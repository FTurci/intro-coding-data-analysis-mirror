[
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html",
    "href": "01/week_01_intro_to_data_types_advanced.html",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "Welcome to the Week 1 Advanced Python Notebook. This notebook is designed for students who already have substantial experience with Python and feel confident working with both the Beginner and Intermediate material.\nYour task today is to carefully read through the content and complete the exercises at the end. These exercises are more challenging and are intended to deepen your understanding of how Python handles data behind the scenes.\n\nImportant: This notebook is only recommended if you are already very confident with Python. Before beginning, you must have attempted at least \\(4\\) exercises from both the Beginner and Intermediate notebooks. If you have not done so, please return to those notebooks first, as the material here builds directly on those foundations.\n\nIn this notebook, you will explore the critical differences between immutable and mutable data types in Python. Specifically, you will learn how Python handles copying and references, which can be critical knowledge when it comes to debugging complex code.\nWork through the examples carefully, and take your time with the exercises. They are designed to stretch your understanding and prepare you for advanced applications of Python.\n\n\n\nWelcome Page\nBeginner: Basic Data Types\nIntermediate: Collections\nAdvanced: Copying and References\n\nImmutable vs Mutable\nThe id Function\nExercises\n\nSlides (Powerpoint)\n\n\n\n\nIn Python, all data types can be described as either “immutable” or “mutable”.\nTo understand the difference between “immutable” and “mutable” types, it may be useful to introduce the notion of a reference. You can think of a reference as an address which tells us where some data lives physically on a machine. When we talk about variables, we really are talking about reference’s (which we have named) that point us to some data in memory.\nWhen you reassign the value of a variable in your code, there are actually two possible things that could be happening. The reference could be changed (i.e. the variable now represents a different place in memory), or the data itself could be changed (i.e. the variable is still “looking” at the same location in memory, but the data that is stored there has changed).\nWhat is important to know here is that when you change the value of a variable which has an “immutable” data type you are changing a reference whereas when you are changing “mutable” variables you are changing the data itself. Examples of mutable data types in Python include the list, dictionary and the set. On the other hand, examples of immutable data types are given by the int, float, decimal, bool and the tuple. In general, the more complicated data types discussed so far are “mutable”.\nThe distinction between a data type being “mutable” or “immutable” may seem dull and/or trivial but, in practice, can result in some very unexpected behaviour, especially when multiple variables are using the same reference (i.e. “looking” at the same place in memory)!\nFor example, in the below code we may expect a and b to have different values:\n\na = 7\nb = a # a and b are now both looking in the same place in memory\na = 10 # Here we have changed the reference\nprint(a)\nprint(b) # Changing a has not changed b\n\n10\n7\n\n\nAnd they do! However, if we change a from being 7 to a list containing 7, perhaps surprisingly, changing the value of a also changes the value b!\n\na = [7]\nb = a # a and b are now both looking in the same place in memory\na[0] = 10 # Here we have changed the data itself!\nprint(a)\nprint(b) # Changing a has changed b\n\n[10]\n[10]\n\n\nIn both the examples above, we start by assigning a and b as references to the same location in memory.\nIn the first example, when we assign a=10, we are telling Python that a must change where it is “looking” in the computers memory. This does not have any effect on the value of b.\nIn the second example, however, when we assign a[0]=10, we are telling Python that the data stored in the location which a is “looking” at at must be changed. As b is also “looking” at this location in memory, this does have an effect on the value of b. It has changed!\nIt is worth noting though that if an operation is performed then a copy might be made:\n\na = [7]\nb = a*2 # In this case b is a reference to a new object.\na[0] = 10\nprint(a)\nprint(b) # Changing a has not changed b\n\n[10]\n[7, 7]\n\n\nIn this case, to ensure we are working with a copy of a and not just a reference to the same variable, we can use the list constructor (see below).\n\nNote: In this case a is a list so we use the list constructor. For other datatypes similar constructors exist and would be used in this situation (e.g. set, dict, etc…).\n\n\na = [7]\nb = list(a) # This time, a and b are not both looking in the same place in memory!\na[0] = 10\nprint(a)\nprint(b) # Changing a has not changed b\n\n[10]\n[7]\n\n\n\nWarning: Errors of this type can often cause extremely anti-intuitive behaviour, including unexpected interactions between functions.\nFor example, in the below a function is called on a variable b, yet a seemingly unrelated variable a was affected by calling the function. This is because a and b were both references to the same object in memory, as oppose to being distinct copies of the object.\nIf you are not familiar with functions, do not worry; these will be covered in depth later in the course and, for now, move past this example.\n\n\ndef function1(x):\n    x.append(10)\n    return(x)\n\n# Create a variable a\na = [3]\nprint(a)\n\n# Set b equal to a\nb = a\n\n# Run function1 on b; surely this couldn't affect a...\nc = function1(b)\n\n# In actual fact, as a and b are both names for the same object~\n# in memory, changing b was the same as changing a (note that \n# the append operation in the function is where b was changed).\nprint(a)\n\n[3]\n[3, 10]\n\n\n\n\n\nNow that we understand the difference between mutable and immutable types, let’s take a look at the Python id() function, which can help us visualise what is happening with references and memory locations.\nThe id() function returns the unique identifier (memory address) of an object. This identifier tells us exactly where some data lives physically on a machine - essentially showing us the reference that a variable is pointing to.\n\n# Basic usage of id()\nx = 42\nprint(\"ID of x:\", id(x))\nprint(\"ID of the literal 42:\", id(42))\n\nID of x: 4386909224\nID of the literal 42: 4386909224\n\n\nWith immutable data types, when you reassign a variable, you are changing the reference (the variable now points to a different location in memory). Let’s see this with our integer example:\n\nprint(\"---------------\")\nprint(\"Before a = 10:\")\nprint(\"---------------\")\n\n# Integer example - reproducing the behaviour from earlier\na = 7\nb = a # a and b are now both looking in the same place in memory\nprint(\"a = \" + str(a) + \", id(a) = \" + str(id(a)))\nprint(\"b = \" + str(b) + \", id(b) = \" + str(id(b)))\nprint(\"a and b reference the same object:\", id(a) == id(b))\n\n# What happens when we \"change\" the integer?\noriginal_id = id(a)\na = 10 # Here we have changed the reference\nprint(\"---------------\")\nprint(\"After a = 10:\")\nprint(\"---------------\")\nprint(\"a = \" + str(a) + \", id(a) = \" + str(id(a)))\nprint(\"b = \" + str(b) + \",  id(b) = \" + str(id(b)))\nprint(\"a and b now reference different objects:\", id(a) == id(b))\nprint(\"id(a) changed:\", id(a) == original_id)\nprint(\"This is why changing a did not change b!\")\n\n---------------\nBefore a = 10:\n---------------\na = 7, id(a) = 4386908104\nb = 7, id(b) = 4386908104\na and b reference the same object: True\n---------------\nAfter a = 10:\n---------------\na = 10, id(a) = 4386908200\nb = 7,  id(b) = 4386908104\na and b now reference different objects: False\nid(a) changed: False\nThis is why changing a did not change b!\n\n\nWith mutable data types, when you modify the data, you are changing the data itself (the reference stays the same - the variable is still “looking” at the same location in memory). Let’s reproduce our list example:\n\nprint(\"---------------\")\nprint(\"Before a[0] = 10:\")\nprint(\"---------------\")\n\n# List example - reproducing the behaviour from earlier\na = [7]\nb = a # a and b are now both looking in the same place in memory\nprint(\"a = \" + str(a) + \", id(a) = \" + str(id(a)))\nprint(\"b = \" + str(b) + \", id(b) = \" + str(id(b)))\nprint(\"a and b reference the same object:\", id(a) == id(b))\n\n# Modifying the list in place\noriginal_id = id(a)\na[0] = 10 # Here we have changed the data itself!\nprint(\"---------------\")\nprint(\"After a[0] = 10:\")\nprint(\"---------------\")\nprint(\"a = \" + str(a) + \", id(a) = \" + str(id(a)))\nprint(\"b = \" + str(b) + \", id(b) = \" + str(id(b)))\nprint(\"a and b still reference the same object:\", id(a) == id(b))\nprint(\"id(a) remained the same:\", id(a) == original_id)\nprint(\"This is why changing a also changed b!\")\n\n---------------\nBefore a[0] = 10:\n---------------\na = [7], id(a) = 4430072192\nb = [7], id(b) = 4430072192\na and b reference the same object: True\n---------------\nAfter a[0] = 10:\n---------------\na = [10], id(a) = 4430072192\nb = [10], id(b) = 4430072192\na and b still reference the same object: True\nid(a) remained the same: True\nThis is why changing a also changed b!\n\n\n\n\n\nThe is operator and == operator are often confused with one another but they are not same. The is checks if both the variables point to the same object in memory whereas the == sign checks if the values of the two variables are equal.\nIf the is operator returns True then the equality is definitely True, but the opposite may or may not be the case. For an example see the below.\n\nWarning: Avoid using the is operator for “immutable” types such as strings and numbers; the result is unpredictable and in most cases the == is more appropriate for purpose.\n\n\n# a and b are set to both represent the same object in memory.\na = b = [1,2,3]\n\n# c represents a list in a different location in memory but with the same\n# value as a and b\nc = [1,2,3]\nprint(a)\nprint(b)\nprint(c)\n\n# a, b and c are all equal\nprint('a == b: ', a == b)\nprint('a == c: ', a == c)\n\n# But only a and b point to the same location in memory, c is treated as a seperate 'copy' of [1,2,3]\nprint('a is b: ', a is b)\nprint('a is c: ', a is c)\n\n[1, 2, 3]\n[1, 2, 3]\n[1, 2, 3]\na == b:  True\na == c:  True\na is b:  True\na is c:  False\n\n\n\n\n\nQuestion 1: Predict the output of the following code. What will be printed and why?\nlist_a = [1, 2, 3]\nlist_b = list_a\nlist_a.append(4)\nprint(list_b)\nRun the code in the box below to verify your answer.\n\n# Write your code here...\n\nQuestion 2: Consider these two similar-looking pieces of code. Predict what each will output and explain the difference:\nCode A:\na = [1, 2, 3]\nb = a\na = [4, 5, 6]\nprint(b)\nCode B:\na = [1, 2, 3]\nb = a\na[0] = 4\na[1] = 5\na[2] = 6\nprint(b)\nRun the code above to verify your answers.\n\n# Write your code here...\n\nQuestion 3: In the below we have a list of 3 values, x=1, y=2 and z=3. We want to work out the value of:\n\n\\(x + y + z + x^2 + y^2 + z^2\\) \\(= 1 + 2 + 3 + 1 + 4 + 9\\) \\(= 20\\)\n\nThe below code should give us \\(20\\) as an answer… but it doesn’t - something has gone wrong! Can you see what is wrong in the below code? How would you fix it?\n\nxyz = [1,2,3]\n\n# Make a list of x squared, y squared, z squared\nxyzsquared = xyz\nxyzsquared[0] = xyzsquared[0]**2\nxyzsquared[1] = xyzsquared[1]**2\nxyzsquared[2] = xyzsquared[2]**2\n\n# Get x, y and z from xyz list\nx = xyz[0]\ny = xyz[1]\nz = xyz[2]\n\n# Get x squared, y squared and z squared from\n# xyzsquared list\nxsquared = xyzsquared[0]\nysquared = xyzsquared[1]\nzsquared = xyzsquared[2]\n\nprint(x + y + z + xsquared + ysquared + zsquared)\n\n28\n\n\nQuestion 4: You have a list of lists representing a grid. You want to create a backup copy before making changes, but the following approach doesn’t work correctly. Explain what has gone wrong here.\n\ngrid = [[1, 2], [3, 4], [5, 6]]\nbackup = list(grid)\n\n# Make a change to the grid\ngrid[0][0] = 999\n\nprint(\"grid =\", grid)\nprint(\"backup =\", backup)  # This should be unchanged, but it isn't!\n\ngrid = [[999, 2], [3, 4], [5, 6]]\nbackup = [[999, 2], [3, 4], [5, 6]]\n\n\nQuestion 5: The following code creates a 3x3 grid filled with zeros, but when you try to modify one cell, unexpected behavior occurs. Identify the problem and provide a solution:\n\n# This code has a problem!\ngrid = [[0] * 3] * 3\nprint(\"Initial grid:\", grid)\n\ngrid[0][0] = 1\nprint(\"After setting grid[0][0] = 1:\", grid)\n# Expected: [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n# Actual: [[1, 0, 0], [1, 0, 0], [1, 0, 0]]\n\nInitial grid: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\nAfter setting grid[0][0] = 1: [[1, 0, 0], [1, 0, 0], [1, 0, 0]]\n\n\n\n# Write your solution code here...",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#immutable-vs-mutable",
    "href": "01/week_01_intro_to_data_types_advanced.html#immutable-vs-mutable",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "In Python, all data types can be described as either “immutable” or “mutable”.\nTo understand the difference between “immutable” and “mutable” types, it may be useful to introduce the notion of a reference. You can think of a reference as an address which tells us where some data lives physically on a machine. When we talk about variables, we really are talking about reference’s (which we have named) that point us to some data in memory.\nWhen you reassign the value of a variable in your code, there are actually two possible things that could be happening. The reference could be changed (i.e. the variable now represents a different place in memory), or the data itself could be changed (i.e. the variable is still “looking” at the same location in memory, but the data that is stored there has changed).\nWhat is important to know here is that when you change the value of a variable which has an “immutable” data type you are changing a reference whereas when you are changing “mutable” variables you are changing the data itself. Examples of mutable data types in Python include the list, dictionary and the set. On the other hand, examples of immutable data types are given by the int, float, decimal, bool and the tuple. In general, the more complicated data types discussed so far are “mutable”.\nThe distinction between a data type being “mutable” or “immutable” may seem dull and/or trivial but, in practice, can result in some very unexpected behaviour, especially when multiple variables are using the same reference (i.e. “looking” at the same place in memory)!\nFor example, in the below code we may expect a and b to have different values:\n\na = 7\nb = a # a and b are now both looking in the same place in memory\na = 10 # Here we have changed the reference\nprint(a)\nprint(b) # Changing a has not changed b\n\n10\n7\n\n\nAnd they do! However, if we change a from being 7 to a list containing 7, perhaps surprisingly, changing the value of a also changes the value b!\n\na = [7]\nb = a # a and b are now both looking in the same place in memory\na[0] = 10 # Here we have changed the data itself!\nprint(a)\nprint(b) # Changing a has changed b\n\n[10]\n[10]\n\n\nIn both the examples above, we start by assigning a and b as references to the same location in memory.\nIn the first example, when we assign a=10, we are telling Python that a must change where it is “looking” in the computers memory. This does not have any effect on the value of b.\nIn the second example, however, when we assign a[0]=10, we are telling Python that the data stored in the location which a is “looking” at at must be changed. As b is also “looking” at this location in memory, this does have an effect on the value of b. It has changed!\nIt is worth noting though that if an operation is performed then a copy might be made:\n\na = [7]\nb = a*2 # In this case b is a reference to a new object.\na[0] = 10\nprint(a)\nprint(b) # Changing a has not changed b\n\n[10]\n[7, 7]\n\n\nIn this case, to ensure we are working with a copy of a and not just a reference to the same variable, we can use the list constructor (see below).\n\nNote: In this case a is a list so we use the list constructor. For other datatypes similar constructors exist and would be used in this situation (e.g. set, dict, etc…).\n\n\na = [7]\nb = list(a) # This time, a and b are not both looking in the same place in memory!\na[0] = 10\nprint(a)\nprint(b) # Changing a has not changed b\n\n[10]\n[7]\n\n\n\nWarning: Errors of this type can often cause extremely anti-intuitive behaviour, including unexpected interactions between functions.\nFor example, in the below a function is called on a variable b, yet a seemingly unrelated variable a was affected by calling the function. This is because a and b were both references to the same object in memory, as oppose to being distinct copies of the object.\nIf you are not familiar with functions, do not worry; these will be covered in depth later in the course and, for now, move past this example.\n\n\ndef function1(x):\n    x.append(10)\n    return(x)\n\n# Create a variable a\na = [3]\nprint(a)\n\n# Set b equal to a\nb = a\n\n# Run function1 on b; surely this couldn't affect a...\nc = function1(b)\n\n# In actual fact, as a and b are both names for the same object~\n# in memory, changing b was the same as changing a (note that \n# the append operation in the function is where b was changed).\nprint(a)\n\n[3]\n[3, 10]",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#the-id-function",
    "href": "01/week_01_intro_to_data_types_advanced.html#the-id-function",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "Now that we understand the difference between mutable and immutable types, let’s take a look at the Python id() function, which can help us visualise what is happening with references and memory locations.\nThe id() function returns the unique identifier (memory address) of an object. This identifier tells us exactly where some data lives physically on a machine - essentially showing us the reference that a variable is pointing to.\n\n# Basic usage of id()\nx = 42\nprint(\"ID of x:\", id(x))\nprint(\"ID of the literal 42:\", id(42))\n\nID of x: 4386909224\nID of the literal 42: 4386909224\n\n\nWith immutable data types, when you reassign a variable, you are changing the reference (the variable now points to a different location in memory). Let’s see this with our integer example:\n\nprint(\"---------------\")\nprint(\"Before a = 10:\")\nprint(\"---------------\")\n\n# Integer example - reproducing the behaviour from earlier\na = 7\nb = a # a and b are now both looking in the same place in memory\nprint(\"a = \" + str(a) + \", id(a) = \" + str(id(a)))\nprint(\"b = \" + str(b) + \", id(b) = \" + str(id(b)))\nprint(\"a and b reference the same object:\", id(a) == id(b))\n\n# What happens when we \"change\" the integer?\noriginal_id = id(a)\na = 10 # Here we have changed the reference\nprint(\"---------------\")\nprint(\"After a = 10:\")\nprint(\"---------------\")\nprint(\"a = \" + str(a) + \", id(a) = \" + str(id(a)))\nprint(\"b = \" + str(b) + \",  id(b) = \" + str(id(b)))\nprint(\"a and b now reference different objects:\", id(a) == id(b))\nprint(\"id(a) changed:\", id(a) == original_id)\nprint(\"This is why changing a did not change b!\")\n\n---------------\nBefore a = 10:\n---------------\na = 7, id(a) = 4386908104\nb = 7, id(b) = 4386908104\na and b reference the same object: True\n---------------\nAfter a = 10:\n---------------\na = 10, id(a) = 4386908200\nb = 7,  id(b) = 4386908104\na and b now reference different objects: False\nid(a) changed: False\nThis is why changing a did not change b!\n\n\nWith mutable data types, when you modify the data, you are changing the data itself (the reference stays the same - the variable is still “looking” at the same location in memory). Let’s reproduce our list example:\n\nprint(\"---------------\")\nprint(\"Before a[0] = 10:\")\nprint(\"---------------\")\n\n# List example - reproducing the behaviour from earlier\na = [7]\nb = a # a and b are now both looking in the same place in memory\nprint(\"a = \" + str(a) + \", id(a) = \" + str(id(a)))\nprint(\"b = \" + str(b) + \", id(b) = \" + str(id(b)))\nprint(\"a and b reference the same object:\", id(a) == id(b))\n\n# Modifying the list in place\noriginal_id = id(a)\na[0] = 10 # Here we have changed the data itself!\nprint(\"---------------\")\nprint(\"After a[0] = 10:\")\nprint(\"---------------\")\nprint(\"a = \" + str(a) + \", id(a) = \" + str(id(a)))\nprint(\"b = \" + str(b) + \", id(b) = \" + str(id(b)))\nprint(\"a and b still reference the same object:\", id(a) == id(b))\nprint(\"id(a) remained the same:\", id(a) == original_id)\nprint(\"This is why changing a also changed b!\")\n\n---------------\nBefore a[0] = 10:\n---------------\na = [7], id(a) = 4430072192\nb = [7], id(b) = 4430072192\na and b reference the same object: True\n---------------\nAfter a[0] = 10:\n---------------\na = [10], id(a) = 4430072192\nb = [10], id(b) = 4430072192\na and b still reference the same object: True\nid(a) remained the same: True\nThis is why changing a also changed b!",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#the-is-operator",
    "href": "01/week_01_intro_to_data_types_advanced.html#the-is-operator",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "The is operator and == operator are often confused with one another but they are not same. The is checks if both the variables point to the same object in memory whereas the == sign checks if the values of the two variables are equal.\nIf the is operator returns True then the equality is definitely True, but the opposite may or may not be the case. For an example see the below.\n\nWarning: Avoid using the is operator for “immutable” types such as strings and numbers; the result is unpredictable and in most cases the == is more appropriate for purpose.\n\n\n# a and b are set to both represent the same object in memory.\na = b = [1,2,3]\n\n# c represents a list in a different location in memory but with the same\n# value as a and b\nc = [1,2,3]\nprint(a)\nprint(b)\nprint(c)\n\n# a, b and c are all equal\nprint('a == b: ', a == b)\nprint('a == c: ', a == c)\n\n# But only a and b point to the same location in memory, c is treated as a seperate 'copy' of [1,2,3]\nprint('a is b: ', a is b)\nprint('a is c: ', a is c)\n\n[1, 2, 3]\n[1, 2, 3]\n[1, 2, 3]\na == b:  True\na == c:  True\na is b:  True\na is c:  False",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#exercises",
    "href": "01/week_01_intro_to_data_types_advanced.html#exercises",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "Question 1: Predict the output of the following code. What will be printed and why?\nlist_a = [1, 2, 3]\nlist_b = list_a\nlist_a.append(4)\nprint(list_b)\nRun the code in the box below to verify your answer.\n\n# Write your code here...\n\nQuestion 2: Consider these two similar-looking pieces of code. Predict what each will output and explain the difference:\nCode A:\na = [1, 2, 3]\nb = a\na = [4, 5, 6]\nprint(b)\nCode B:\na = [1, 2, 3]\nb = a\na[0] = 4\na[1] = 5\na[2] = 6\nprint(b)\nRun the code above to verify your answers.\n\n# Write your code here...\n\nQuestion 3: In the below we have a list of 3 values, x=1, y=2 and z=3. We want to work out the value of:\n\n\\(x + y + z + x^2 + y^2 + z^2\\) \\(= 1 + 2 + 3 + 1 + 4 + 9\\) \\(= 20\\)\n\nThe below code should give us \\(20\\) as an answer… but it doesn’t - something has gone wrong! Can you see what is wrong in the below code? How would you fix it?\n\nxyz = [1,2,3]\n\n# Make a list of x squared, y squared, z squared\nxyzsquared = xyz\nxyzsquared[0] = xyzsquared[0]**2\nxyzsquared[1] = xyzsquared[1]**2\nxyzsquared[2] = xyzsquared[2]**2\n\n# Get x, y and z from xyz list\nx = xyz[0]\ny = xyz[1]\nz = xyz[2]\n\n# Get x squared, y squared and z squared from\n# xyzsquared list\nxsquared = xyzsquared[0]\nysquared = xyzsquared[1]\nzsquared = xyzsquared[2]\n\nprint(x + y + z + xsquared + ysquared + zsquared)\n\n28\n\n\nQuestion 4: You have a list of lists representing a grid. You want to create a backup copy before making changes, but the following approach doesn’t work correctly. Explain what has gone wrong here.\n\ngrid = [[1, 2], [3, 4], [5, 6]]\nbackup = list(grid)\n\n# Make a change to the grid\ngrid[0][0] = 999\n\nprint(\"grid =\", grid)\nprint(\"backup =\", backup)  # This should be unchanged, but it isn't!\n\ngrid = [[999, 2], [3, 4], [5, 6]]\nbackup = [[999, 2], [3, 4], [5, 6]]\n\n\nQuestion 5: The following code creates a 3x3 grid filled with zeros, but when you try to modify one cell, unexpected behavior occurs. Identify the problem and provide a solution:\n\n# This code has a problem!\ngrid = [[0] * 3] * 3\nprint(\"Initial grid:\", grid)\n\ngrid[0][0] = 1\nprint(\"After setting grid[0][0] = 1:\", grid)\n# Expected: [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n# Actual: [[1, 0, 0], [1, 0, 0], [1, 0, 0]]\n\nInitial grid: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\nAfter setting grid[0][0] = 1: [[1, 0, 0], [1, 0, 0], [1, 0, 0]]\n\n\n\n# Write your solution code here...",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html",
    "href": "01/week_01_intro_to_data_types_intermediate.html",
    "title": "",
    "section": "",
    "text": "Code",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html#tuples-and-lists",
    "href": "01/week_01_intro_to_data_types_intermediate.html#tuples-and-lists",
    "title": "",
    "section": "Tuples and lists",
    "text": "Tuples and lists\nIn this section, we are going to look at Tuples and Lists.\n\nA tuple is a collection which is ordered and unchangeable. In Python tuples are written with round brackets.\nA list is a collection which is ordered and changeable. In Python lists are written with square brackets.\n\n*where changeable means that once\nBoth tuples and lists are built-in data types, can hold elements of arbitrary datatypes and behave, in many respects, like mathematical vectors. However, for numerical vectors and arrays it is much better to use numpy arrays, which are covered later in the course.\nBelow are some examples of lists and tuples. Note again that lists and tuples can contain data of any type.\n\n# Example tuple\nexample_tuple = ('random string', 8, True)\nprint(example_tuple)\n\n# Example list\nexample_list = [10, 'str', False]\nprint(example_list)\n\n('random string', 8, True)\n[10, 'str', False]\n\n\nThis means they can also be nested. I.e. we can put a list in a list, a tuple in a tuple, a list in a tuple and a tuple in a list!\n\nTupleAndListInTuple = (example_tuple, example_list)\nTupleAndListInList = [example_tuple, example_list]\nprint(TupleAndListInTuple)\nprint(TupleAndListInList)\n\n(('random string', 8, True), [10, 'str', False])\n[('random string', 8, True), [10, 'str', False]]\n\n\n\nAdding to Lists and Tuples\nLists and tuples can be added to using the concatenation operator, +, like so:\n\nexample_list = [1, 2, 3]\nexample_list = example_list + [4]\nexample_list +=  [5]\nprint(example_list)\n\nexample_tuple = (1, 2, 3)\nexample_tuple = example_tuple + (4,)\nexample_tuple +=  (5,)\nprint(example_tuple)\n\n[1, 2, 3, 4, 5]\n(1, 2, 3, 4, 5)\n\n\n\n\nIndexing Lists and Tuples\nTo index in python, square brackets are used. This is a common convention which applies to almost all vector-like datatypes in Python, e.g. tuples, lists, strings, numpy arrays, etc.\nPython uses zero indexing, which means that the first element in a list of length n is indexed as 0 and the last element is indexed as n-1. For example see the below (note that the same can also be done for tuples):\n\nexample_list = [2,'str',4,9,0]\n\n# Work out the length of the list\nn = len(example_list)\n\nprint(example_list[0])\nprint(example_list[n-1])\nprint(example_list[3])\n#print(example_list[n]) # This line will fail as the highest index for a python list is n-1\n\n2\n0\n9\n\n\nNegative numbers can also be used to index lists (and other similar datatypes). For example, the index -1 will give the last element of the list, the index -2 will give the second to last element of the list and so on. This is known as circular wrap-around.\nFor a list of length n any index can be used between -n and (n-1) (inclusive) to access elements in the list. Indices outside of this range, however, will give an “index out of range” error.\n\n# Examples of circular wrap-around\nprint(example_list)\nprint(example_list[-2])\nprint(example_list[-4])\nprint(example_list[-n])\n\n# Examples of indices which will fail/give errors\n#print(example_list[n])\n#print(example_list[-n-1])\n#print(example_list[20*n + 2]) \n#print(example_list[-20*n - 2])\n\n[2, 'str', 4, 9, 0]\n9\nstr\n2\n\n\nNote that nested lists and tuples support nested indexing but this involve multiple sets of square brackets (for example see below).\nYou may be more familiar with indexing of the form example_list[a,b] (i.e. only one set of square brackets); this syntax does exist in Python but unfortunately not for lists. In fact, this syntax is used heavily by numpy arrays (which we will cover later in the course).\n\nexampleNested = [('str', 20, 'str2'), [False, 8, 9.5]]\nprint(exampleNested[0][1])\nprint(exampleNested[1][0])\nprint(exampleNested[1][-1])\n\n20\nFalse\n9.5\n\n\n\n\nSlicing Tuples and Lists\nA range of index values can be specified to extract values from a list using a colon, :. This way of accessing data is known as slicing and can be performed as follows:\n\nexample_list = [1,2,3,4,5]\nprint(example_list[0:3])\n\n[1, 2, 3]\n\n\n\nWarning: Often, in other languages such as Matlab the syntax 0:3 represents the range [0,1,2,3]; however, in python 0:3 represents only [0,1,2]. In other words the syntax k:n includes [k,k+1,...n-1] but does not include n itself! This is common to all data types in python and should always be remembered when indexing anything in Python!\n\nWhen indexing in python you can leave the start and end values implicit. This will give the same effect as starting from the beginning of the list and ending at the end of the list. For example:\n\nexample_list = [1,2,3,4,5]\n\n# The below two lines will give the same\nprint(example_list[0:3])\nprint(example_list[:3])\n\n# The below two lines will also give the same\nprint(example_list[2:5])\nprint(example_list[2:])\n\n# This will print the whole list\nprint(example_list[:])\n\n[1, 2, 3]\n[1, 2, 3]\n[3, 4, 5]\n[3, 4, 5]\n[1, 2, 3, 4, 5]\n\n\nYou can also indicate a step size when indexing by using the following syntax:\n\n# Print every second element between the 0th and 5th elements\nprint(example_list[0:5:2])\nprint(example_list[::2])\n\n[1, 3, 5]\n[1, 3, 5]\n\n\nAnd you can run backwards through the list by using negative integers as the step size. For example:\n\n# Print the list backwards\nprint(example_list[::-1])\n\n[5, 4, 3, 2, 1]\n\n\n\n\nOperations on Lists and Tuples\nOther operations are also available for lists and tuples. Most notably, the * symbol can be used to replicate a list or tuple like so:\n\nexample_list = [1,2,3,4]\nprint(example_list*2)\n\nexample_tuple = (1,2,3,4)\nprint(example_tuple*2)\n\n[1, 2, 3, 4, 1, 2, 3, 4]\n(1, 2, 3, 4, 1, 2, 3, 4)\n\n\nOther notable operations for lists include:\n\ninsert: This function adds an element to the list at a specified position.\npop: This function removes the element in the list at the specified position.\nremove: This function removes the item with the specified value from the list.\nreverse: This function reverses the order of the list.\nsort: This function sorts the list.\n\nA few examples of these functions are given below. Try changing and editing the below code to check your understanding! Again, this is by no means a comprehensive list; more information can be found in the Python API or in the W3 schools documentation.\n\n# Here is an example list\nexample_list = [1,2,3,4,5]\nprint(example_list)\n\n# We will now insert the value 3 at index 2\nexample_list.insert(2,3)\nprint(example_list)\n\n# We will now remove the item in the 4th position of the list\nexample_list.pop(4)\nprint(example_list)\n\n# We will now remove an element with the value 3 from the list\nexample_list.remove(3)\nprint(example_list)\n\n# We will now reverse the list\nexample_list.reverse()\nprint(example_list)\n\n# We will now sort the list\nexample_list.sort()\nprint(example_list)\n\n[1, 2, 3, 4, 5]\n[1, 2, 3, 3, 4, 5]\n[1, 2, 3, 3, 5]\n[1, 2, 3, 5]\n[5, 3, 2, 1]\n[1, 2, 3, 5]\n\n\nNot as many operations are available for tuples as tuples are immutable (not meant to change in value). Two available operations are:\n\ncount: This function returns the number of times a specified value occurs in the tuple.\nindex: This function searches the tuple for a specified value and returns the position of where it was found.\n\nExamples of these are given below. For more information on tuples please visit the Python API or the W3 schools documentation.\n\nexample_tuple = (1,2,3,3,4,5,6)\n\n# Count how many times the value 3 occurs\nprint(example_tuple.count(3))\n\n# Find the number 2 in the tuple and return it's index\n# (Remember indexing starts at 0 in Python!)\nprint(example_tuple.index(2))\n\n2\n1",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html#sets-and-dictionarys",
    "href": "01/week_01_intro_to_data_types_intermediate.html#sets-and-dictionarys",
    "title": "",
    "section": "Sets and Dictionarys",
    "text": "Sets and Dictionarys\nIn this section, we are going to look in more detail at Sets and Dictionarys.\n\nA set is a collection which is unordered, changeable and unindexed. In Python sets are written with curly brackets.\nA dictionary is a collection which is unordered, changeable and indexed. In Python dictionarys are also written with curly brackets but also with keys and values.\n\nLike tuples and lists, both sets and dictionarys are built-in python types and can hold elements of arbitrary data types. However, unlike tuples and lists they do not behave like vectors as they are unordered. In other programming languages, such as Java, you may have heard of dictionarys referred to as hashmaps.\nBelow are some examples of sets and dictionarys.\n\nexample_set = {1,'str',3}\nprint(example_set)\n\nexample_dict = {'A':1, 'B':'str'}\nprint(example_dict)\n\n# We can also create dictionaries using the dict function if using strings for keys\nexample_dict = dict(A=1, B='str')\nprint(example_dict)\n\n{1, 'str', 3}\n{'A': 1, 'B': 'str'}\n{'A': 1, 'B': 'str'}\n\n\n\nAdding elements to and retreiving elements from Dictionarys\nElements can be added to dictionarys as keys and values. For example; in the first line below the key is a and the value is b. Note that a key does not have to be a string; integers and floats work just as well. Values can be of any data type.\n\n# Here we assign value 'b' to key 'a'\nexample_dict['a'] = 'b'\n\n# Here we assign value 2 to key 10\nexample_dict[10] = 2\n\n# Here we assign value [2,1] to key 1.1\nexample_dict[1.1] = [2,1]\n\nprint(example_dict)\n\n{'A': 1, 'B': 'str', 'a': 'b', 10: 2, 1.1: [2, 1]}\n\n\nWe can then retreive values from the dictionary using the keys we stored them under. This can be done with either square brackets or the built-in get function. For example:\n\n# Using square brackets\nprint(example_dict[10])\nprint(example_dict['a'])\n\n# Using the `get` function\nprint(example_dict.get(10))\nprint(example_dict.get('a'))\n\n2\nb\n2\nb\n\n\n\n\nRemoving elements from a dictionary\nElements can be removed from a dictionary using the pop and del methods. For example:\n\n# Example dictionary\nexample_dict = {'A':1, 'B':'str', 'C':2}\nprint(example_dict)\n\n# Remove element 'A'\nexample_dict.pop('A')\nprint(example_dict)\n\n# Remove element C\ndel example_dict['C']\nprint(example_dict)\n\n{'A': 1, 'B': 'str', 'C': 2}\n{'B': 'str', 'C': 2}\n{'B': 'str'}\n\n\n\n\nOperations on Dictionarys\nOther operations are also available for dictionarys. Some of the most useful of these are;\n\nkeys: This function returns a list containing the dictionary’s keys.\nvalues: This function returns a list of all the values in the dictionary.\nitems: This function returns a list containing a tuple for each (key, value) pair.\n\nExamples of these functions are given below. For full documentation and details on more functions see the Python API and W3 schools Python documentation.\n\nexample_dict = {'A':1, 'B':'str', 'C':2}\nprint(example_dict.keys())\nprint(example_dict.values())\nprint(example_dict.items())\n\ndict_keys(['A', 'B', 'C'])\ndict_values([1, 'str', 2])\ndict_items([('A', 1), ('B', 'str'), ('C', 2)])\n\n\n\n\nAdding elements to a set\nElements can be added to a set using the add function. For example, see the below code.\nNote that a set is designed to mimic the idea of a set in mathematics and, therefore, sets do not allow for duplicate entries. An entry is either in or not in a set; it cannot be “in” a set twice.\nMultiple elements can also be added to a set at once using the update method.\n\nexample_set = {1,'str',3}\nprint(example_set)\n\n# Add an element\nexample_set.add(8)\nprint(example_set)\n\n# Add another element; note this element is already in the set and therefore the\n# set is left unchanged\nexample_set.add(1)\nprint(example_set)\n\n# Add two elements to the set\nexample_set.update([10,'blah'])\nprint(example_set)\n\n{1, 'str', 3}\n{8, 1, 'str', 3}\n{8, 1, 'str', 3}\n{1, 3, 8, 'str', 10, 'blah'}\n\n\nHowever, there is no notion of indexing for Python sets as sets are unordered. This means that individual elements cannot be accessed in the same manor as in dictionarys, lists and tuples. We can check if an element is in a set, however, using the in keyword.\n\nprint(1 in example_set)\nprint(2 in example_set)\n\nTrue\nFalse\n\n\n\n\nRemoving elements from a set\nElements can be removed from a set using the remove function. Note: the remove function will errror if the requested value is not in the set.\n\nexample_set.remove(1)\nprint(example_set)\n\n{3, 8, 'str', 10, 'blah'}\n\n\n\n\nOperations on Sets\nOther operations are also available for sets, many of which are designed to mimic mathematic functions. For example:\n\ndifference: This function returns a set containing the difference between two or more sets.\nintersection: This function returns a set which is the intersection of two other sets.\nissubset: This function returns True if the first set input contains the second set input and False otherwise.\nissuperset: This function returns True if the first set input is contained within the second set input and False otherwise.\nunion: This function returns a set containing the union of input sets.\n\nExamples of these are given below. For full documentation and details on more functions see the Python API and W3 schools Python documentation.\n\nprint('Sets')\nset1 = {1,2,3,4}\nset2 = {2,4,5,6}\nprint(set1)\nprint(set2)\n\n# Difference\nprint('\\nSet Differences')\nprint(set1.difference(set2))\nprint(set2.difference(set1))\n\n# Intersection\nprint('\\nIntersection')\nprint(set1.intersection(set2))\n\n# Is subset or superset\nprint('\\nSubset/Superset')\nprint(set1.issubset(set2))\nprint(set1.issuperset({1,2}))\n\n# Union\nprint('\\nUnion')\nprint(set1.union(set2))\n\nSets\n{1, 2, 3, 4}\n{2, 4, 5, 6}\n\nSet Differences\n{1, 3}\n{5, 6}\n\nIntersection\n{2, 4}\n\nSubset/Superset\nFalse\nTrue\n\nUnion\n{1, 2, 3, 4, 5, 6}",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html#exercises",
    "href": "01/week_01_intro_to_data_types_intermediate.html#exercises",
    "title": "",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: The below code creates a list of numbers:\n\n# List of numbers\nnums = [5, 2, 8, 2, 9]\n\nUsing this list, write code which does the following: 1. retrieves the third element of the list 2. slice the first three elements of the list 3. replaces the last element with 10 4. appends 7 to the end of the list 5. removes the first occurrence of 2\nMake sure to print the list after each change.\n\n# Write your code here...\n\nQuestion 2: The below code creates a list, casts it to a set and then casts it back to a list.\n\n# Create the list\nmy_list = [4,2,3]\n\n# Convert it to a set\nmy_set = set(my_list)\n\n# Convert it back to a list\nmy_new_list = list(my_set)\n\nprint(my_list==my_new_list)\n\nFalse\n\n\nThe new list doesn’t equal the original list. Why do you think this might be?\nHint: Try printing my_list and my_new_list.\nQuestion 3: A string can be converted to a set using the set() constructor. Use this fact to identify which letter appears in string2 but not in string1 below:\n\n# Here are two strings\nstring1 = \"This is a long random sentence - I wonder which letters it contains and which letters it doesn't.\"\nstring2 = \"This task makes a clear and coherent string with words taken inside a small set\"\n\nHint: You might want to recap difference function from this notebook and the lower() function from the beginner notebook.\nQuestion 4: The below code creates a tuple named t.\n\nt = ('a', 'b', 'c', 'd', 'e')\n\nWrite some code which does the following:\n\naccess the first and last elements of t\nslice out ('b', 'c', 'd')\ncheck whether 'c' is in t\nfind the index of 'd' in t\ncount how many times 'a' appears in t\n\n\n# Write your code here...\n\nQuestion 5: You are given the below dataset for 5 individuals in a clinical trial.\n\n\n\nName\nWeight (kg)\nHeight (cm)\n\n\n\n\nJohn\n82\n178\n\n\nAlice\n68\n165\n\n\nMaria\n74\n170\n\n\nDavid\n90\n185\n\n\nSarah\n60\n160\n\n\n\nUsing the collection types introduced in this notebook (lists, tuples, sets, dictionaries - no loops or user-defined functions), choose an appropriate way to represent the clinical-trial table. Write your code in the box below.\n\nmy_data = # Write your code here...\n\n\n  Cell In[29], line 1\n    my_data = # Write your code here...\n              ^\nSyntaxError: invalid syntax",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_home.html",
    "href": "01/week_01_home.html",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "Welcome Page\n\nUsing the Notebooks\nToday’s Material\nGetting Help\n\nBeginner: Basic Data Types\nIntermediate: Collections\nAdvanced: Copying and References\nSlides (Powerpoint)\n\n\n\n\nThe file you have open is aJupyter Notebook. This is an interactive Python environment where you can both write and run code. All of the interactive parts of this course will take place in Jupyter notebooks.\nEach notebook is made up of two types of cells:\n- Text cells (like this one), which introduce and explain new topics.\n- Code cells, which contain Python code you can run and modify.\nTo run a code cell, click inside it and press Shift + Enter. You can also edit the code before running it. Give it a try in the cell below!\n\nprint('Hello World')\n\nHello World\n\n\n\n\n\nToday, we will be learning about data types. As there is a range of ability in the class we have prepared three options for today’s work.\n\nImportant: For today, please choose just one of the options below. You’ll have many opportunities to revisit the other concepts later in the course, so focus on building confidence with the Beginner material before tackling more advanced work.\n\n\n\nIf you are new to coding, or still building confidence in Python, today you should work through the Basic Data Types notebook linked below:\n\nBeginner: Basic Data Types\n\nIn this notebook you will find interactive code blocks and plenty of exercises. Coding is best learned by doing, so take your time to work through the material and attempt as many exercises as you can during today’s session!\n\n\n\nIf you have some coding experience and are already somewhat familiar with basic data types in Python, you may wish to choose this option.\nFirst, please do check over the exercises in the Basic Data Types notebook and ensure you can answer them. Even the most experienced programmers will have gaps in their knowledge, so it is important you check this.\n\nBeginner: Basic Data Types\n\nOnce you feel confident with the material above, move on to the Collections notebook. This will introduce you to Python’s built-in collections and highlight the differences between sets, lists, dicts, and tuples. As always, aim to complete as many of the exercises as you can.\n\nIntermediate: Collections\n\n\n\n\nIf you are an experienced programmer with a strong grasp of Python, begin by reviewing the exercises in the notebooks below to ensure you are fully comfortable with the material:\n\nBeginner: Basic Data Types\n\nIntermediate: Collections\n\nOnce you are confident in your understanding, move on to the following notebook:\n\nAdvanced: Copying and References\n\n\n\n\n\nThere is a lot to remember when first learning Python. To get more help see the Python API. Another useful link is the W3 schools series on Python which is very good, especially for new users. Another way to get help if you are ever unsure what a function is doing is to use thehelp function in the Python terminal like so:\n\nhelp(print)\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n    \n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\nIn class, you can ask for help from the lecturer, demonstrators and your peers around you. We advise you do not ask AI for help unless you are really stuck.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Week 1: Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_home.html#using-the-notebooks",
    "href": "01/week_01_home.html#using-the-notebooks",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "The file you have open is aJupyter Notebook. This is an interactive Python environment where you can both write and run code. All of the interactive parts of this course will take place in Jupyter notebooks.\nEach notebook is made up of two types of cells:\n- Text cells (like this one), which introduce and explain new topics.\n- Code cells, which contain Python code you can run and modify.\nTo run a code cell, click inside it and press Shift + Enter. You can also edit the code before running it. Give it a try in the cell below!\n\nprint('Hello World')\n\nHello World",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Week 1: Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_home.html#todays-material",
    "href": "01/week_01_home.html#todays-material",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "Today, we will be learning about data types. As there is a range of ability in the class we have prepared three options for today’s work.\n\nImportant: For today, please choose just one of the options below. You’ll have many opportunities to revisit the other concepts later in the course, so focus on building confidence with the Beginner material before tackling more advanced work.\n\n\n\nIf you are new to coding, or still building confidence in Python, today you should work through the Basic Data Types notebook linked below:\n\nBeginner: Basic Data Types\n\nIn this notebook you will find interactive code blocks and plenty of exercises. Coding is best learned by doing, so take your time to work through the material and attempt as many exercises as you can during today’s session!\n\n\n\nIf you have some coding experience and are already somewhat familiar with basic data types in Python, you may wish to choose this option.\nFirst, please do check over the exercises in the Basic Data Types notebook and ensure you can answer them. Even the most experienced programmers will have gaps in their knowledge, so it is important you check this.\n\nBeginner: Basic Data Types\n\nOnce you feel confident with the material above, move on to the Collections notebook. This will introduce you to Python’s built-in collections and highlight the differences between sets, lists, dicts, and tuples. As always, aim to complete as many of the exercises as you can.\n\nIntermediate: Collections\n\n\n\n\nIf you are an experienced programmer with a strong grasp of Python, begin by reviewing the exercises in the notebooks below to ensure you are fully comfortable with the material:\n\nBeginner: Basic Data Types\n\nIntermediate: Collections\n\nOnce you are confident in your understanding, move on to the following notebook:\n\nAdvanced: Copying and References",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Week 1: Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_home.html#getting-help",
    "href": "01/week_01_home.html#getting-help",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "There is a lot to remember when first learning Python. To get more help see the Python API. Another useful link is the W3 schools series on Python which is very good, especially for new users. Another way to get help if you are ever unsure what a function is doing is to use thehelp function in the Python terminal like so:\n\nhelp(print)\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n    \n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\nIn class, you can ask for help from the lecturer, demonstrators and your peers around you. We advise you do not ask AI for help unless you are really stuck.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Week 1: Introduction to Data Types"
    ]
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy.html",
    "href": "08/exercises_lecture_working_with_numpy.html",
    "title": "Exercises - Working with NumPy",
    "section": "",
    "text": "Create a 1D NumPy array arr of integers from 10 to 19. Access the element at index 3.\n\n# Your code here",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Exercises - Working with NumPy"
    ]
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy.html#exercise-9-problem-solving-with-numpy",
    "href": "08/exercises_lecture_working_with_numpy.html#exercise-9-problem-solving-with-numpy",
    "title": "Exercises - Working with NumPy",
    "section": "Exercise 9: Problem solving with NumPy",
    "text": "Exercise 9: Problem solving with NumPy\nConsider the following problem:\n\nA panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.\n\nThe problem is a two-dimensional problem. The passenger has coordinates \\(x(t), y(t)\\) and is performing uniform rotational motion, with angular velocity \\(\\omega\\) and radius \\(R\\).\nThe angle formed at which the passenger is located is \\(\\theta(t)\\) and simply evolves as\n\\[\\theta(t) = \\omega t +\\theta_0\\]\nwhere \\(\\theta_0\\) is the initial angle (\\(\\theta_0=0\\) in our case).\nHence, the trajectory is expressed by\n\\[\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n\\]\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\nThe first approach is via using vanilla Python\n\nimport math\nR = 10.0 #in metres\nomega = 2.0*2*math.pi/60. # in radians per second\nx0 = R # in metres\ny0 = 0 # in metres\ndt = 2.0 # in seconds\nduration = 20.0 #in seconds\nnum_iterations  = int(duration/dt)\nx, y = [], []\nt = 0\nfor _ in range(num_iterations):\n    x.append(R*math.cos(omega*t)+x0)\n    y.append(R*math.sin(omega*t)+y0)\n    t += dt \n\n# plotting, ignore the details for now sicne we will cover this in a later lecture\nimport matplotlib.pyplot as plt\nplt.scatter(x,y)\nplt.axis(\"equal\")\nplt.show()\n\n\n\n\n\n\n\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on avoiding for loops and using NumPy’s array operations instead.\n\n# Your code here",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Exercises - Working with NumPy"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html",
    "href": "08/lecture_working_with_numpy.html",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "",
    "text": "NumPy is a powerful library for numerical computing in Python, providing efficient multi-dimensional array operations and a wide range of mathematical functions. With NumPy, you can perform fast element-wise computations, advanced indexing, slicing, and generate random data for simulations and analysis.\nThis notebook illustrates array indexing, boolean arrays, generating sequences using np.arange and np.linspace, and generating random samples with NumPy’s random number generator.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#array-indexing-slicing-views-and-copies",
    "href": "08/lecture_working_with_numpy.html#array-indexing-slicing-views-and-copies",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Array indexing, slicing, views and copies",
    "text": "Array indexing, slicing, views and copies\nIndexing in NumPy allows you to access and modify individual elements or groups of elements within an array. You can use integer indices, slices, and even boolean arrays to select data efficiently. For example:\n\nInteger Indexing: Select a single element by its position.\nSlicing: Extract a range of elements.\nBoolean Indexing: Filter elements based on a condition.\n\n\nInteger indexing\nWe have already seen that the lements of an array are idnexed similarly to lists. The syntax simply requires you to enter the integer index of the element you want to access. For example, if you have an array arr, you can access the element at index 1 using arr[1]. You can also slice arrays using the same syntax as lists, such as arr[1:4] to get elements from index 1 to 3.\n\nimport numpy as np\n\narr = np.array([10, 20, 30, 40, 50])\nprint(\"Array:\", arr)\nprint(\"Element at index 1:\", arr[1])\n\nArray: [10 20 30 40 50]\nElement at index 1: 20\n\n\n\n\nSlicing\nSlicing allows you to extract a portion of an array by specifying a start index, an end index, and an optional step. The syntax is similar to that used for lists in Python. For example, arr[1:4] retrieves elements from index 1 to 3 (the end index is exclusive).\n\nprint(\"Slice from index 1 to 3:\", arr[1:4])\n\nSlice from index 1 to 3: [20 30 40]\n\n\n\n\nAdvanced Slicing Techniques\nNumPy slicing can be extended beyond basic start and end indices:\n\nStep Size: Use a third parameter to specify the step, e.g., arr[::2] selects every other element.\nNegative Indices: Negative values index from the end, e.g., arr[-3:] gets the last three elements.\nReverse Slicing: Use a negative step to reverse an array, e.g., arr[::-1].\n\n\n# Step size: select every other element\nprint(\"Every other element:\", arr[::2])\n\n# Negative indices: last three elements\nprint(\"Last three elements:\", arr[-3:])\n\n# Reverse slicing: reverse the array\nprint(\"Reversed array:\", arr[::-1])\n\n# Selecting all elements\nprint(\"All elements:\", arr[:])\n\nEvery other element: [10 30 50]\nLast three elements: [30 40 50]\nReversed array: [50 40 30 20 10]\nAll elements: [10 20 30 40 50]\n\n\nSlicing creates views, not copies, so modifying a slice affects the original array. Use arr.copy() to create a copy if needed.\nA view is a new array object that looks at the same data as the original array. Changes made to a view will affect the original array, since they share the same underlying data. For example, arr[1:4] returns a view of arr, not a separate copy.\n\n# Demonstrating that slicing creates a view, not a copy\nslice_view = arr[2:5]\nprint(\"Original array before modification:\", arr)\nslice_view[0] = 99  # Modify the view\nprint(\"Modified slice_view:\", slice_view)\nprint(\"Original array after modification:\", arr)  # arr is also changed\n\nOriginal array before modification: [10 20 30 40 50]\nModified slice_view: [99 40 50]\nOriginal array after modification: [10 20 99 40 50]\n\n\nSlices can be programmaticaly generated using the slice function, which allows you to create a slice object that can be reused. For example, s = slice(1, 4) creates a slice object that can be used as arr[s] to get the same result as arr[1:4].\n\n# Creating an independent copy of a slice\nexample_slice = slice(1, 4, 2)\nprint(\"Using slice(1, 4, 2) on arr:\", arr[example_slice])\n\nUsing slice(1, 4, 2) on arr: [20 40]\n\n\nTo create an independent copy of an array (rather than a view), use the copy() method. For example, arr_copy = arr[1:4].copy() creates a new array with its own data, so changes to arr_copy will not affect the original arr. This is useful when you want to modify a subset of an array without altering the original data.\n\n# Creating an independent copy of a slice\narr_copy = arr[2:5].copy()\narr_copy[0] = 100  # Modify the copy\nprint(\"arr_copy:\", arr_copy)\nprint(\"Original arr:\", arr)  # arr remains unchanged\n\narr_copy: [100  40  50]\nOriginal arr: [10 20 99 40 50]\n\n\n\n\nBoolean Indexing\nBoolean indexing allows you to select elements from an array based on a condition. When you apply a condition to a NumPy array, it returns a boolean (an array that contains only True/False values ) array indicating which elements satisfy the condition. You can then use this boolean array to filter the original array, extracting only the elements that meet the criteria. This technique is powerful for data selection and analysis.\n\narr = np.array([1, 2, 3, 4, 5, 6])\nthreshold = 3\nbool_mask = arr &gt; threshold\nprint(\"Original array:\", arr)\nprint(f\"Boolean mask for threshold {threshold}:\", bool_mask)\nprint(\"Filtered values:\", arr[bool_mask])\n\nOriginal array: [1 2 3 4 5 6]\nBoolean mask for threshold 3: [False False False  True  True  True]\nFiltered values: [4 5 6]\n\n\n\n\nUsing np.where for conditional selection\nThe np.where function in NumPy is a powerful tool for conditional selection and element-wise operations. It allows you to choose values from arrays based on a condition, returning indices or constructing new arrays.\n\nBasic usage:\nnp.where(condition) returns the indices where the condition is True.\n\n\nnp.where(arr &gt; threshold)\n\n(array([3, 4, 5]),)\n\n\nnp.where(arr &gt; threshold) returns a tuple because, for 1D arrays, it provides the indices where the condition is True. In NumPy, the output is always a tuple of arrays—one for each dimension of the input array. For a 1D array, it’s a single-element tuple containing the indices. For higher dimensions, it returns a tuple with arrays for each axis. This consistent tuple format makes it easy to handle multi-dimensional indexing.\nSo, for 1D arrays as the ones considered up to now, we should get the indices by extracting the first element of the tuple returned by np.where\n\nnp.where(arr &gt; threshold)[0]\n\narray([3, 4, 5])\n\n\n\nElement-wise selection:\nnp.where(condition, x, y) returns elements from x where the condition is True, and from y where it is False. Here the result is an array of the same shape as x and y, containing values from x where the condition is met, and from y otherwise. This is useful for creating new arrays based on conditions without using loops.\n\n\na  = np.array([1, 2, 3, 4, 5])\nb = np.array([-1,-2, -3, - 4, -5])\nc = np.array([10, 20, 30, 40, 50])\n\nresult = np.where(a &gt; 2, x, y)\nprint(result)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 5\n      2 b = np.array([-1,-2, -3, - 4, -5])\n      3 c = np.array([10, 20, 30, 40, 50])\n----&gt; 5 result = np.where(a &gt; 2, x, y)\n      6 print(result)\n\nNameError: name 'x' is not defined\n\n\n\nThis creates a new array where each element is 100 if the condition is met, otherwise 0.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#function-to-generate-numerical-arrays",
    "href": "08/lecture_working_with_numpy.html#function-to-generate-numerical-arrays",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Function to generate numerical arrays",
    "text": "Function to generate numerical arrays\nNumPy provides automated methods for generating numerical sequences, which are essential for simulations, sampling, and creating structured data.\n\nGenerating sequences\nThe two most used functions for generating ordered numerical sequences in NumPy are np.arange and np.linspace.\n\nnp.arange(start, stop, step): Generates an array of evenly spaced values within a specified range. The start value is inclusive, while the stop value is exclusive. The step parameter defines the spacing between values.\nExample: np.arange(0, 10, 2) produces [0, 2, 4, 6, 8].\nnp.linspace(start, stop, num): Creates an array of num evenly spaced values between start and stop, inclusive. This is useful for generating a specific number of points in a range.\n\n\nprint(\"np.arange(0, 10, 2):\", np.arange(0, 10, 2))\nprint(\"np.linspace(0, 1, 5):\", np.linspace(0, 1, 5))\n\nnp.arange(0, 10, 2): [0 2 4 6 8]\nnp.linspace(0, 1, 5): [0.   0.25 0.5  0.75 1.  ]\n\n\nMost importantly, these functions can be used to create arrays of any kinds of numerical data, including integers and floating-point numbers.\n\n# integers\nnp.arange(0, 10, 2)  # Creates an array with values from 0 to 10 with a step of 2\n\narray([0, 2, 4, 6, 8])\n\n\n\n# floating-point numbers\nnp.arange(0.0, 1.0, 0.2)  # Creates an array with values from 0.0 to 1.0 with a step of 0.2\n\narray([0. , 0.2, 0.4, 0.6, 0.8])\n\n\n\n# complex numbers, by using the data type specifier `dtype=complex`\nnp.arange(0, 10, 2, dtype=complex)  # Creates an array with complex numbers from 0 to 10 with a step of 2\n\narray([0.+0.j, 2.+0.j, 4.+0.j, 6.+0.j, 8.+0.j])\n\n\nNotice that linspace is useful when we know the start and end value and the specific number of points we want to generate, while arange is useful when we know the start and end value and the step size between the points.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#generating-filled-arrays",
    "href": "08/lecture_working_with_numpy.html#generating-filled-arrays",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Generating filled arrays",
    "text": "Generating filled arrays\nNumPy provides functions to create arrays filled with specific values, such as zeros, ones, or a constant value. These functions are useful for initializing arrays before performing computations.\nThe main functions for generating filled arrays are: - np.zeros(shape): Creates an array filled with zeros, where shape specifies the dimensions of the array. - np.ones(shape): Creates an array filled with ones. - np.full(shape, fill_value): Creates an array filled with a specified value (fill_value), where shape defines the dimensions of the array.\n- np.empty(shape): Creates an uninitialized array with the specified shape. The values in this array are not set to any particular value, so they may contain random data.\nThere are also functions that create arrays with the same shape and type as an existing array, which can be useful for initializing arrays that will be used in computations:\n\nnp.zeros_like(array): Creates an array of zeros with the same shape and type as the input array.\nnp.ones_like(array): Creates an array of ones with the same shape and type as the input array.\nnp.full_like(array, fill_value): Creates an array filled with a specified value, with the same shape and type as the input array.\n\n\n# Examples using filled array generation functions\n\n# Create a 1D array of zeros with the same shape as arr\nzeros_arr = np.zeros_like(arr)\nprint(\"Zeros array:\", zeros_arr)\n\n# Create a 1D array of ones with the same shape as arr\nones_arr = np.ones_like(arr)\nprint(\"Ones array:\", ones_arr)\n\n# Create a 1D array filled with the value 7, same shape as arr\nfull_arr = np.full_like(arr, 7)\nprint(\"Full array (filled with 7):\", full_arr)\n\n# Create an uninitialized array (values may be random, or zeros)\nempty_2d = np.empty(5)\nprint(\"An empty array:\\n\", empty_2d)\n\nZeros array: [0 0 0 0 0 0]\nOnes array: [1 1 1 1 1 1]\nFull array (filled with 7): [7 7 7 7 7 7]\nAn empty array:\n [0. 0. 0. 0. 0.]",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#random-data-generation",
    "href": "08/lecture_working_with_numpy.html#random-data-generation",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Random Data Generation",
    "text": "Random Data Generation\nRandom data generation is essential for simulations, statistical modeling, and testing algorithms.\nFor example, you might want to generate random samples from a normal distribution to simulate real-world data or create random datasets for testing purposes. Or you may want to simulate the effect of measurement errors in your data analysis. Or you may want to sub-sample a large dataset randomly to take a representative sample without bias.\nTo do all this, one needs methods to sample numbers that possess the statistical properties of the desired distribution, such as uniform, normal, or binomial distributions.\nStrictly speaking (classical) computers are deterministic machines, meaning they follow a set of rules and produce the same output for the same input every time. We have therefore to use algorithms to produce sequences of numbers that mimic the properties of random numbers.\nThese are called pseudo-random numbers. Pseudo-random number generators (PRNGs) use algorithms to produce sequences of numbers that appear random but are actually deterministic.\nA simple and classic example of a pseudo-random number generator is the Linear Congruential Generator (LCG). The LCG produces a sequence of numbers using the recurrence relation:\n\\[x_{n+1} = (a \\times  x_{n} + c)\\,\\mathrm{mod}\\, m\\]\nwhere\n- \\(x_n\\) is the current value,\n- \\(a\\) is the multiplier,\n- \\(c\\) is the increment,\n- \\(m\\) is the modulus.\nIn vanilla Python this looks like the following custom function\n\ndef lcg(seed, a=1664525, c=1013904223, m=2**32, size=10):\n    nums = []\n    x = seed\n    for _ in range(size):\n        x = (a * x + c) % m\n        nums.append(x)\n    return nums\n\n\n# Example usage:\nlcg_sequence = lcg(seed=42, size=5)\nprint(\"LCG sequence:\", lcg_sequence)\n\nLCG sequence: [1083814273, 378494188, 2479403867, 955863294, 1613448261]\n\n\nThis will generate a sequence of pseudo-random integers. The choice of parameters (a, c, m) affects the quality and period of the generator.\n\n# Example of LCG with a short period by choosing small modulus\nshort_period_seq = lcg(seed=1,  a=5, c=3, m=16, size=20)\nprint(\"LCG sequence with short period:\", short_period_seq)\n\nLCG sequence with short period: [8, 11, 10, 5, 12, 15, 14, 9, 0, 3, 2, 13, 4, 7, 6, 1, 8, 11, 10, 5]\n\n\nThe seed is crucial: it is the initial value that starts the algorithm to determin the subsequent values in the sequence. By setting the seed, you can ensure that the sequence is reproducible, meaning that running the same code with the same seed will produce the same sequence of numbers every time.\nIn numpy, we do not need to implement our own LCG, as it provides a built-in random number generator that is based on the Mersenne Twister algorithm, which is a widely used and efficient pseudo-random numbwer generator.\nWhat we do instead is to use the numpy.random sub-module, which provides a wide range of functions for generating random numbers from various distributions, including uniform, normal, and binomial distributions.\nThe standard way to to use it is the following:\n\nfirst, one initialises a new kind of object called a random number generator (RNG) using np.random.default_rng(). This is a numpy object capable of generating random numbers from various distributions. It allows us in particular to set the seed and therefore ensure reproducibility.\n\n\nrng = np.random.default_rng(seed=123)\n\nWe can do this at any point in our code, but it is a good practice to do it at the beginning of our script or notebook, so that we can ensure that all random numbers generated in the script are reproducible. Putting the generator elsewhere (for example, inside a function) could lead to unexpected results, as the generator would be re-initialised each time the function is called.\nOnce we have a generator we can access any of its method to sample numbers from various distributions\nFor example:\n\nIntegers\nTo sample uniformly distributed integers, we can use the integers method of the generator. This method allows us to specify a range and the number of integers to generate.\n\nrng.integers(0, 100, size=5)  # 5 random integers between 0 and 100\n\narray([ 1, 68, 59,  5, 90])\n\n\n\n\n[0-1) uniform floats\nTo sample uniformly distributed floats between 0 and 1, we can use the random method of the generator. This method generates random floats in the range [0.0, 1.0) (which means 0 included and 1 excluded).\n\nrng.random(1000)\n\narray([1.84371811e-01, 1.75905901e-01, 8.12094507e-01, 9.23344998e-01,\n       2.76574398e-01, 8.19754562e-01, 8.89892693e-01, 5.12970455e-01,\n       2.44964601e-01, 8.24241596e-01, 2.13762963e-01, 7.41467052e-01,\n       6.29940205e-01, 9.27407259e-01, 2.31908189e-01, 7.99125129e-01,\n       5.18165037e-01, 2.31555625e-01, 1.65903993e-01, 4.97788968e-01,\n       5.82724641e-01, 1.84337987e-01, 1.48949168e-02, 4.71133229e-01,\n       7.28243328e-01, 9.18600492e-01, 6.25534006e-01, 9.17122573e-01,\n       8.64690251e-01, 2.18142873e-01, 8.66127431e-01, 7.30751936e-01,\n       2.77865290e-01, 7.97043553e-01, 8.65221713e-01, 2.99437896e-01,\n       5.27042084e-01, 7.14868066e-02, 5.83238410e-01, 2.37906400e-01,\n       7.64963646e-01, 1.73631636e-01, 3.12742256e-01, 1.44744768e-02,\n       3.25519216e-02, 4.96701842e-01, 4.68312534e-01, 1.27690323e-01,\n       2.57562505e-01, 3.18110929e-03, 3.81067748e-01, 5.75873084e-01,\n       4.27298771e-01, 8.35102347e-01, 6.16491251e-01, 2.66083912e-01,\n       8.11022111e-01, 4.99486750e-01, 7.58810321e-01, 5.66089086e-01,\n       4.37440362e-01, 3.96154444e-01, 2.22352879e-02, 4.69350788e-01,\n       6.23558402e-01, 9.46113421e-01, 4.35326080e-01, 4.85641403e-01,\n       5.19115144e-01, 4.08590980e-01, 5.78795719e-01, 7.03506733e-02,\n       4.88383831e-01, 6.10144828e-01, 7.43879107e-01, 4.29830320e-01,\n       3.02802133e-01, 5.89003332e-03, 7.56478970e-01, 7.75759702e-02,\n       4.89988038e-01, 3.04361097e-01, 8.40822162e-01, 9.50475862e-01,\n       3.18874579e-01, 8.97768289e-01, 3.37529051e-01, 8.12112111e-01,\n       7.98843598e-01, 6.55285177e-01, 2.28703455e-01, 1.37674465e-01,\n       4.24371139e-01, 1.51538753e-01, 8.73272949e-01, 1.79126757e-01,\n       3.02946616e-02, 5.59249677e-01, 4.28806253e-01, 8.58597422e-01,\n       1.60831376e-01, 3.60353699e-01, 6.40509937e-01, 9.31079350e-01,\n       2.61801022e-01, 6.88098414e-01, 1.49052652e-01, 7.40154973e-01,\n       2.93181283e-01, 2.43745105e-01, 2.29821438e-01, 3.70651165e-01,\n       3.28555087e-01, 6.12641672e-01, 5.44715400e-01, 7.49643105e-01,\n       2.94954285e-01, 9.60553728e-01, 5.43482759e-01, 6.79424148e-01,\n       6.88259248e-01, 1.52297793e-01, 1.45024452e-01, 4.62043822e-01,\n       5.21933533e-01, 2.72044753e-01, 1.80120947e-01, 5.03921087e-01,\n       6.59638348e-01, 2.28754453e-01, 2.18418231e-01, 9.54899059e-01,\n       7.24892934e-01, 3.43368483e-02, 9.81617034e-01, 8.49616629e-03,\n       2.64961882e-01, 9.17324152e-01, 8.03877164e-02, 8.54715704e-01,\n       1.44677397e-01, 1.79241078e-01, 7.84673473e-01, 8.95424057e-01,\n       4.60734326e-01, 3.84836822e-02, 3.15305260e-01, 1.52932497e-02,\n       3.49173685e-01, 6.59310019e-01, 2.65216132e-01, 6.52018838e-01,\n       9.27480197e-01, 4.66138759e-01, 2.07109561e-01, 9.22714245e-01,\n       9.45856611e-01, 1.34905654e-01, 8.99638534e-01, 2.92149167e-01,\n       1.28175443e-01, 1.18076690e-01, 7.59450077e-01, 8.84425144e-02,\n       7.63151744e-01, 2.39618554e-01, 4.18783790e-01, 1.43017706e-01,\n       6.52669797e-01, 4.57785927e-01, 3.93830151e-01, 8.04673138e-01,\n       4.59015110e-01, 6.91568337e-01, 7.81989077e-01, 6.14881258e-01,\n       9.61390895e-01, 5.50878047e-01, 2.19012527e-01, 5.41879843e-01,\n       2.44556981e-01, 8.33270172e-02, 7.56362092e-01, 2.64497549e-01,\n       3.13640437e-01, 9.88342858e-01, 4.00557832e-01, 4.41312096e-01,\n       9.20598730e-01, 7.90066378e-01, 8.59482088e-01, 4.68356714e-01,\n       2.12503574e-01, 6.56388165e-02, 7.98140191e-02, 1.36989553e-01,\n       2.69348924e-01, 7.77373950e-01, 2.29526009e-01, 4.21793581e-01,\n       4.58136535e-01, 3.09685992e-01, 1.77010903e-01, 2.68030787e-01,\n       8.52354381e-01, 9.94072275e-01, 3.70674245e-01, 4.61750909e-01,\n       3.34988554e-01, 3.65438705e-01, 6.87173494e-01, 7.35326314e-01,\n       3.17037589e-01, 1.45020086e-01, 7.07526003e-01, 4.39390997e-01,\n       9.16295276e-01, 4.09334109e-01, 2.77150070e-02, 7.26138640e-01,\n       9.85781890e-01, 4.66361827e-01, 9.52649389e-01, 1.62589708e-01,\n       2.12859688e-01, 3.41512042e-01, 4.05946036e-01, 8.99458188e-01,\n       9.72509770e-01, 5.10212230e-01, 6.96744277e-01, 6.27618975e-01,\n       8.60532754e-01, 1.07781528e-01, 5.61674829e-01, 8.08329407e-01,\n       7.74227117e-01, 7.67461953e-01, 9.81200035e-01, 2.83038159e-02,\n       1.06097737e-01, 1.53329230e-01, 5.80881814e-01, 4.30837283e-01,\n       6.41294099e-02, 2.79183123e-01, 3.90760254e-01, 5.05871219e-01,\n       7.55738892e-01, 4.89023703e-01, 8.25727590e-01, 5.40468140e-01,\n       3.57183202e-01, 8.05977481e-01, 1.86378547e-01, 8.89289032e-01,\n       6.73413707e-01, 9.53377252e-01, 2.09842996e-01, 2.32745704e-01,\n       4.56558778e-01, 1.48755812e-01, 3.97266148e-02, 3.51908111e-01,\n       7.51073437e-01, 8.88985034e-01, 2.33330969e-01, 9.44303691e-01,\n       7.92382452e-02, 7.82914944e-02, 7.05380588e-01, 6.78028455e-02,\n       9.70647394e-01, 2.74209810e-01, 1.28723815e-01, 7.68454465e-01,\n       4.22450862e-01, 9.00075386e-01, 4.92458541e-01, 7.98362805e-03,\n       1.63343123e-01, 9.93855166e-02, 1.81349494e-01, 2.70568170e-01,\n       7.53784338e-02, 8.78925401e-01, 6.73292806e-01, 4.43977331e-01,\n       8.98713315e-01, 6.11667746e-01, 6.81721781e-01, 7.12645562e-01,\n       4.39463988e-01, 2.93164240e-01, 8.86758579e-01, 3.69086347e-01,\n       4.36794215e-01, 2.76273452e-01, 5.53644595e-01, 5.38142965e-01,\n       4.31733785e-01, 3.53278547e-01, 5.41743078e-01, 3.82057942e-01,\n       7.79098989e-01, 1.53412210e-01, 7.20461787e-01, 2.08668011e-01,\n       9.32024800e-01, 3.84991713e-01, 3.23780149e-01, 9.00976329e-01,\n       4.73760930e-02, 9.77634923e-01, 9.28686984e-01, 6.64628650e-01,\n       5.69600819e-01, 5.24352848e-01, 8.34164345e-02, 9.07821313e-02,\n       6.90645119e-01, 9.57967677e-01, 5.10249274e-01, 1.01844895e-03,\n       8.28841928e-01, 8.30527092e-01, 3.36511890e-01, 6.79818631e-01,\n       1.41583649e-01, 1.63237978e-01, 7.11432537e-01, 5.09927237e-01,\n       5.88925603e-01, 5.23705849e-01, 9.40467623e-01, 7.88692180e-01,\n       8.99123374e-01, 2.91613581e-01, 9.79610619e-01, 8.18777761e-01,\n       9.95662196e-02, 8.71069391e-02, 1.91521038e-01, 3.36374640e-01,\n       2.19437735e-01, 5.18401453e-02, 4.45013130e-01, 2.62511860e-01,\n       4.62669935e-01, 7.83487475e-01, 3.21772672e-01, 4.03029885e-02,\n       8.34537973e-01, 4.90318507e-01, 2.44148858e-01, 9.28257314e-01,\n       7.35195053e-01, 4.21703964e-01, 3.47123735e-01, 7.10517888e-02,\n       2.85652304e-01, 7.15829431e-01, 7.56348747e-02, 3.76477949e-01,\n       5.91571543e-01, 7.39956524e-01, 7.42822511e-01, 2.92607877e-01,\n       3.29242395e-01, 1.57348400e-01, 7.29287841e-01, 2.65469563e-01,\n       4.80423341e-01, 8.99725840e-01, 6.42896243e-03, 8.56693461e-01,\n       7.39848839e-01, 6.45152381e-01, 4.07077242e-01, 6.24018428e-01,\n       9.48596887e-01, 9.52827932e-02, 6.77719450e-02, 3.40497035e-01,\n       1.03056557e-01, 9.17756634e-01, 7.87378214e-01, 1.58418307e-01,\n       3.73626915e-01, 4.15391292e-01, 9.54422908e-01, 3.29219753e-01,\n       4.80208521e-01, 5.28962176e-01, 7.81803274e-01, 8.68044648e-01,\n       6.70774506e-01, 3.63329218e-01, 2.29046003e-01, 3.98075545e-01,\n       5.75837731e-01, 7.66922112e-01, 9.59497014e-01, 8.73402359e-01,\n       7.87775841e-01, 9.00659757e-01, 6.96050335e-01, 9.45490228e-01,\n       5.13548471e-01, 9.10756934e-02, 7.29521894e-01, 9.48477875e-01,\n       3.10402712e-02, 6.22092795e-01, 3.04768507e-01, 4.04182471e-01,\n       9.18098826e-01, 3.34389520e-01, 6.25812967e-01, 4.23398749e-01,\n       9.26832129e-01, 3.68676160e-01, 9.93795752e-02, 4.18998728e-01,\n       4.05119062e-01, 8.85378822e-01, 3.31414354e-01, 2.94004444e-01,\n       4.07031481e-01, 6.91009738e-01, 4.22313249e-01, 5.22053089e-01,\n       7.10217611e-01, 2.67980368e-02, 1.33159234e-01, 7.25115476e-01,\n       9.07175470e-01, 8.67027162e-01, 7.07202750e-01, 9.81854660e-01,\n       8.52905505e-01, 6.93752664e-01, 6.40121696e-01, 8.53131626e-01,\n       8.80156165e-01, 2.74037982e-01, 8.54019135e-01, 5.88206803e-01,\n       1.86379777e-04, 1.97099418e-01, 7.79598163e-01, 3.42190497e-01,\n       8.43060960e-01, 6.02672523e-01, 9.86654937e-01, 7.63854232e-01,\n       9.30444278e-02, 8.37787891e-01, 6.63912156e-01, 2.20122755e-01,\n       5.16804413e-01, 1.60351790e-01, 3.73046077e-01, 7.44788479e-01,\n       4.53366397e-01, 6.61458118e-01, 8.99345144e-01, 7.01525089e-01,\n       9.20566999e-02, 4.12473460e-01, 3.16132834e-01, 4.78451996e-01,\n       8.96847839e-01, 3.42900315e-01, 7.41429784e-01, 4.68276663e-01,\n       8.37718614e-01, 2.35700386e-01, 5.23455616e-01, 6.31811742e-01,\n       3.76699726e-01, 5.63502651e-01, 2.96738637e-01, 9.87425770e-01,\n       6.87260695e-01, 6.29460053e-01, 9.34547524e-01, 4.40673000e-01,\n       9.81269351e-01, 9.00139631e-02, 9.88211527e-01, 7.19692087e-01,\n       5.79939881e-01, 3.56486538e-01, 2.03086688e-01, 9.82557875e-01,\n       2.35221673e-01, 8.80107684e-01, 5.70474295e-02, 8.01264314e-01,\n       8.69584494e-01, 2.44912426e-01, 9.76953176e-01, 3.71831094e-01,\n       1.58355891e-01, 4.19490157e-01, 9.72325640e-01, 1.13491229e-01,\n       6.92972289e-01, 1.36092032e-01, 6.85297152e-01, 1.54219934e-01,\n       9.43749823e-01, 9.13711151e-01, 9.84413406e-01, 8.78415554e-01,\n       3.85919890e-01, 4.65802671e-01, 3.13890072e-01, 4.92166010e-01,\n       2.37900547e-01, 9.60058750e-01, 4.17853706e-01, 3.36021029e-01,\n       9.35275132e-01, 3.47530896e-01, 4.21498557e-01, 6.27928406e-01,\n       7.30556551e-01, 4.25667830e-01, 2.22257876e-01, 6.21894105e-01,\n       1.70135598e-01, 6.18882849e-01, 6.42565172e-01, 6.38895026e-01,\n       3.51982564e-01, 3.96320815e-01, 2.65015454e-01, 7.89367513e-01,\n       7.16239201e-01, 6.91437570e-01, 9.71314939e-01, 8.86818231e-01,\n       4.29160537e-01, 7.57904842e-01, 6.44050284e-01, 5.37030350e-01,\n       1.40040249e-01, 4.93648641e-01, 2.16956963e-01, 8.08458170e-01,\n       7.39295663e-01, 1.79091296e-01, 9.03285198e-02, 1.08586391e-01,\n       7.83586979e-01, 9.41516049e-01, 2.89726949e-01, 1.09244985e-01,\n       7.07720088e-01, 5.22596691e-01, 6.05670467e-01, 5.01821423e-01,\n       8.09740839e-01, 5.84896971e-01, 8.02212848e-01, 6.57759409e-01,\n       6.84953179e-01, 7.36580632e-01, 5.78187585e-01, 3.59761003e-01,\n       3.96263174e-01, 2.23260703e-02, 3.71782090e-02, 4.64820602e-01,\n       8.01973219e-01, 7.07226413e-01, 3.84889505e-01, 4.79529675e-01,\n       8.38114215e-01, 7.87692873e-01, 6.10222185e-01, 8.49063075e-01,\n       9.79207663e-01, 6.22966362e-01, 9.69881649e-01, 7.80090568e-02,\n       7.75855776e-01, 9.61048047e-02, 2.21691318e-01, 3.39170089e-01,\n       1.16700789e-01, 7.15962826e-01, 3.49435446e-01, 1.68633123e-01,\n       2.14742590e-01, 2.47672902e-02, 9.60535205e-01, 9.51182093e-01,\n       2.54441148e-01, 6.99273568e-01, 4.64313594e-02, 3.49571461e-01,\n       6.76266217e-01, 2.27676696e-01, 3.39148914e-01, 1.31136392e-01,\n       1.51316642e-01, 6.21017714e-03, 3.38630900e-01, 4.25739019e-01,\n       4.22599751e-01, 2.84916502e-01, 5.31731583e-01, 2.53781815e-02,\n       4.05774435e-01, 6.12898421e-01, 7.64075727e-01, 9.92727201e-01,\n       4.39374925e-01, 9.40188607e-01, 9.16371994e-01, 1.39190844e-01,\n       5.00843313e-01, 2.24280699e-01, 7.93077513e-01, 7.35168059e-01,\n       9.73456559e-01, 5.93342214e-02, 4.33034747e-01, 3.64531796e-01,\n       6.55678105e-01, 5.30821139e-01, 5.70188154e-01, 1.42042459e-01,\n       9.41130038e-01, 3.24981732e-01, 3.93215105e-01, 2.28596939e-01,\n       3.03361353e-01, 3.78744798e-01, 2.60604557e-01, 4.53498545e-01,\n       8.33089640e-01, 8.43666133e-01, 6.12317203e-01, 5.52709486e-01,\n       6.02282676e-01, 5.04238757e-01, 7.10020576e-02, 1.01995977e-01,\n       4.78667187e-01, 7.38418414e-02, 1.29717098e-01, 6.25772270e-01,\n       9.45583945e-01, 3.47629781e-02, 6.02315044e-01, 4.52489476e-01,\n       3.95084990e-02, 7.80372045e-01, 7.04680631e-01, 9.34338102e-01,\n       6.63940453e-01, 7.15504435e-01, 3.60105197e-01, 5.79098519e-01,\n       6.20473130e-01, 1.16505534e-01, 1.99216124e-01, 2.36086058e-01,\n       6.09880241e-01, 5.42884698e-01, 3.22745858e-01, 7.89789443e-01,\n       6.91813852e-01, 1.39315464e-01, 7.89802302e-01, 3.09553223e-01,\n       4.66120187e-01, 1.81748724e-01, 4.03280255e-01, 2.29615358e-01,\n       7.33369033e-01, 5.88246449e-01, 8.81447262e-01, 1.58060193e-01,\n       5.74691483e-01, 4.72075225e-01, 4.76160368e-01, 7.55445869e-01,\n       4.14679282e-01, 6.95271222e-01, 2.78711499e-01, 1.27075953e-01,\n       7.92857877e-01, 5.25856417e-01, 2.47756200e-01, 4.51794210e-01,\n       6.32646492e-01, 2.46935350e-01, 1.80625697e-01, 9.90570705e-01,\n       1.84435744e-01, 3.34265115e-01, 3.98346351e-01, 8.61159621e-01,\n       2.78233797e-01, 2.21618214e-01, 1.26682913e-01, 7.60594687e-01,\n       5.65182951e-01, 9.42787883e-02, 4.54948466e-01, 9.88445048e-01,\n       9.23071934e-01, 5.62383859e-01, 2.35183420e-01, 5.88979107e-01,\n       5.12704297e-01, 9.69980113e-01, 1.50404598e-02, 3.11346496e-01,\n       4.03148074e-01, 7.30309455e-01, 7.49192551e-01, 7.34195577e-01,\n       5.68886818e-01, 5.51682285e-01, 2.90253650e-01, 8.68864839e-01,\n       4.26876456e-01, 3.57536909e-01, 7.95125315e-01, 7.24742588e-01,\n       3.18551534e-01, 2.36879864e-02, 8.38310718e-03, 8.50825909e-01,\n       1.51046580e-01, 6.02445589e-01, 5.90731652e-01, 2.25353624e-01,\n       4.45584992e-01, 4.19023040e-01, 5.02707937e-01, 8.57022140e-01,\n       9.15971624e-01, 8.65700471e-02, 4.29082699e-01, 2.94536932e-01,\n       7.87849073e-01, 3.45847897e-01, 4.85105598e-01, 7.06576725e-01,\n       6.35219271e-01, 7.43435940e-01, 4.30920168e-01, 5.41323170e-01,\n       2.72144070e-01, 7.77095084e-01, 8.66290049e-01, 3.02129491e-01,\n       4.97757480e-01, 1.04605450e-01, 1.11726740e-01, 1.44628744e-01,\n       6.29905356e-01, 7.86264040e-01, 1.29190474e-01, 9.97435899e-01,\n       3.53866468e-01, 8.93344644e-01, 9.99608624e-01, 8.41059435e-01,\n       3.80353548e-01, 2.41634372e-02, 5.07971669e-01, 4.87943326e-01,\n       3.51834111e-03, 8.68652395e-01, 1.46184072e-01, 6.27005376e-01,\n       2.62514882e-01, 4.14292580e-01, 4.69887143e-01, 5.87663680e-01,\n       5.19519352e-01, 3.64439271e-01, 4.04623206e-02, 1.26604592e-01,\n       6.23990975e-01, 6.06017770e-01, 6.68272217e-01, 8.03770268e-02,\n       2.49796689e-01, 2.34870364e-01, 8.14631148e-01, 7.59801548e-01,\n       7.51641514e-01, 9.71902838e-01, 9.15851294e-01, 6.44074919e-01,\n       5.08843946e-01, 8.17654038e-01, 5.49662595e-01, 7.67618746e-01,\n       1.80170976e-01, 5.13005646e-01, 4.83605604e-01, 4.84650633e-01,\n       5.19503300e-01, 6.13990319e-01, 6.05418128e-01, 9.52585636e-01,\n       2.19548381e-01, 1.43917481e-01, 7.29420234e-01, 2.43480099e-01,\n       2.80502889e-01, 1.79434111e-01, 4.77527810e-01, 4.09491510e-01,\n       9.75167208e-01, 6.75184193e-01, 5.84872619e-01, 5.77342807e-01,\n       2.85003405e-01, 8.87184719e-01, 1.16355801e-01, 7.35554824e-01,\n       1.24013004e-01, 4.98390320e-01, 2.16397744e-01, 5.53822787e-01,\n       1.96260005e-01, 5.02868933e-01, 3.11090563e-02, 2.46768705e-01,\n       7.35394909e-01, 5.19689621e-01, 4.95135275e-01, 6.36488593e-01,\n       5.25254822e-01, 2.63066968e-01, 8.89971280e-01, 3.13161731e-01,\n       1.82308237e-02, 1.89502519e-01, 4.09071206e-01, 9.76064011e-03,\n       5.45704311e-01, 9.53276151e-01, 5.59704505e-01, 2.07067188e-01,\n       6.41759332e-02, 5.40570751e-01, 6.85448654e-01, 6.41559203e-01,\n       5.67484382e-01, 3.67901675e-01, 3.88360406e-01, 8.62396452e-01,\n       4.83391607e-02, 2.98826500e-01, 2.87245366e-01, 9.81379650e-01,\n       5.01772265e-01, 1.81215893e-01, 8.47957394e-01, 3.73746504e-01,\n       3.85041209e-01, 3.37156609e-01, 1.50255558e-01, 4.46627035e-01,\n       5.49211816e-01, 4.52836646e-01, 3.81312948e-01, 2.29694327e-01,\n       8.58702776e-01, 8.63031827e-01, 5.62718035e-01, 7.10165693e-01,\n       9.10979874e-01, 1.60458306e-01, 1.27352099e-01, 1.98341592e-01,\n       5.91370725e-01, 7.33427875e-02, 7.33828716e-01, 4.99027872e-02,\n       2.56524814e-02, 9.66295697e-01, 3.53274248e-01, 5.59386955e-01,\n       4.82919017e-01, 6.47204067e-01, 9.42171578e-01, 5.57108997e-01,\n       3.22657791e-01, 4.04844321e-02, 6.44860711e-01, 4.20518623e-01,\n       9.55370116e-01, 5.85203790e-01, 6.34037553e-01, 6.41387498e-01,\n       5.42994115e-01, 3.88003153e-01, 4.61014667e-01, 6.82868933e-01,\n       2.38841304e-01, 1.82540351e-01, 8.99260513e-01, 6.82811763e-01,\n       8.71299481e-01, 3.67317126e-01, 5.75866982e-01, 6.04302596e-01,\n       8.94619187e-01, 8.77432271e-01, 2.60269946e-01, 9.68562352e-01,\n       3.72231077e-01, 6.09669515e-01, 9.93231610e-01, 4.07178709e-01,\n       6.41876306e-01, 9.88305005e-01, 6.29292661e-01, 6.57618907e-01,\n       7.88160705e-01, 7.87910291e-01, 9.48015524e-01, 6.48913074e-01,\n       2.51063503e-01, 6.11801501e-02, 7.97181219e-02, 9.62301018e-01,\n       8.23306828e-01, 5.93376564e-01, 8.99971486e-01, 8.70132481e-01,\n       3.59576234e-01, 8.09451971e-01, 1.99053249e-01, 9.83838075e-01,\n       3.16119220e-01, 2.79590636e-01, 1.82316030e-01, 5.55344640e-01,\n       9.01338225e-01, 5.54274114e-01, 3.89840504e-02, 5.33396917e-02,\n       5.18277669e-01, 8.89943918e-01, 5.83347833e-01, 7.46426878e-01,\n       8.36735442e-01, 1.31531810e-01, 4.28953841e-01, 3.81465212e-03,\n       4.18834672e-01, 8.58456078e-01, 7.87468105e-01, 3.34499223e-01,\n       7.12883037e-01, 7.12539124e-01, 4.91427391e-01, 1.03870391e-01,\n       9.26174898e-01, 5.72580403e-01, 1.78409738e-01, 6.73914909e-01,\n       7.71047912e-01, 1.11449991e-01, 4.24989628e-01, 9.49653830e-01,\n       5.87384706e-01, 7.84826859e-01, 1.51450563e-01, 2.67089098e-01,\n       9.63130696e-01, 8.07866729e-02, 8.94102677e-01, 6.35593048e-02,\n       5.94423335e-01, 1.37989970e-02, 9.02332677e-01, 5.34706480e-01,\n       5.37337899e-01, 3.88505423e-01, 6.97279170e-01, 6.67139924e-01,\n       6.01679114e-01, 4.61518241e-01, 1.89506686e-01, 5.79511760e-01])\n\n\nAlternatively, we can use the uniform method to sample uniformly distributed floats in a specified range. This method allows us to specify the lower and upper bounds of the range, as well as the number of samples to generate.\n\nrng.uniform(0,1,1000)\n\narray([9.39046881e-01, 2.99072349e-01, 4.60476377e-01, 5.75651076e-02,\n       8.53021741e-02, 1.99444561e-01, 6.30163990e-01, 2.72450314e-01,\n       9.49816269e-01, 4.16201503e-01, 6.24219978e-01, 5.65506017e-01,\n       4.97016101e-01, 3.99685405e-01, 4.46141742e-01, 9.96016783e-01,\n       9.20760027e-02, 9.66146235e-01, 2.53428386e-01, 7.98048289e-01,\n       2.30934744e-01, 3.91438675e-01, 7.12524762e-01, 9.24495876e-01,\n       4.36304104e-01, 6.09645109e-01, 3.47455055e-01, 2.09448681e-01,\n       9.40345824e-01, 9.39048542e-01, 9.76034937e-01, 9.78221913e-01,\n       9.02928508e-01, 5.60702051e-01, 3.09192067e-01, 3.91578411e-01,\n       2.92628804e-01, 3.17626904e-01, 7.66354541e-01, 9.39779224e-01,\n       5.69968327e-01, 7.13253015e-01, 2.74080220e-01, 8.95021851e-01,\n       5.30589171e-01, 6.62250513e-01, 8.64017361e-01, 3.16234042e-01,\n       1.88104862e-01, 5.57143310e-01, 8.17542081e-01, 8.58312274e-01,\n       5.01593115e-02, 7.92609803e-01, 2.75257158e-01, 1.06116893e-01,\n       2.96840193e-01, 1.21722548e-01, 3.73409647e-01, 4.84855204e-01,\n       9.22876849e-01, 8.74894519e-01, 7.52243348e-01, 9.78958211e-02,\n       4.50270849e-01, 3.30712733e-01, 9.77906312e-01, 9.14776224e-01,\n       9.13868879e-01, 8.38384506e-01, 7.49295400e-01, 7.10760466e-01,\n       5.26938341e-01, 5.82278280e-01, 4.80260639e-01, 5.05936164e-01,\n       1.61046049e-01, 2.43229116e-01, 2.34171132e-01, 3.40931217e-01,\n       4.66680644e-01, 4.43303703e-01, 9.16474167e-01, 1.64046955e-01,\n       4.32778458e-01, 2.50382062e-01, 9.69336428e-01, 5.05868856e-01,\n       5.97572988e-01, 9.61026988e-01, 6.88217480e-01, 5.12134690e-01,\n       3.64972923e-01, 7.74441496e-01, 4.08990526e-01, 7.56958925e-01,\n       2.00530754e-01, 2.37046734e-02, 3.14880132e-01, 7.18777612e-01,\n       9.93411364e-01, 2.04545022e-01, 8.13393436e-01, 6.02388676e-01,\n       4.72424496e-01, 9.15535640e-01, 5.49467740e-01, 5.53611078e-01,\n       3.79539326e-02, 6.23560704e-01, 7.76300109e-01, 5.83428729e-01,\n       8.06469228e-01, 5.88682791e-01, 7.01220649e-01, 2.81851476e-01,\n       1.52021601e-01, 5.65156070e-01, 7.32794705e-01, 5.48162882e-01,\n       1.77599121e-01, 8.06796579e-01, 1.76029382e-01, 4.15069242e-01,\n       8.61067741e-01, 2.03767686e-01, 3.03374987e-01, 9.56281712e-01,\n       4.96929571e-01, 2.63140565e-01, 5.48214506e-03, 5.07201406e-01,\n       8.67810292e-01, 2.55675259e-01, 6.05977714e-01, 4.75479148e-02,\n       3.11960444e-03, 5.54840591e-01, 1.10582273e-01, 9.77321754e-01,\n       6.44707923e-01, 4.92329798e-01, 4.38426760e-01, 9.96039697e-02,\n       7.20558841e-01, 9.66520259e-01, 5.57218602e-01, 5.66755844e-01,\n       2.00055375e-01, 2.01626605e-01, 1.97593822e-02, 7.08782545e-01,\n       7.83318769e-01, 6.05374008e-01, 8.84005733e-02, 9.24494874e-02,\n       3.37631718e-01, 6.71974027e-01, 8.11094465e-01, 6.48130078e-01,\n       8.56567945e-02, 4.15919142e-01, 1.13229127e-01, 3.84815962e-01,\n       8.98405796e-01, 8.28333721e-01, 6.31976262e-01, 2.10819193e-01,\n       1.02017242e-01, 8.48920389e-01, 5.02509110e-01, 8.23674751e-02,\n       8.78193787e-01, 5.43596167e-01, 9.36220894e-01, 3.72718503e-02,\n       2.33907671e-01, 3.32317764e-01, 1.16643626e-01, 1.79741474e-01,\n       5.50346034e-01, 3.14914038e-01, 4.66292031e-01, 1.19050105e-01,\n       9.67330379e-01, 5.17209722e-01, 3.29413257e-01, 5.06939964e-01,\n       6.77473761e-01, 4.39335185e-01, 5.36633968e-01, 5.08119033e-01,\n       6.60915553e-01, 2.81602932e-01, 7.67412814e-01, 4.37584231e-01,\n       8.53253295e-01, 3.60466663e-01, 1.99149777e-01, 2.73663273e-01,\n       8.36071859e-02, 6.51674516e-01, 2.40058390e-01, 3.99561750e-01,\n       2.94306151e-01, 2.59131632e-01, 9.21081146e-01, 9.77457778e-01,\n       7.59463906e-01, 9.17235823e-01, 2.24739173e-01, 8.95179168e-03,\n       3.32654963e-01, 1.85178069e-01, 1.56566257e-01, 9.86649044e-01,\n       1.83058118e-01, 3.60504984e-01, 3.47485932e-02, 7.00267040e-01,\n       4.87796298e-01, 1.26143539e-01, 2.68842854e-01, 5.48578408e-02,\n       9.76707585e-01, 3.06238432e-01, 6.29145369e-02, 8.71402212e-01,\n       5.46726494e-01, 5.70306434e-01, 3.83497303e-01, 6.60174228e-01,\n       3.03535071e-01, 5.92221133e-01, 2.48318360e-01, 4.25080529e-01,\n       2.38926593e-01, 9.21466382e-01, 4.86994228e-01, 5.98600799e-01,\n       6.02966315e-01, 8.81515304e-01, 5.01991498e-01, 9.55579830e-01,\n       8.03049675e-01, 8.89482334e-01, 5.86259040e-01, 2.98590937e-01,\n       1.70701098e-01, 6.76465597e-01, 4.68659805e-02, 5.81771565e-01,\n       4.30385329e-01, 1.94970270e-01, 8.74490822e-01, 2.76041618e-01,\n       1.11886334e-01, 2.73645781e-01, 4.51729674e-01, 5.64951892e-01,\n       9.49877563e-01, 3.57451532e-01, 8.21238186e-01, 7.82852812e-01,\n       3.15079437e-01, 6.57408126e-01, 6.75003130e-01, 1.97777437e-01,\n       9.33368675e-01, 6.36717139e-02, 6.18067652e-02, 5.53587160e-01,\n       3.13264006e-01, 5.52835105e-01, 2.96553226e-01, 8.86666517e-01,\n       4.54500199e-01, 1.12838032e-01, 2.73088770e-01, 1.60579622e-01,\n       9.88848127e-01, 7.64797877e-01, 2.38755209e-01, 2.06513489e-01,\n       7.09747436e-01, 7.83601141e-01, 4.98321584e-01, 9.22615238e-01,\n       4.33066353e-01, 5.96670489e-01, 6.22017475e-02, 5.40068839e-01,\n       2.28925449e-01, 1.21800229e-01, 3.62077305e-01, 5.96335034e-01,\n       8.45790418e-01, 3.33130975e-01, 5.15639637e-01, 6.67838071e-01,\n       1.07683183e-02, 5.64992104e-01, 6.03295561e-01, 1.21048449e-01,\n       4.45780525e-01, 4.40698882e-01, 7.45671182e-01, 3.15114678e-01,\n       3.63511342e-01, 6.04209884e-02, 2.46925855e-01, 6.54217948e-01,\n       3.15348568e-01, 5.93983769e-01, 3.61622656e-01, 5.89536917e-01,\n       6.51420483e-01, 4.05148560e-01, 8.85472566e-01, 5.94187764e-03,\n       1.29931134e-01, 5.54676669e-01, 1.58565413e-01, 2.97718421e-01,\n       2.39183839e-01, 8.13161632e-01, 2.56432174e-01, 4.55495082e-01,\n       8.66773335e-01, 4.74161695e-01, 8.79824388e-01, 6.13388923e-01,\n       8.05616862e-01, 3.89964154e-01, 5.49124034e-01, 1.88516834e-02,\n       6.78648866e-01, 2.11352893e-02, 7.47267428e-01, 9.93132865e-01,\n       9.56919666e-01, 6.28902825e-01, 7.84826963e-01, 2.31412155e-01,\n       4.61915361e-01, 7.40138069e-01, 1.30809776e-01, 2.89822950e-01,\n       1.72577763e-01, 2.58512370e-01, 1.11739129e-01, 2.05501170e-01,\n       6.21224997e-01, 9.57338512e-01, 5.45806568e-01, 9.25340888e-01,\n       3.65686268e-01, 7.11680890e-01, 3.39997009e-01, 5.11716892e-01,\n       1.48922035e-01, 7.67503817e-01, 2.62191161e-01, 4.70173622e-01,\n       9.72929519e-01, 4.69575122e-01, 9.09733151e-01, 8.44748028e-01,\n       5.02236810e-01, 1.34381388e-01, 1.85123585e-01, 4.22317586e-01,\n       4.36513643e-01, 7.68556667e-01, 7.44617946e-01, 8.07089891e-02,\n       3.67476926e-01, 3.92403075e-02, 2.27581056e-01, 9.55978199e-01,\n       2.67355271e-01, 1.09349430e-01, 6.84934585e-01, 9.57111536e-02,\n       9.15547961e-01, 6.26693750e-01, 6.91814895e-01, 5.52959059e-01,\n       3.60970462e-01, 3.03738771e-02, 2.86480059e-01, 5.99010907e-02,\n       7.71218831e-01, 4.30088632e-01, 6.74977103e-01, 8.35081532e-01,\n       2.95654631e-01, 8.74616706e-01, 1.24960991e-01, 5.26928286e-01,\n       7.77395342e-01, 7.39842315e-01, 6.60814147e-01, 5.65130412e-01,\n       2.20348043e-01, 2.38456453e-01, 9.31657446e-03, 4.48256654e-01,\n       2.65352845e-01, 2.40815269e-01, 6.38530143e-01, 1.56858034e-01,\n       2.36504980e-01, 7.46484788e-01, 3.97029208e-01, 7.67796987e-01,\n       1.80498800e-01, 3.82578022e-01, 6.21753653e-01, 5.82020157e-01,\n       2.96019333e-01, 9.92414322e-01, 3.89788153e-01, 6.38642355e-01,\n       1.66983293e-01, 1.73415192e-01, 1.37398670e-02, 2.37580668e-01,\n       1.99639036e-01, 7.95087954e-01, 1.77660488e-01, 3.70720849e-01,\n       9.26332543e-01, 3.83092454e-01, 1.57896459e-01, 8.87986269e-01,\n       1.62724795e-01, 9.43776004e-01, 9.47770523e-01, 2.08565739e-01,\n       2.56907715e-01, 6.80663558e-01, 3.41946270e-01, 1.34994192e-01,\n       4.94789023e-01, 5.66743643e-03, 2.45165622e-01, 6.19023288e-01,\n       9.75593920e-01, 5.92461338e-02, 9.09004205e-02, 4.63243802e-01,\n       8.22387350e-01, 1.70918091e-01, 5.75100984e-01, 3.35140369e-01,\n       4.68705969e-01, 1.47151202e-01, 8.47253985e-01, 4.19769574e-01,\n       2.68394636e-02, 6.12353914e-01, 2.57518300e-01, 7.60307339e-01,\n       1.18149812e-02, 4.16342047e-01, 6.39608253e-01, 3.22392740e-01,\n       3.74420155e-01, 3.90134937e-01, 6.81239224e-01, 9.29478422e-01,\n       9.29048739e-01, 2.20197109e-01, 5.48000828e-01, 4.47280939e-01,\n       2.26052968e-01, 6.74115280e-01, 8.49571863e-01, 6.92680684e-01,\n       2.41917850e-01, 8.63866200e-01, 7.37356681e-01, 3.91472579e-01,\n       6.11947071e-01, 7.22743143e-01, 7.29350342e-01, 3.82094538e-01,\n       1.13268130e-01, 6.61689390e-01, 5.48965399e-01, 5.78609601e-01,\n       8.28296877e-01, 8.66148183e-01, 6.06183160e-01, 7.43907862e-01,\n       6.84041139e-01, 5.04629593e-01, 5.85694492e-01, 5.44613518e-01,\n       5.04709317e-01, 3.67703861e-01, 7.06676888e-01, 8.14875765e-02,\n       4.58417580e-01, 5.44996000e-01, 8.40103325e-01, 4.09019151e-01,\n       4.54258064e-01, 5.01554503e-01, 8.82274163e-01, 6.98791958e-01,\n       4.94292773e-01, 2.70974854e-01, 9.80345041e-01, 3.77745309e-01,\n       3.54225457e-01, 3.57946109e-01, 1.63522213e-01, 5.04434221e-01,\n       1.57169153e-01, 2.62902242e-01, 7.54080831e-01, 1.42662222e-01,\n       4.89198857e-02, 8.96956676e-01, 1.66028183e-01, 1.05744495e-01,\n       5.77262122e-01, 4.95333468e-01, 2.69221539e-01, 7.50629043e-02,\n       8.00641226e-01, 6.37875957e-01, 1.44590932e-01, 2.89403720e-01,\n       8.29014256e-01, 9.06232511e-01, 5.34988220e-01, 1.88377352e-01,\n       1.40360738e-02, 1.21884387e-01, 8.53648493e-01, 7.39454445e-01,\n       2.55709883e-01, 4.96526758e-01, 1.41675501e-01, 1.10881288e-01,\n       2.27003581e-02, 5.06955737e-01, 7.12320947e-01, 6.13523558e-02,\n       4.05780570e-01, 5.75356159e-01, 4.27570251e-01, 3.91731663e-02,\n       3.59125118e-01, 6.07530855e-01, 2.09980493e-01, 6.37577808e-01,\n       4.67977959e-01, 6.67936873e-01, 5.15925675e-01, 1.72443532e-02,\n       9.90899812e-01, 6.63725434e-01, 2.65976611e-02, 3.29401293e-01,\n       2.03772643e-01, 5.25321081e-01, 5.21774029e-01, 3.61756661e-01,\n       7.01433873e-01, 8.60661979e-01, 2.83490606e-01, 9.75994671e-02,\n       9.97636879e-01, 8.39402421e-01, 2.89122434e-01, 6.01370400e-01,\n       7.78274265e-02, 9.58840484e-01, 2.95308935e-01, 2.73414800e-01,\n       2.15145912e-01, 2.32607254e-01, 8.99541130e-01, 2.61819681e-01,\n       4.29901612e-01, 5.09332053e-01, 7.76760074e-01, 9.66727606e-01,\n       9.03271662e-01, 5.21577287e-01, 7.01896898e-01, 2.48531042e-01,\n       5.48329026e-01, 1.89795727e-01, 1.16278273e-01, 7.70498781e-02,\n       7.98109521e-01, 3.07431651e-01, 9.33656812e-01, 7.09477107e-01,\n       6.03351999e-01, 3.42529819e-01, 3.89799751e-01, 8.14044765e-01,\n       5.48647495e-01, 6.78955853e-01, 5.27875352e-01, 9.22524052e-01,\n       4.64668625e-01, 7.77288260e-01, 6.63861343e-01, 7.56830805e-01,\n       3.87510118e-01, 3.39214872e-01, 4.09521302e-01, 4.99021471e-02,\n       6.71094039e-02, 8.71835442e-01, 7.14479803e-01, 8.71500636e-01,\n       4.70883837e-01, 3.38454678e-01, 1.93298748e-01, 9.08053118e-03,\n       1.19849570e-02, 8.25213241e-01, 3.45732425e-02, 1.25061895e-01,\n       9.67070867e-01, 9.52576638e-02, 1.13074586e-01, 8.66017214e-01,\n       8.56738468e-01, 6.34160252e-01, 5.21817310e-01, 2.37326991e-02,\n       4.45799054e-02, 1.17434528e-01, 8.40408591e-01, 5.55745783e-01,\n       7.56024738e-01, 6.23063634e-01, 2.26936673e-01, 6.02586173e-01,\n       7.99224608e-02, 2.75581484e-01, 7.36358231e-01, 3.16760623e-01,\n       3.88639057e-01, 3.14300712e-01, 7.05166414e-01, 9.96209335e-01,\n       8.13363557e-01, 3.00410449e-02, 3.44026549e-01, 6.82195590e-01,\n       4.77584431e-01, 1.08808256e-01, 9.29270784e-01, 1.16843153e-01,\n       6.11075707e-01, 9.44947830e-01, 2.16341973e-01, 1.38111313e-01,\n       2.31941259e-01, 7.93296534e-01, 7.84660508e-01, 9.62220776e-01,\n       9.78038714e-01, 2.56622990e-01, 2.52882748e-01, 8.58728884e-01,\n       2.47908013e-01, 8.25546762e-01, 5.73483018e-01, 5.18959054e-01,\n       8.54767299e-01, 5.67634881e-01, 7.72012376e-01, 8.45391591e-01,\n       2.53787662e-01, 9.26891731e-01, 4.02300539e-01, 4.04906953e-01,\n       8.96553754e-01, 4.03917983e-01, 2.46264529e-01, 6.63359181e-01,\n       7.97039743e-01, 1.21872038e-01, 2.47078205e-02, 3.44022010e-01,\n       6.14689214e-01, 2.46268973e-01, 1.16183060e-01, 5.92593818e-02,\n       9.36196851e-01, 1.80862637e-01, 1.56036063e-01, 3.28245470e-01,\n       6.25056396e-01, 9.60057105e-01, 9.80454137e-01, 7.38615659e-01,\n       6.38647060e-01, 4.21520023e-01, 6.41029746e-01, 1.55398359e-01,\n       1.38090820e-01, 4.41676356e-01, 2.09316965e-01, 1.39274604e-01,\n       6.20597119e-01, 2.93102739e-01, 4.77086274e-01, 4.94198881e-01,\n       1.81244310e-01, 4.66419340e-04, 2.20412012e-01, 4.65466297e-01,\n       3.86666608e-01, 6.60946666e-01, 7.13174475e-01, 9.10054744e-01,\n       2.58206349e-01, 8.46718455e-01, 4.40410752e-01, 1.81451945e-01,\n       5.64716926e-01, 6.01446750e-01, 1.06598346e-01, 3.37186056e-01,\n       4.10934087e-01, 3.00209335e-01, 6.95339769e-01, 1.37981177e-01,\n       4.69806787e-01, 8.22103214e-03, 2.93250660e-01, 9.72403853e-01,\n       9.10775460e-02, 7.68391492e-01, 4.71175346e-01, 2.40473886e-01,\n       6.39844114e-01, 7.71800659e-01, 1.41401672e-01, 8.53959169e-01,\n       2.47556814e-01, 7.74939840e-01, 4.45042170e-02, 2.73398114e-01,\n       5.54265246e-01, 8.63758971e-01, 7.74219411e-01, 4.16773829e-01,\n       7.25118538e-01, 5.39290104e-01, 1.08711474e-01, 8.25583851e-02,\n       3.06353166e-01, 3.83219529e-01, 8.60839451e-01, 6.79976844e-01,\n       7.25867199e-01, 9.85427779e-01, 4.16377951e-02, 5.28858098e-02,\n       3.77562877e-02, 7.36128174e-01, 9.58813188e-01, 1.35057390e-02,\n       3.90703157e-01, 9.18964128e-01, 2.34047390e-01, 4.81482219e-01,\n       4.56424670e-01, 6.74335839e-01, 7.76822974e-01, 8.24378193e-01,\n       7.11327420e-01, 1.47612393e-01, 1.15066955e-02, 9.90341638e-01,\n       8.25234650e-01, 7.49161961e-01, 8.16225638e-01, 4.60326996e-01,\n       2.97124482e-01, 8.54610518e-01, 5.38353447e-01, 9.61631350e-01,\n       2.02053203e-01, 3.98745264e-01, 8.97869081e-01, 2.17531012e-01,\n       7.17190664e-01, 8.42895400e-01, 5.09209175e-01, 2.77850835e-01,\n       7.70385101e-01, 8.98876379e-01, 2.26329732e-02, 7.01434107e-01,\n       4.83751864e-01, 5.78432737e-01, 8.58170356e-01, 6.29490891e-02,\n       1.36025401e-01, 5.23700295e-01, 4.73706162e-01, 3.11395564e-01,\n       3.40342608e-01, 3.84414625e-01, 2.87871960e-01, 2.53824671e-01,\n       5.81916507e-01, 5.30911228e-01, 9.35411249e-01, 2.77090201e-03,\n       2.87714150e-01, 2.84669971e-01, 6.69182996e-01, 5.17995845e-01,\n       8.30357304e-01, 4.08039237e-01, 6.70209778e-01, 7.09472033e-01,\n       9.77039514e-01, 1.30699083e-01, 7.45993968e-01, 6.47610354e-02,\n       6.18952393e-01, 1.07269919e-01, 6.18547614e-02, 6.14745389e-01,\n       8.45125076e-01, 1.37897722e-01, 7.49469598e-01, 3.09935872e-01,\n       1.57855778e-01, 9.14563453e-01, 4.60090006e-01, 6.86840379e-01,\n       6.13167260e-01, 5.71956868e-01, 1.84486682e-01, 4.19567448e-01,\n       8.01451099e-01, 2.59943308e-01, 8.23728384e-02, 6.84533421e-01,\n       7.52549554e-01, 8.28840346e-01, 6.17659030e-01, 2.97600327e-01,\n       1.73955591e-01, 3.05756051e-01, 2.03569042e-03, 2.54816952e-01,\n       4.81229534e-01, 8.34690453e-01, 2.58826221e-01, 1.11862945e-01,\n       3.10177435e-01, 8.08646191e-01, 9.51128390e-01, 7.56449872e-02,\n       7.83386996e-01, 4.60595694e-01, 4.58201195e-01, 5.10289507e-01,\n       7.58101706e-01, 9.16468399e-01, 1.28482444e-01, 2.58583506e-01,\n       6.96765118e-01, 5.84025781e-03, 6.92299901e-01, 4.59616732e-01,\n       4.50523518e-01, 7.40215177e-01, 3.62022582e-01, 1.37208974e-01,\n       6.51771446e-01, 7.82904524e-01, 9.52234843e-01, 2.89850315e-01,\n       6.88595675e-01, 7.69937931e-01, 4.58378344e-01, 9.38766474e-01,\n       7.63179411e-01, 1.36882670e-01, 5.56652611e-01, 4.64698167e-01,\n       2.43621928e-01, 1.34920453e-01, 5.40979105e-01, 9.16859843e-01,\n       7.63449237e-01, 1.51858144e-01, 8.46576703e-01, 2.21823340e-01,\n       8.16840578e-01, 9.24855411e-01, 4.55731745e-01, 7.04288066e-01,\n       4.78152964e-01, 4.25379117e-01, 4.75146881e-01, 3.36648240e-01,\n       3.66605023e-01, 1.88449642e-01, 6.46731540e-01, 9.75416668e-01,\n       1.63605016e-01, 3.90714947e-01, 2.82926824e-01, 7.73025605e-01,\n       3.60698230e-01, 4.32143099e-03, 3.13347157e-01, 4.75902720e-01,\n       1.58720271e-01, 1.73788611e-01, 1.45198501e-01, 8.55673458e-01,\n       1.85380867e-01, 5.08237057e-01, 3.55181571e-01, 9.86155074e-01,\n       7.14983227e-01, 4.80624993e-01, 9.08687883e-01, 2.45265759e-01,\n       3.94426028e-02, 2.72335210e-01, 5.45585942e-01, 9.67169884e-01,\n       3.83255134e-01, 6.22768792e-01, 5.42178103e-01, 6.89709536e-01,\n       4.53036264e-01, 2.74958603e-01, 5.31887941e-01, 4.07142284e-01,\n       3.96566101e-02, 9.52339397e-01, 9.80892467e-01, 1.61702610e-01,\n       9.16305525e-01, 8.12907902e-01, 7.82202816e-01, 6.91177192e-01,\n       6.48327907e-01, 5.89161241e-01, 2.09708712e-01, 9.87087151e-01,\n       8.80355881e-01, 2.39709542e-02, 9.80054161e-01, 5.58697731e-01,\n       7.66711638e-01, 8.39535815e-01, 2.76899511e-01, 1.12798250e-01,\n       5.19525737e-01, 5.50361612e-01, 2.69184868e-01, 4.55888948e-01,\n       1.14524741e-01, 7.97432455e-01, 9.47297306e-01, 2.10065007e-03,\n       3.25631610e-01, 3.93960918e-01, 1.70772596e-01, 9.78050550e-01,\n       2.29130937e-01, 7.56058374e-01, 3.67350583e-01, 6.92963971e-01,\n       8.69916159e-02, 2.93356699e-01, 6.65430208e-01, 1.86539047e-01,\n       3.98378860e-01, 9.84440292e-01, 6.01335919e-01, 1.05915265e-01,\n       4.35912414e-02, 3.47717412e-01, 9.45176602e-01, 9.58938703e-01])\n\n\n\n\nNormal distribution\nTo sample from a normal distribution, we can use the normal method of the generator. This method allows us to specify the mean and standard deviation of the distribution, as well as the number of samples to generate. The generated samples will follow a normal (Gaussian) distribution with the specified parameters.\n\nnormal_rv = rng.normal(loc=0, scale=4, size=10000)  # 10000 samples from a normal distribution with mean 0 and std dev 1\n\n\n# check that the sample mean and standard deviation are close to the specified values \n\nnormal_rv.mean()\n\n-0.00030211517930401043\n\n\n\nnormal_rv.std()\n\n3.988386668060006",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#sampling-a-siingle-value",
    "href": "08/lecture_working_with_numpy.html#sampling-a-siingle-value",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Sampling a siingle value",
    "text": "Sampling a siingle value\nIf we only want to sample a single value, we can simply not specify the size parameter, or set it to 1. This will return a single value sampled from the specified distribution.\n\nrng.integers(0,100) # run this multiple times to observe the random nature of the output\n\n22\n\n\nHowever, this can sometimes be more computationally costly than generating a larger sample and then selecting a single value from it.\n\nimport time\n\n# Timing a for loop that generates a random integer in each iteration\nstart_time = time.time()\nsteps = 1000000\nfor _ in range(steps):\n    # use a random value\n    val = 2*rng.integers(0, 100)\nelapsed_no_prealloc = time.time() - start_time\n\n# Timing a for loop that uses preallocated random integers\npreallocated = rng.integers(0, 100, size=steps)\nstart_time = time.time()\nfor u in preallocated:\n    val = 2*u  # use the preallocated value\nelapsed_prealloc = time.time() - start_time\n\nprint(f\"Time without preallocation: {elapsed_no_prealloc:.4f} seconds\")\nprint(f\"Time with preallocation: {elapsed_prealloc:.4f} seconds\")\n\nTime without preallocation: 0.9014 seconds\nTime with preallocation: 0.0658 seconds\n\n\nThis is a good example of the tradeoff between memory usage and computational efficiency: in modern machines, memory is quite cheap, so it is often more efficient to preallocate a larger array and then sample from it, rather than generating a single value at a time.\nA good size for preallocated numbers depends on your use case and available memory. Typical choices are:\n\nSmall tasks: 100 to 1,000 elements\nMedium tasks: 10,000 to 100,000 elements\nLarge tasks: 1,000,000 or more elements\n\nFor most data analysis or simulation tasks, starting with 100,000 elements is practical and efficient. Always ensure the size fits within your system’s memory limits.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "09/exercises_plotting_data_from_file.html",
    "href": "09/exercises_plotting_data_from_file.html",
    "title": "Plotting data from file",
    "section": "",
    "text": "How can we use what we have learnt in the past few workshops to read data from a file? And how can we plot this?\nOne way to then plot this data would be to extract the index and/or multiple columns we are interested in plotting and use matplotlib as we have done before.\nAs an example, we’ll look at a new data file. This contains a simulation of the (fractional) concentration change for two species in a reaction, “A” and “B” where \\(A \\rightarrow B\\).\n\ndata_filename = \"data/FIRST ORDER_k=0.0005.txt\"\n\nIf we open this file more directly in Python when we looked at a text file) we can take quick look at the contents to see what this looks like:\n\nopen_file = open(data_filename)\ndata_from_file = open_file.read()\nprint(data_from_file[0:200])\n\nTime    A   B   \n0   1   0   \n100 0.950565    0.0494353   \n200 0.903573    0.0964268   \n300 0.858905    0.141095    \n400 0.816445    0.183555    \n500 0.776083    0.223917    \n600 0.737717    0.262283    \n700 0.701248    0.298752    \n800 0.666582    0.33341\n\n\nFrom printing out the first 200 characters, we can see this looks like a table of data with each column separated by spaces. This looks nicely formatted with a title row including the column names and no extra header rows.\nWe will see in the next year that there are dedicate packages to manipulate large tabulated files. However, for now we can exploit numpy as a quick and effective way to read such input.\n\nimport numpy as np\n\ndata_kinetic_k0005 = np.genfromtxt(\"data/FIRST ORDER_k=0.0005.txt\", names=True)\n\nThis is a special kind of array called a structured array, because it has named fields. You can check this by querying the subproperties of the array:\n\ndata_kinetic_k0005.dtype.names\n\n('Time', 'A', 'B')\n\n\nThese various names are the fields of the array, corresponding to the columns in the file. This syntax is reminiscent of what we have seen in the case of dictionaries, where keys are used to specific other objects stored in the dictionary.\n\ndata_kinetic_k0005['A']\n\narray([1.        , 0.950565  , 0.903573  , 0.858905  , 0.816445  ,\n       0.776083  , 0.737717  , 0.701248  , 0.666582  , 0.633629  ,\n       0.602305  , 0.57253   , 0.544227  , 0.517323  , 0.491749  ,\n       0.467439  , 0.444331  , 0.422365  , 0.401486  , 0.381638  ,\n       0.362772  , 0.344838  , 0.327791  , 0.311586  , 0.296183  ,\n       0.281541  , 0.267623  , 0.254393  , 0.241817  , 0.229863  ,\n       0.218499  , 0.207698  , 0.19743   , 0.18767   , 0.178393  ,\n       0.169574  , 0.161191  , 0.153222  , 0.145648  , 0.138447  ,\n       0.131603  , 0.125097  , 0.118913  , 0.113035  , 0.107447  ,\n       0.102135  , 0.097086  , 0.0922865 , 0.0877243 , 0.0833876 ,\n       0.0792653 , 0.0753468 , 0.071622  , 0.0680813 , 0.0647157 ,\n       0.0615165 , 0.0584754 , 0.0555846 , 0.0528368 , 0.0502248 ,\n       0.0477419 , 0.0453818 , 0.0431383 , 0.0410057 , 0.0389786 ,\n       0.0370517 , 0.03522   , 0.0334789 , 0.0318239 , 0.0302506 ,\n       0.0287552 , 0.0273337 , 0.0259824 , 0.024698  , 0.023477  ,\n       0.0223164 , 0.0212132 , 0.0201645 , 0.0191677 , 0.0182201 ,\n       0.0173194 , 0.0164632 , 0.0156493 , 0.0148757 , 0.0141403 ,\n       0.0134413 , 0.0127768 , 0.0121452 , 0.0115448 , 0.0109741 ,\n       0.0104316 , 0.00991587, 0.00942568, 0.00895972, 0.00851679,\n       0.00809576, 0.00769554, 0.00731511, 0.00695349, 0.00660974,\n       0.00628298])\n\n\nThis data also has a column for “Time” as the number of seconds elapsed.\n\ndata_kinetic_k0005 ['Time']\n\narray([    0.,   100.,   200.,   300.,   400.,   500.,   600.,   700.,\n         800.,   900.,  1000.,  1100.,  1200.,  1300.,  1400.,  1500.,\n        1600.,  1700.,  1800.,  1900.,  2000.,  2100.,  2200.,  2300.,\n        2400.,  2500.,  2600.,  2700.,  2800.,  2900.,  3000.,  3100.,\n        3200.,  3300.,  3400.,  3500.,  3600.,  3700.,  3800.,  3900.,\n        4000.,  4100.,  4200.,  4300.,  4400.,  4500.,  4600.,  4700.,\n        4800.,  4900.,  5000.,  5100.,  5200.,  5300.,  5400.,  5500.,\n        5600.,  5700.,  5800.,  5900.,  6000.,  6100.,  6200.,  6300.,\n        6400.,  6500.,  6600.,  6700.,  6800.,  6900.,  7000.,  7100.,\n        7200.,  7300.,  7400.,  7500.,  7600.,  7700.,  7800.,  7900.,\n        8000.,  8100.,  8200.,  8300.,  8400.,  8500.,  8600.,  8700.,\n        8800.,  8900.,  9000.,  9100.,  9200.,  9300.,  9400.,  9500.,\n        9600.,  9700.,  9800.,  9900., 10000.])\n\n\nTo create a plot for time vs concentration of A, we can extract this data from our array\n\n# Extract time and concentration of A from our array\ntime = data_kinetic_k0005['Time']\nconcentration_A = data_kinetic_k0005[\"A\"]\n\nWe could then use matplotlib to plot this:\n\nimport matplotlib.pyplot as plt\n\n# Create our Figure and Axes objects for plotting\nfig, ax = plt.subplots()\n\n# Plot our data - time vs concentration of A\nax.plot(time, concentration_A)\n\n# Add x and y labels for this data\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Concentration\")\n\nText(0, 0.5, 'Concentration')\n\n\n\n\n\n\n\n\n\nThis simulation shows a clean relationship as concentration decreases over time (in an exponential way).\nSuppose we want to filter our data and plot only concentrations less than 0.5. We can simply create a boolean array that masks the invalid data.\n\nmask = concentration_A &lt;= 0.5\nconcentration_A_low = concentration_A[mask]\n# Make sure to match the time values (index) to our filtered data\ntime_low = time[mask]\n\nHere we have filtered our data to include all fractional concentrations less than (or equal to) 0.5. Notice we have also matched our time values to plot to these concentrations by extracting the index from our new array concentration_A_low.\n\n# Create our Figure and Axes objects for plotting\nfig, ax = plt.subplots()\n\n# Plot our data - time vs concentration of A\nax.plot(time_low, concentration_A_low)\n\n# Note: Alternative syntax! we can set multiple properties at once\nax.set(xlabel = \"Time (s)\",  ylabel=\"Concentration\")\n\n\n\n\n\n\n\n\nYou can also see the slope is similiar (in fact it is the same) between our unfiltered and filtered data (this is due to the exponential relationship).\n\n\nExercise\n\nRe-plot the un-filtered graph created above and add another line to show concentration of B vs time from the data_kinetic_k0005 array on the same plot.\n\n\nCan you include a label for A and B?\n\n\nCalculate the the sum of the concentrations for these two columns (A and B).\nRe-plot the graph created in the previous question and add this sum as a third line.\n\n\nConsider: What does this sum tell us about “A” is decaying into “B”?",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting data from file"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html",
    "href": "09/lecture_intro_matplotlib.html",
    "title": "Plotting with matplotlib",
    "section": "",
    "text": "One way to plot a graph in Python is to use the matplotlib package.\nMatplotlib is a powerful and widely-used Python library for creating static, animated, and interactive visualizations. It provides a flexible framework for generating a wide variety of plots and charts, making it a popular choice for data analysis and scientific research. With matplotlib, you can customize every aspect of your figures, from colors and styles to labels and legends.\nWe start by importing the pyplot sub-module from matplotlib.\nThe most widespread convention is to use the shorthand plt to refer to this package with the as syntax and so we can import this in the following way:\nimport matplotlib.pyplot as plt",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#figure-and-axes",
    "href": "09/lecture_intro_matplotlib.html#figure-and-axes",
    "title": "Plotting with matplotlib",
    "section": "Figure and Axes",
    "text": "Figure and Axes\nThere are two main interfaces for plotting using matplotlib.\n\nThe first is to use Pyplot (plt) to create a plot directly e.g. using plt.plot(). This is the type of syntax you may see often when looking online. This way of interacting with and plotting data was created to replicate the functionality of an alternative, and common programming language called MATLAB, which a lot of early Python adopters were familiar with.\nThe second, more modern way to create plots is to use the object-oriented approach where the figure is created first and then explicitly referenced when creating a plot. One way to do this is by calling the subplots() function to create a Figure (the canvas) and an Axes (the x-y axes) object which can then be used for plotting.\n\nfig, ax = plt.subplots()\nWe can plot using the ax object directly using whichever type of graph we want to create e.g.  - for a simple line graph we can use the plot() function - for a scatter graph we can use the scatter() function. - for a 1D histogram we can the hist() function\nYou can also add multiple graphs to the same set of Axes to plot sets of data on top of each other:\n\nimport numpy as np\nfrom numpy import random\n\nrng = random.default_rng(seed=124)\n\nx = np.arange(1, 56, 5)\ny1 = x**2\ny2 = x**2 + rng.normal(size=len(x))*100 # Add random noise to our scatter points\n\n\nfig, ax = plt.subplots()\nax.plot(x, y1)      # Plot line plot\nax.scatter(x, y2)   # Plot scatter plot as well\n\n\n\n\n\n\n\n\nYou may notice that unlike other Python you have been writing, in Jupyter notebooks you should keep your plotting code together in one code cell as this will immediately be displayed when the code cell is run.\nTo create another plot in a new cell you can create new Figure and Axes objects using the same names fig, ax or name them something different if you’d prefer.\nMatplotlib sample plots - https://matplotlib.org/3.3.3/tutorials/introductory/sample_plots.html\n\nAside: subplots\nYou may ask why the function for creating a new plot is called subplots(). By default, this function allows you to create one plot on one figure, which is usually what you want for an initial plot. However, it is possible to use the subplots() function to create multiple plots on the same figure. One way to do this is by specifying the number of rows (nrows) and number of columns (ncols) you want when using the subplots() function. Note that this will pass back an array of Axes objects rather than just one which you can then use to plot.\nWe won’t explore this further, but for more details on how this is done have a look at the subplots demo.\n\n\n\nExercise A\nFor this exercise, we have created some random sample data which we can plot. Here we have created several numpy arrays each 100 elements long (based on num_points).\n\nfrom numpy import random\n\nrng = random.default_rng(seed=68)\nnum_points = 100\n\nx_range = np.linspace(0.0, 1.0, num_points)\n\nrandom_sample1 = rng.normal(0.1, 0.5, size=num_points)\nrandom_sample2 = rng.random(num_points)\n\n\nCreate a scatter plot of x_range versus random_sample1.\n\n\nStart by creating your Figure and Axes objects (fig, ax) using the subplots function\nUse the scatter method to plot your data using your Axes object\n\n\n### ADD CODE HERE\n\n\nCreate a line plot of x_range versus random_sample2\n\n\nAs before, start by creating your Figure and Axes objects (fig, ax) using the subplots function\nUse the plot method to plot your data using your Axes object\n\n\n### ADD CODE HERE",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#annotating-and-adding-features",
    "href": "09/lecture_intro_matplotlib.html#annotating-and-adding-features",
    "title": "Plotting with matplotlib",
    "section": "Annotating and adding features",
    "text": "Annotating and adding features\nAs well as plotting you can, and should, add additional information to your plot as appropriate. For instance, you can:\n\nchange the style, colour etc. of your initial plot (e.g. see examples within matplotlib decoration)\nadd additional features such as axis labels, legend etc.\n\nThe code below demonstrates how we could customise the plot above using these inputs:\n\n1. Using more of the available plotting options\n\nfig, ax = plt.subplots(figsize=(8, 4))\n\nax.plot(x, y1, color=\"slategrey\", linestyle=\"--\")\nax.scatter(x, y2, color=\"indianred\", marker='+', s=60)\n\n\n\n\n\n\n\n\nWe can include more inputs for both our subplots function and our plotting functions such as plot() and scatter():\n\nFor the subplots() initial step we specified the figure size, figsize, as an input. This is set using a tuple of (width, height) in inches.\nFor the plot function we set:\n\nthe colour to be a named colour called “slategrey” using the color input\nthe style of the line to be dashed, using “–” and the linestyle input\n\nFor the scatter function we set:\n\nthe colour to be a named colour called “indianred” using the color input\nthe marker shape to a cross shape, using “+” and the marker input\nsize to be 60 (area of the marker) using the s input\n\n\nFor in-built options see: - Colours - https://matplotlib.org/stable/gallery/color/named_colors.html - Line style - https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html - Markers - https://matplotlib.org/api/markers_api.html\n\n\n2. Setting properties on the plot\n\nfig, ax = plt.subplots(figsize=(8, 4))\n\nax.plot(x, y1, color=\"slategrey\", linestyle=\"--\")\nax.scatter(x, y2, color=\"indianred\", marker='+', s=60)\n\n### ADDED x and y labels and an x limit\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.set_xlim(0, 52)\n\n\n\n\n\n\n\n\nHere we set additional parameters for the plot - the x and y labels and an x limit. We have done this by calling the relevant functions (e.g. set_xlabel, set_ylim) on our ax variable.\nFor some examples of different Axes functions of this type see: - Axes - labels and limits - https://matplotlib.org/stable/api/axes_api.html#axis-labels-title-and-legend - Axes - tick labels - https://matplotlib.org/stable/api/axes_api.html#ticks-and-tick-labels\n\n\n3. Additional labelling - legend\n\nfig, ax = plt.subplots(figsize=(8, 4))\n\n### Added labels for each of the plots\nax.plot(x, y1, color=\"slategrey\", linestyle=\"--\", label=\"Fitted line\")  # label input added when plotting\nax.scatter(x, y2, color=\"indianred\", marker='+', s=60, label=\"Measurements\")  # label input added when plotting\n\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.set_xlim(0, 52)\n\n### Asked for a legend to be displayed\nax.legend()\n\n\n\n\n\n\n\n\nA legend can be created using the .legend() function (method) and this will use the label value supplied when creating each plot. If ax.legend() is not included then, even if a label variable is specified, no legend will be added to the plot.\nSee: - legend function - https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#other-plot-types",
    "href": "09/lecture_intro_matplotlib.html#other-plot-types",
    "title": "Plotting with matplotlib",
    "section": "Other plot types",
    "text": "Other plot types\nWe can also apply similiar principles to other plot types. We can generate some more random data to look at this. Here we have created two normal distributions containing different numbers of points.\n\n# Create random numbers (normal distribution) to plot\nfrom numpy import random\n\nrng = random.default_rng(seed=68)\nnumber_of_points_1 = 5000\nnumber_of_points_2 = 500\n\nx_rand1 = rng.normal(size=number_of_points_1)\nx_rand2 = rng.normal(size=number_of_points_2)\n\nWe could create a simple plot using the subplots function and the hist() function:\n\nfig, ax = plt.subplots()\n\nax.hist(x_rand1)\nax.hist(x_rand2)\n\n(array([ 10.,  30.,  66., 103.,  93.,  93.,  55.,  40.,   7.,   3.]),\n array([-2.48175617, -1.9278922 , -1.37402822, -0.82016424, -0.26630026,\n         0.28756372,  0.8414277 ,  1.39529168,  1.94915565,  2.50301963,\n         3.05688361]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\n\n\nUsing the exact same data we could update our plot using relevant inputs for our hist function and setting values on our axis:\n\nfig, ax = plt.subplots()\n\n# Create an explicit range to use for our histogram bins\nbins = np.arange(-3, 3, 0.2)\n\n# Include colour, transparency (alpha), plot type (density) inputs as well as a label\nax.hist(x_rand1, color=\"skyblue\", alpha=0.7, bins=bins, density=True, label=\"Sample 1\")\nax.hist(x_rand2, color=\"tan\", alpha=0.7, bins=bins, density=True, label=\"Sample 2\")\n\n# Update plotting area to label and set axes limits\nax.set_xlabel(\"y\")\nax.set_ylabel(\"Number in x\")\nax.set_xlim(-3, 3)\nax.set_ylim(0, 0.5)\n\n# Add legend to the plot (uses labels defined above)\nax.legend()\n\n\n\n\n\n\n\n\nFor our histogram, in addition to options we used for our scatter and line plot, we have set more options available to us: - alpha - This allows us to make our data partially transparent to better view overlapping data - bins - We defined and included an input for the bin sizes rather than using the default - density - This is a plot type we can set which normalised our data for the different datasets. This can be useful if you are comparing datasets which have different sample sizes.\nIn general, you will need to look at the specific documentation for each of the the plot types to see what options are available.",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#anatomy-of-a-figure",
    "href": "09/lecture_intro_matplotlib.html#anatomy-of-a-figure",
    "title": "Plotting with matplotlib",
    "section": "Anatomy of a figure",
    "text": "Anatomy of a figure\nThis is a summary image to show the make up (anatomy) of a plot in matplotlib.\n\nYou can see some features we have described above such as “Figure”, “Axes”, “x axis label”, “y axis label”, “legend”. But you can also see how our inputs have influenced other aspects of the plot e.g. “Major tick”, “Minor tick”, “Major tick label”, “Minor tick label”, which were updated when we set the limits on the x and y axes, and “Markers” from our scatter plot which updated the marker style and colour.\nBecoming familiar with this terminology when applied to a matplotlib figure allows you to put a name to any part of the plot you wish to modify and to dig into the features offered for how to update these plots.\n\n\nExercise B\n\nCreate a scatter plot with the same data from Exercise A showing x_range versus random_sample1 adding or setting the following features:\n\n\nchanging the marker and colour\nsetting appropriate x and y labels\n\nRemember, you always need to recreate your fig and ax objects using the subplots function to create a new plot using Jupyter notebooks\n\n### ADD CODE HERE (copy code from Exercise A1 to start)\n\n\nCreate a histogram plot overlaying data from random_sample1 and random_sample2.\n\n\nExperiment with different inputs to see if you can improve the default plot (e.g. setting the bin size, including transparency, changing the colours etc.)\nYou can also look at the hist() function documentation for more inputs to try e.g. histtype.\n\n\n### ADD CODE HERE\n\nExtra. Create a plot containing both a scatter plot for x_range versus random_sample1 AND a line plot for x_range versus random_sample2. Add or set the following features: - changing the line style and colour - setting a title for your plot\nHint: Look at “set_” commands within https://matplotlib.org/stable/api/axes_api.html#axis-labels-title-and-legend\n\n### ADD CODE HERE\n\n\nExtended: Pick an interesting plot from the matplotlib gallery and see if you replicate some of the additional features for these plots.\n\nYou can now proceed with the remaining exercises\n\nExercise C - Plotting data from a file\nA fun session - Using matplotlib to create a fun plot",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html",
    "href": "07/exercises_numpy_solutions.html",
    "title": "numpy Exercises",
    "section": "",
    "text": "These exercises test your understanding of the NumPy concepts covered in the introduction notebook.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-1-import-and-basic-array-creation",
    "href": "07/exercises_numpy_solutions.html#exercise-1-import-and-basic-array-creation",
    "title": "numpy Exercises",
    "section": "Exercise 1: Import and Basic Array Creation",
    "text": "Exercise 1: Import and Basic Array Creation\nTask: Import NumPy with the standard import command and create a NumPy array from the list [2, 4, 6, 8, 10, 12]. Print the array, its data type, and its shape.\n\nimport numpy as np\n\narr = np.array([2, 4, 6, 8, 10, 12])\nprint(\"Array:\", arr)\nprint(\"Data type:\", arr.dtype)\nprint(\"Shape:\", arr.shape)\n\nArray: [ 2  4  6  8 10 12]\nData type: int64\nShape: (6,)",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-2-array-indexing-and-slicing",
    "href": "07/exercises_numpy_solutions.html#exercise-2-array-indexing-and-slicing",
    "title": "numpy Exercises",
    "section": "Exercise 2: Array Indexing and Slicing",
    "text": "Exercise 2: Array Indexing and Slicing\nTask: Using the array you created in Exercise 1:\n\nPrint the first element\nPrint the last element\nPrint elements from index 2 to 4 (inclusive of 2, exclusive of 5)\nPrint every second element\n\n\nprint(\"First element:\", arr[0])\nprint(\"Last element:\", arr[-1])\nprint(\"Elements from index 2 to 4:\", arr[2:5])\nprint(\"Every second element:\", arr[::2])\n\nFirst element: 2\nLast element: 12\nElements from index 2 to 4: [ 6  8 10]\nEvery second element: [ 2  6 10]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-3-element-wise-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-3-element-wise-operations",
    "title": "numpy Exercises",
    "section": "Exercise 3: Element-wise Operations",
    "text": "Exercise 3: Element-wise Operations\nTask: Create a NumPy array arr = np.array([1, 4, 9, 16, 25]). Perform the following operations and print the results:\n\nMultiply each element by 3\nAdd 10 to each element\nCalculate the square root of each element\nApply the sine function to each element\n\n\narr = np.array([1, 4, 9, 16, 25])\nprint(\"Original array:\", arr)\nprint(\"Multiply by 3:\", arr * 3)\nprint(\"Add 10:\", arr + 10)\nprint(\"Square root:\", np.sqrt(arr))\nprint(\"Sine function:\", np.sin(arr))\n\nOriginal array: [ 1  4  9 16 25]\nMultiply by 3: [ 3 12 27 48 75]\nAdd 10: [11 14 19 26 35]\nSquare root: [1. 2. 3. 4. 5.]\nSine function: [ 0.84147098 -0.7568025   0.41211849 -0.28790332 -0.13235175]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-4-array-operations-with-two-arrays",
    "href": "07/exercises_numpy_solutions.html#exercise-4-array-operations-with-two-arrays",
    "title": "numpy Exercises",
    "section": "Exercise 4: Array Operations with Two Arrays",
    "text": "Exercise 4: Array Operations with Two Arrays\nTask: Create two NumPy arrays:\n\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([10, 20, 30, 40, 50])\n\nPerform element-wise operations and print the results:\n\nAdd the two arrays\nSubtract arr1 from arr2\nMultiply the two arrays\nDivide arr2 by arr1\n\n\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([10, 20, 30, 40, 50])\n\nprint(\"arr1:\", arr1)\nprint(\"arr2:\", arr2)\nprint(\"Addition:\", arr1 + arr2)\nprint(\"Subtraction (arr2 - arr1):\", arr2 - arr1)\nprint(\"Multiplication:\", arr1 * arr2)\nprint(\"Division (arr2 / arr1):\", arr2 / arr1)\n\narr1: [1 2 3 4 5]\narr2: [10 20 30 40 50]\nAddition: [11 22 33 44 55]\nSubtraction (arr2 - arr1): [ 9 18 27 36 45]\nMultiplication: [ 10  40  90 160 250]\nDivision (arr2 / arr1): [10. 10. 10. 10. 10.]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-5-shape-mismatch-error",
    "href": "07/exercises_numpy_solutions.html#exercise-5-shape-mismatch-error",
    "title": "numpy Exercises",
    "section": "Exercise 5: Shape Mismatch Error",
    "text": "Exercise 5: Shape Mismatch Error\nTask: Create two arrays with different lengths:\n\narr_a = np.array([1, 2, 3, 4])\narr_b = np.array([10, 20])\n\nTry to add these arrays together. What happens? Write the code and explain the error in a comment.\n\narr_a = np.array([1, 2, 3, 4])\narr_b = np.array([10, 20])\n\nprint(\"arr_a:\", arr_a)\nprint(\"arr_b:\", arr_b)\n\ntry:\n    result = arr_a + arr_b\n    print(\"Result:\", result)\nexcept ValueError as e:\n    print(\"Error occurred:\", e)\n    \n# This happens because the arrays have different shapes: (4,) and (2,)\n# NumPy cannot broadcast these shapes together for element-wise operations\n# The arrays must have compatible shapes for element-wise operations\n\narr_a: [1 2 3 4]\narr_b: [10 20]\nError occurred: operands could not be broadcast together with shapes (4,) (2,)",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-6-reductive-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-6-reductive-operations",
    "title": "numpy Exercises",
    "section": "Exercise 6: Reductive Operations",
    "text": "Exercise 6: Reductive Operations\nTask: Create a NumPy array data = np.array([12, 8, 15, 3, 7, 20, 11, 9]). Calculate and print:\n\nThe sum of all elements\nThe mean (average) of all elements\nThe maximum value\nThe minimum value\nThe standard deviation\n\n\ndata = np.array([12, 8, 15, 3, 7, 20, 11, 9])\n\nprint(\"Data:\", data)\nprint(\"Sum:\", np.sum(data))\nprint(\"Mean:\", np.mean(data))\nprint(\"Maximum:\", np.max(data))\nprint(\"Minimum:\", np.min(data))\nprint(\"Standard deviation:\", np.std(data))\n\nData: [12  8 15  3  7 20 11  9]\nSum: 85\nMean: 10.625\nMaximum: 20\nMinimum: 3\nStandard deviation: 4.871793817476269",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-7-array-manipulation",
    "href": "07/exercises_numpy_solutions.html#exercise-7-array-manipulation",
    "title": "numpy Exercises",
    "section": "Exercise 7: Array Manipulation",
    "text": "Exercise 7: Array Manipulation\nTask: Create a NumPy array numbers = np.array([5, 2, 8, 1, 9, 3]). Perform the following operations:\n\nSort the array and print the result\nCalculate the cumulative sum and print the result\nCreate a new array with duplicates: with_duplicates = np.array([5, 2, 8, 1, 9, 3, 5, 2, 1]) and find the unique elements\n\n\nnumbers = np.array([5, 2, 8, 1, 9, 3])\nprint(\"Original numbers:\", numbers)\nprint(\"Sorted array:\", np.sort(numbers))\nprint(\"Cumulative sum:\", np.cumsum(numbers))\n\nwith_duplicates = np.array([5, 2, 8, 1, 9, 3, 5, 2, 1])\nprint(\"Array with duplicates:\", with_duplicates)\nprint(\"Unique elements:\", np.unique(with_duplicates))\n\nOriginal numbers: [5 2 8 1 9 3]\nSorted array: [1 2 3 5 8 9]\nCumulative sum: [ 5  7 15 16 25 28]\nArray with duplicates: [5 2 8 1 9 3 5 2 1]\nUnique elements: [1 2 3 5 8 9]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-8-list-vs-numpy-comparison",
    "href": "07/exercises_numpy_solutions.html#exercise-8-list-vs-numpy-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 8: List vs NumPy Comparison",
    "text": "Exercise 8: List vs NumPy Comparison\nTask: Compare the flexibility of lists vs NumPy arrays:\n\nCreate a Python list containing mixed data types: mixed_list = [1, 'hello', 3.14, True]\nTry to create a NumPy array from this list. What happens to the data types?\nCreate a list of numbers: num_list = [1, 2, 3, 4, 5]\nTry to multiply the entire list by 2 using num_list * 2. What happens?\nCreate a NumPy array from the same numbers and multiply by 2. Compare the results.\n\n\n# Mixed data types\nmixed_list = [1, 'hello', 3.14, True]\nprint(\"Mixed list:\", mixed_list)\n\nmixed_array = np.array(mixed_list)\nprint(\"NumPy array from mixed list:\", mixed_array)\nprint(\"Array dtype:\", mixed_array.dtype)\nprint(\"# NumPy converted everything to strings (the most general type)\")\n\n# List multiplication vs NumPy\nnum_list = [1, 2, 3, 4, 5]\nprint(\"\\nNumeric list:\", num_list)\nprint(\"List * 2:\", num_list * 2)\nprint(\"# List multiplication repeats the entire list\")\n\nnum_array = np.array([1, 2, 3, 4, 5])\nprint(\"NumPy array:\", num_array)\nprint(\"Array * 2:\", num_array * 2)\nprint(\"# NumPy multiplication is element-wise\")\n\nMixed list: [1, 'hello', 3.14, True]\nNumPy array from mixed list: ['1' 'hello' '3.14' 'True']\nArray dtype: &lt;U32\n# NumPy converted everything to strings (the most general type)\n\nNumeric list: [1, 2, 3, 4, 5]\nList * 2: [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n# List multiplication repeats the entire list\nNumPy array: [1 2 3 4 5]\nArray * 2: [ 2  4  6  8 10]\n# NumPy multiplication is element-wise",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-9-performance-comparison",
    "href": "07/exercises_numpy_solutions.html#exercise-9-performance-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 9: Performance Comparison",
    "text": "Exercise 9: Performance Comparison\nTask: Compare the performance of list comprehension vs NumPy operations:\n\nImport the time module\nCreate a range of 50,000 numbers using numpy np.arange()\nTime how long it takes to square each number using a list comprehension, i.e. the syntax [x**2 for x in myarray]\nTime how long it takes to square each number using NumPy operations\nCalculate and print how many times faster the NumPy operation is\n\n\nimport time\n\nnum_range = 50000\ntest_array = np.arange(num_range)\n\n# List comprehension timing\ntime1 = time.time()\nlist_squared = [x**2 for x in test_array]\ntime2 = time.time()\nlist_time = time2 - time1\n\n# NumPy operation timing\ntime1 = time.time()\narr_squared = test_array**2\ntime2 = time.time()\narr_time = time2 - time1\n\nprint(f\"List comprehension time: {list_time:.6f} seconds\")\nprint(f\"NumPy operation time: {arr_time:.6f} seconds\")\n\nif arr_time &gt; 0:\n    print(f\"NumPy is {list_time/arr_time:.1f} times faster\")\nelse:\n    print(\"NumPy operation was too fast to measure accurately\")\n\nList comprehension time: 0.002060 seconds\nNumPy operation time: 0.000089 seconds\nNumPy is 23.2 times faster",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-10-complex-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-10-complex-operations",
    "title": "numpy Exercises",
    "section": "Exercise 10: Complex Operations",
    "text": "Exercise 10: Complex Operations\nTask: Create a NumPy array representing angles in degrees: angles_deg = np.array([0, 30, 45, 60, 90, 120, 180])\n\nConvert these angles to radians (hint: multiply by π/180, use np.pi)\nCalculate the sine and cosine of each angle\nVerify that sin²(x) + cos²(x) = 1 for each angle (use np.sin() and np.cos())\nPrint all results\n\n\nangles_deg = np.array([0, 30, 45, 60, 90, 120, 180])\nprint(\"Angles in degrees:\", angles_deg)\n\n# Convert to radians\nangles_rad = angles_deg * np.pi / 180\nprint(\"Angles in radians:\", angles_rad)\n\n# Calculate sine and cosine\nsin_values = np.sin(angles_rad)\ncos_values = np.cos(angles_rad)\nprint(\"Sine values:\", sin_values)\nprint(\"Cosine values:\", cos_values)\n\n# Verify sin²(x) + cos²(x) = 1\nverification = sin_values**2 + cos_values**2\nprint(\"sin²(x) + cos²(x):\", verification)\nprint(\"All close to 1?\", np.allclose(verification, 1))\n\nAngles in degrees: [  0  30  45  60  90 120 180]\nAngles in radians: [0.         0.52359878 0.78539816 1.04719755 1.57079633 2.0943951\n 3.14159265]\nSine values: [0.00000000e+00 5.00000000e-01 7.07106781e-01 8.66025404e-01\n 1.00000000e+00 8.66025404e-01 1.22464680e-16]\nCosine values: [ 1.00000000e+00  8.66025404e-01  7.07106781e-01  5.00000000e-01\n  6.12323400e-17 -5.00000000e-01 -1.00000000e+00]\nsin²(x) + cos²(x): [1. 1. 1. 1. 1. 1. 1.]\nAll close to 1? True\n\n\n\n# Additional verification - showing the identity holds for each angle\nfor i, angle in enumerate(angles_deg):\n    identity_value = sin_values[i]**2 + cos_values[i]**2\n    print(f\"{angle}°: sin²({angle}) + cos²({angle}) = {identity_value:.10f}\")\n\n0°: sin²(0) + cos²(0) = 1.0000000000\n30°: sin²(30) + cos²(30) = 1.0000000000\n45°: sin²(45) + cos²(45) = 1.0000000000\n60°: sin²(60) + cos²(60) = 1.0000000000\n90°: sin²(90) + cos²(90) = 1.0000000000\n120°: sin²(120) + cos²(120) = 1.0000000000\n180°: sin²(180) + cos²(180) = 1.0000000000",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#challenge-exercise-temperature-conversion",
    "href": "07/exercises_numpy_solutions.html#challenge-exercise-temperature-conversion",
    "title": "numpy Exercises",
    "section": "Challenge Exercise: Temperature Conversion",
    "text": "Challenge Exercise: Temperature Conversion\nTask: You have temperature readings in Celsius: celsius_temps = np.array([0, 10, 20, 25, 30, 35, 40])\n\nConvert all temperatures to Fahrenheit using the formula: F = (C × 9/5) + 32\nConvert all temperatures to Kelvin using the formula: K = C + 273.15\nCalculate the temperature range (max - min) for each scale\n\n\ncelsius_temps = np.array([0, 10, 20, 25, 30, 35, 40])\nprint(\"Celsius temperatures:\", celsius_temps)\n\n# Convert to Fahrenheit\nfahrenheit_temps = (celsius_temps * 9/5) + 32\nprint(\"Fahrenheit temperatures:\", fahrenheit_temps)\n\n# Convert to Kelvin\nkelvin_temps = celsius_temps + 273.15\nprint(\"Kelvin temperatures:\", kelvin_temps)\n\n# Calculate temperature ranges\ncelsius_range = np.max(celsius_temps) - np.min(celsius_temps)\nfahrenheit_range = np.max(fahrenheit_temps) - np.min(fahrenheit_temps)\nkelvin_range = np.max(kelvin_temps) - np.min(kelvin_temps)\n\nprint(f\"\\nTemperature ranges:\")\nprint(f\"Celsius: {celsius_range}°C\")\nprint(f\"Fahrenheit: {fahrenheit_range}°F\") \nprint(f\"Kelvin: {kelvin_range}K\")\n\n# Note: The range in Celsius and Kelvin is the same because it's just a shift\n# The range in Fahrenheit is larger due to the scaling factor (9/5)\n\nCelsius temperatures: [ 0 10 20 25 30 35 40]\nFahrenheit temperatures: [ 32.  50.  68.  77.  86.  95. 104.]\nKelvin temperatures: [273.15 283.15 293.15 298.15 303.15 308.15 313.15]\n\nTemperature ranges:\nCelsius: 40°C\nFahrenheit: 72.0°F\nKelvin: 40.0K\n\n\n## Challenge 2: Kinetic energy\n\n**Task** Given arrays of mass (kg) and velocity (m/s) for several objects:\n```python\n# copy and paste this code below\nmasses = np.array([2.0, 1.5, 3.0, 0.5])      # in kilograms\nvelocities = np.array([10.0, 20.0, 15.0, 5.0]) # in meters per second\n```\n\n1. Calculate the kinetic energy $K$ for each object using the formula: \n\n$$K =  \\dfrac{1}{2}m v^2$$\n\n2. Calculate the total kinetic energy of the system (sum of all objects)\n\nimport numpy as np\n\nmasses = np.array([2.0, 1.5, 3.0, 0.5])       # kg\nvelocities = np.array([10.0, 20.0, 15.0, 5.0]) # m/s\n\n# 1. Kinetic energy for each object\nkinetic_energy = 0.5 * masses * velocities**2\nprint(\"Kinetic energy of each object:\", kinetic_energy)\n\n# 2. Total kinetic energy of the system\ntotal_ke = np.sum(kinetic_energy)\nprint(\"Total kinetic energy:\", total_ke)\n\nKinetic energy of each object: [100.   300.   337.5    6.25]\nTotal kinetic energy: 743.75",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#challenge-3-temperature-analysis",
    "href": "07/exercises_numpy_solutions.html#challenge-3-temperature-analysis",
    "title": "numpy Exercises",
    "section": "Challenge 3: Temperature Analysis",
    "text": "Challenge 3: Temperature Analysis\nTask: Given a NumPy array of daily temperatures for 30 days:\ntemperatures = np.array([23.5, 24.0, 21.2, 25.6, 22.8, 23.9, 26.1, 27.3, 21.7, 22.5,\n                         24.6, 25.8, 20.9, 22.3, 24.7, 26.0, 27.5, 21.0, 22.9, 24.8,\n                         25.9, 27.6, 20.8, 22.7, 24.5, 26.2, 27.7, 20.5, 22.6, 24.9])\nPerform the following tasks:\n\nFind the top 3 hottest days and their temperatures.\nCalculate the day-to-day percentage change in temperature.\n\n\nimport numpy as np\n\ntemperatures = np.array([23.5, 24.0, 21.2, 25.6, 22.8, 23.9, 26.1, 27.3, 21.7, 22.5,\n                         24.6, 25.8, 20.9, 22.3, 24.7, 26.0, 27.5, 21.0, 22.9, 24.8,\n                         25.9, 27.6, 20.8, 22.7, 24.5, 26.2, 27.7, 20.5, 22.6, 24.9])\n\n# 1. Top 3 hottest days\ntop3_indices = np.argsort(temperatures)[-3:][::-1]\ntop3_temps = temperatures[top3_indices]\nprint(\"Top 3 hottest days (indices and temperatures):\", list(zip(top3_indices, top3_temps)))\n\n# 2. Day-to-day percentage change\npct_change = (temperatures[1:] - temperatures[:-1]) / temperatures[:-1] * 100\nprint(\"Day-to-day percentage change:\", pct_change)\n\nTop 3 hottest days (indices and temperatures): [(26, 27.7), (21, 27.6), (16, 27.5)]\nDay-to-day percentage change: [  2.12765957 -11.66666667  20.75471698 -10.9375       4.8245614\n   9.20502092   4.59770115 -20.51282051   3.68663594   9.33333333\n   4.87804878 -18.99224806   6.69856459  10.76233184   5.26315789\n   5.76923077 -23.63636364   9.04761905   8.29694323   4.43548387\n   6.56370656 -24.63768116   9.13461538   7.92951542   6.93877551\n   5.72519084 -25.99277978  10.24390244  10.17699115]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#aims",
    "href": "slides/07_intro_numpy_slides.html#aims",
    "title": "The numpy module",
    "section": "Aims",
    "text": "Aims\nBy the end of this lecture, you will be able to:\n\nExplain what the NumPy module is and why it is used\nCreate and manipulate NumPy arrays\nPerform element-wise operations and mathematical functions on arrays\nCompare NumPy arrays with Python lists in terms of performance and functionality\nUse basic aggregation and array manipulation functions in NumPy"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#what-is-numpy",
    "href": "slides/07_intro_numpy_slides.html#what-is-numpy",
    "title": "The numpy module",
    "section": "What is numpy?",
    "text": "What is numpy?\nNumPy is a Python library that makes working with numbers and large collections of data fast and easy.\n\nComplete description at https://numpy.orgIt provides special array objects and tools for doing math efficiently, which is useful for data analysis and scientific computing.\n\nIt is imported in your session using the following command\nimport numpy\n\n\nWe will follow a common practice and use a shorthand with the as syntax\nimport numpy as np\n\n\nSo np will always mean numpy for us."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#arrays-vs-lists",
    "href": "slides/07_intro_numpy_slides.html#arrays-vs-lists",
    "title": "The numpy module",
    "section": "Arrays vs lists",
    "text": "Arrays vs lists\n\n\nPython Lists\n\nOrdered, Mutable\n\nMixed data types\nExplicit operations needed\nSlower performance\n\n\nNumPy Arrays\n\nOrdered, Mutable\nOne data type per array\nElement-wise operations\nFast & memory efficient\n\n\n\n\n\n\nlist_ex = [1, 2, 3, 4]\nprint(list_ex)\n\n[1, 2, 3, 4]\n\n\n\n\nimport numpy as np\n#notice that we explicitly call the np.array()\narr_ex = np.array([1, 2, 3, 4]) \nprint(arr_ex)\n\n[1 2 3 4]\n\n\n\nWe are going to see these differences in detail."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#arrays-from-lists",
    "href": "slides/07_intro_numpy_slides.html#arrays-from-lists",
    "title": "The numpy module",
    "section": "Arrays from lists",
    "text": "Arrays from lists\nA purely numerical list can readily be converted to an array.\n\nimport numpy as np\n# Create array from list\nlist1 = [1.,1.,2.,3.,5.,8.]\narr1 = np.array(list1)\nprint(arr1)\n\n[1. 1. 2. 3. 5. 8.]\n\n\n\nThe type of the elements yields the data type of the array\n\nprint(arr1.dtype)\n\nfloat64\n\n\n\nTry and change the list1 object to contain only integers and see the change!"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#array-properties",
    "href": "slides/07_intro_numpy_slides.html#array-properties",
    "title": "The numpy module",
    "section": "Array properties",
    "text": "Array properties\nArrays possess plenty of properties.\nThese are accessed with the . notation1.\n\nprint(f\"Data type: {arr1.dtype}\")\nprint(f\"Shape: {arr1.shape}\")\nprint(f\"Shape: {arr1.size}\")\n\nData type: float64\nShape: (6,)\nShape: 6\n\n\nFor now, we consider only 1d arrays, i.e. sequences. Their length is is their size and corresponds to the first element of the property shape.\nuse . and then TAB to see all of the properties"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#accessing-array-elements",
    "href": "slides/07_intro_numpy_slides.html#accessing-array-elements",
    "title": "The numpy module",
    "section": "Accessing array elements",
    "text": "Accessing array elements\nSimilarly to lists, we access an element in an array via zero-based indexing\n\nprint(arr1[0])    # First element\nprint(arr1[-1])   # Last element\n\n1.0\n8.0\n\n\nAgain, similarly to lists, we can access regions of the array via slicing\n\nprint(arr1[3:6])  # Elements from index 3 to 6\n\n[3. 5. 8.]"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#element-wise-operations",
    "href": "slides/07_intro_numpy_slides.html#element-wise-operations",
    "title": "The numpy module",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe main motivation to use arrays is that lists are cumbersome when performing maths.\nSuppose we have a list and want to double all of its elements:\n\nlist1 = [1,2,3,4]\n\nWe need to loop over all of them and create a new list\n\nlist2 = []\nfor item in list1:\n    list2.append(2*item)\nprint(list2)\n\n[2, 4, 6, 8]\n\n\nIn fact, we can do this in a slightly more compact way using list comprehension\n\nlist2 = [item*2 for item in list1]\n\nStill, an explicit loop is needed. Loops in Python are slow."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#element-wise-operations-1",
    "href": "slides/07_intro_numpy_slides.html#element-wise-operations-1",
    "title": "The numpy module",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe numpy syntax avoids the explicit Python loop.\n\narr1 = np.array(list1)\narr2 = 2*arr1\nprint(arr2)\n\n[2 4 6 8]\n\n\nThis is not just a cosmetic change: under the hood numpy uses an efficient architecture that performs operations in compiled code, making it much faster than Python loops."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#performance-advantage",
    "href": "slides/07_intro_numpy_slides.html#performance-advantage",
    "title": "The numpy module",
    "section": "Performance advantage",
    "text": "Performance advantage\nThis performance difference can be tracked explicitly.\nWe create a large list and a large array with identical content\n\n# Create a large list and array\nlarge_list = list(range(1_000_000))\nlarge_array = np.array(large_list)\n\nAnd then track the time for the two operations\n\nimport time\n#  Track the time taken for the list multiplication\nstart = time.time()\nlist_result = [x * 2 for x in large_list]\nend = time.time()\nprint(f\"List comprehension time: {end - start:.5f} seconds\")\n\n# Time array multiplication\nstart = time.time()\narray_result = large_array * 2\nend = time.time()\nprint(f\"NumPy array time: {end - start:.5f} seconds\")\n\nList comprehension time: 0.01995 seconds\nNumPy array time: 0.00118 seconds"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#general-mathematical-functions",
    "href": "slides/07_intro_numpy_slides.html#general-mathematical-functions",
    "title": "The numpy module",
    "section": "General mathematical functions",
    "text": "General mathematical functions\nThe multiplication we performed earlier is done element-wise: every element is update according to teh same rule.\nWe can apply plenty of element-wise operations to the arrays.\nMany of these are available as numpy functions directly accessed from the np. module\n\n# Element-wise functions\nprint(f\"Square root: {np.sqrt(arr1)}\")\nprint(f\"Mean: {np.mean(arr1)}\")\nprint(f\"Cosine: {np.cos(arr1)}\")\n\nSquare root: [1.         1.41421356 1.73205081 2.        ]\nMean: 2.5\nCosine: [ 0.54030231 -0.41614684 -0.9899925  -0.65364362]\n\n\n\nThe operations do not modify the original array, but produce new copies\n\narr2 = arr1*3/2 + 5\nprint(f\"Original: {arr1}\")\nprint(f\"Modified: {arr2}\")\n\nOriginal: [1 2 3 4]\nModified: [ 6.5  8.   9.5 11. ]"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#sums",
    "href": "slides/07_intro_numpy_slides.html#sums",
    "title": "The numpy module",
    "section": "Sums",
    "text": "Sums\nOther convenent numpy functions allow you to accumulate values without loops.\nAssume we have an array \\(x\\)\n\nx = np.array([1,2,3,4,5,6,7,8])\n\nSums\n\\[\nS = \\sum_{i=1}^{n} x_i\n\\]\nIn NumPy, this is translated as:\n\nS = np.sum(x)\nprint(S)\n\n36"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#sums-1",
    "href": "slides/07_intro_numpy_slides.html#sums-1",
    "title": "The numpy module",
    "section": "Sums",
    "text": "Sums\nCumulative sums\nA cumulative sum is a sequence where each element is the sum of all previous elements up to that position. \\[\ny_i = \\sum_{j=1}^{i} x_j\n\\]\nIn NumPy, this is translated as:\n\n y = np.cumsum(x)\n print(y)\n\n[ 1  3  6 10 15 21 28 36]"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#example-molecular-masses",
    "href": "slides/07_intro_numpy_slides.html#example-molecular-masses",
    "title": "The numpy module",
    "section": "Example: molecular masses",
    "text": "Example: molecular masses\nLet’s consider the formula for the molecular mass of a compound:\n\\[\nM = \\sum_{i=1}^{n} a_i m_i\n\\]\nwhere\n\n\\(a_i\\) is the number of atoms of element \\(i\\)\n\\(m_i\\) is the atomic mass of element \\(i\\)\n\n\nWith numpy, you can compute this as:\n\na = np.array([2, 1, 4])      # Number of atoms for each element\nm = np.array([12.01, 1.01, 16.00])  # Atomic masses (e.g., C, H, O)\nM = np.sum(a * m)\nprint(f\"Molecular mass: {M}\")\n\nMolecular mass: 89.03"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#operations-between-arrays",
    "href": "slides/07_intro_numpy_slides.html#operations-between-arrays",
    "title": "The numpy module",
    "section": "Operations between arrays",
    "text": "Operations between arrays\nYou can perform arithmetic operations directly between arrays of the same shape. Operations like addition, subtraction, multiplication, and division are applied element-wise.\nFor example:\nElement-wise operations:\n\nadded = arr1 + arr2\nmultiplied = arr1 * arr2\nprint(f\"Added: {added}\")\nprint(f\"Multiplied: {multiplied}\")\n\nAdded: [ 7.5 10.  12.5 15. ]\nMultiplied: [ 6.5 16.  28.5 44. ]\n\n\n\nNote: Arrays must have compatible shapes!\n\narr3 = np.array([1, 2, 3])\narr4 = np.array([4, 5])\nresult = arr3 + arr4\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[21], line 3\n      1 arr3 = np.array([1, 2, 3])\n      2 arr4 = np.array([4, 5])\n----&gt; 3 result = arr3 + arr4\n\nValueError: operands could not be broadcast together with shapes (3,) (2,)"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#combining-arrays",
    "href": "slides/07_intro_numpy_slides.html#combining-arrays",
    "title": "The numpy module",
    "section": "Combining arrays",
    "text": "Combining arrays\nWith lists, the + operator concatenated different lists. Since for arrays the sign + corresponds to true mathematical addition, a dedicated concatenation function exists:\n\ncombined = np.concatenate([arr1, arr2])\nprint(f\"Unique elements: {combined}\")\n\nUnique elements: [ 1.   2.   3.   4.   6.5  8.   9.5 11. ]\n\n\nMany other variations of concatenation exist. Consult the documentation."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#key-takeaways",
    "href": "slides/07_intro_numpy_slides.html#key-takeaways",
    "title": "The numpy module",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nNumPy arrays are optimized for numerical operations\nElement-wise operations work implicitly\nPerformance benefits for large datasets\nMathematical functions apply to entire arrays\nShape compatibility required for operations\nChoose the right tool for your task"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#numpy-arrays-beyond-1d",
    "href": "slides/10_multidimensional_arrays_slides.html#numpy-arrays-beyond-1d",
    "title": "Multi-dimensional Arrays",
    "section": "NumPy Arrays Beyond 1D",
    "text": "NumPy Arrays Beyond 1D\nMulti-dimensional arrays enable representation of: - 2D: Grid/Matrix (rows × columns) - 3D: Cuboid/Tensor (depth × rows × columns) - nD: Higher dimensions\n\nimport numpy as np\nfrom numpy import random\nrng = random.default_rng(seed=24)\n\n# 2D array (3×3 matrix)\narray_2d = rng.random((3, 3))\nprint(f\"Shape: {array_2d.shape}\")\nprint(array_2d)\n\nShape: (3, 3)\n[[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]\n [0.87411653 0.08643046 0.74247527]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#indexing-multi-dimensional-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#indexing-multi-dimensional-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Indexing Multi-dimensional Arrays",
    "text": "Indexing Multi-dimensional Arrays\nRow-major order: [row, column] (like [y, x])\n\n# Access single element\nprint(\"Element at [1,2]:\", array_2d[1, 2])\n\n# Access entire row\nprint(\"First row:\", array_2d[0, :])\n\n# Access entire column  \nprint(\"First column:\", array_2d[:, 0])\n\nElement at [1,2]: 0.5696873105084019\nFirst row: [0.33026884 0.40517732 0.57473782]\nFirst column: [0.33026884 0.50639977 0.87411653]\n\n\nSlicing works with multiple dimensions:\n\nprint(\"First 2 rows:\\n\", array_2d[:2])\n\nFirst 2 rows:\n [[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#array-properties",
    "href": "slides/10_multidimensional_arrays_slides.html#array-properties",
    "title": "Multi-dimensional Arrays",
    "section": "Array Properties",
    "text": "Array Properties\n\n# Creating arrays with different shapes\nzeros_2d = np.zeros((2, 3))  # 2 rows, 3 columns\nrandom_3d = rng.integers(0, 3, size=(2, 3, 4))  # 2×3×4 tensor\n\nprint(\"2D shape:\", zeros_2d.shape)\nprint(\"3D shape:\", random_3d.shape)\nprint(\"3D rank/dimensions:\", random_3d.ndim)\n\n2D shape: (2, 3)\n3D shape: (2, 3, 4)\n3D rank/dimensions: 3\n\n\nTerminology: - Rank/ndim: Number of dimensions - Matrix: Rank 2 array - Tensor: Rank 3+ array"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#operations-along-axes",
    "href": "slides/10_multidimensional_arrays_slides.html#operations-along-axes",
    "title": "Multi-dimensional Arrays",
    "section": "Operations Along Axes",
    "text": "Operations Along Axes\nAxis-specific operations:\n\nmatrix = rng.integers(0, 5, size=(3, 4))\nprint(\"Original matrix:\\n\", matrix)\n\nprint(\"Sum along axis 0 (columns):\", matrix.sum(axis=0))\nprint(\"Sum along axis 1 (rows):\", matrix.sum(axis=1))\nprint(\"Mean along axis 0:\", np.mean(matrix, axis=0))\n\nOriginal matrix:\n [[0 2 4 3]\n [4 1 4 0]\n [2 3 4 3]]\nSum along axis 0 (columns): [ 6  6 12  6]\nSum along axis 1 (rows): [ 9  9 12]\nMean along axis 0: [2. 2. 4. 2.]\n\n\nAxis 0: Operations across rows (result has column shape)\nAxis 1: Operations across columns (result has row shape)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#reshaping-and-flattening",
    "href": "slides/10_multidimensional_arrays_slides.html#reshaping-and-flattening",
    "title": "Multi-dimensional Arrays",
    "section": "Reshaping and Flattening",
    "text": "Reshaping and Flattening\nReshape without changing data:\n\narr_1d = np.arange(12)\narr_2d = arr_1d.reshape((3, 4))\narr_3d = arr_1d.reshape((2, 2, 3))\n\nprint(\"1D:\", arr_1d)\nprint(\"2D (3×4):\\n\", arr_2d)\nprint(\"3D shape:\", arr_3d.shape)\n\n1D: [ 0  1  2  3  4  5  6  7  8  9 10 11]\n2D (3×4):\n [[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n3D shape: (2, 2, 3)\n\n\nUsing -1 for automatic dimension:\n\n# -1 means \"figure out this dimension\"\nauto_reshape = arr_1d.reshape(-1, 4)  # ? rows, 4 columns\nprint(\"Auto-reshaped:\\n\", auto_reshape)\n\nAuto-reshaped:\n [[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#flattening-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#flattening-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Flattening Arrays",
    "text": "Flattening Arrays\nravel() - returns view (shares data):\n\nmatrix = rng.integers(0, 10, (2, 3))\nprint(\"Original:\\n\", matrix)\n\nview = matrix.ravel()\nview[0] = 99  # Changes original!\nprint(\"After modifying view:\\n\", matrix)\n\nOriginal:\n [[7 0 4]\n [4 7 4]]\nAfter modifying view:\n [[99  0  4]\n [ 4  7  4]]\n\n\nflatten() - returns copy:\n\nmatrix = rng.integers(0, 10, (2, 3))\ncopy = matrix.flatten()\ncopy[0] = 99  # Original unchanged\nprint(\"Original unchanged:\\n\", matrix)\n\nOriginal unchanged:\n [[6 9 5]\n [5 5 3]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#broadcasting",
    "href": "slides/10_multidimensional_arrays_slides.html#broadcasting",
    "title": "Multi-dimensional Arrays",
    "section": "Broadcasting",
    "text": "Broadcasting\nCombine arrays of different shapes automatically:\n\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6]])\nvector = np.array([10, 20, 30])\n\n# Vector is broadcast to each row\nresult = matrix + vector\nprint(\"Matrix + Vector:\\n\", result)\n\nMatrix + Vector:\n [[11 22 33]\n [14 25 36]]\n\n\nCreate grids with broadcasting:\n\nrow_vec = np.arange(3).reshape(1, -1)    # Shape: (1, 3)\ncol_vec = np.arange(3).reshape(-1, 1)    # Shape: (3, 1)\ngrid = row_vec + col_vec                 # Shape: (3, 3)\nprint(\"Broadcast grid:\\n\", grid)\n\nBroadcast grid:\n [[0 1 2]\n [1 2 3]\n [2 3 4]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#linear-algebra-with-numpy",
    "href": "slides/10_multidimensional_arrays_slides.html#linear-algebra-with-numpy",
    "title": "Multi-dimensional Arrays",
    "section": "Linear Algebra with NumPy",
    "text": "Linear Algebra with NumPy\nMatrix operations for solving systems: \\[A\\mathbf{x} = \\mathbf{b}\\]\n\n# System: 2x + 3y + z = 5, 4x - y = 1, 2y + z = 3\nA = np.array([[2, 3, 1], \n              [4, -1, 0], \n              [0, 2, 1]])\nb = np.array([[5], [1], [3]])\n\n# Solve the system\nx = np.linalg.solve(A, b)\nprint(\"Solution:\", x.flatten())\n\n# Verify: A @ x should equal b\nprint(\"Verification:\\n\", A @ x)\n\nSolution: [0.5 1.  1. ]\nVerification:\n [[5.]\n [1.]\n [3.]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#linear-algebra-operations",
    "href": "slides/10_multidimensional_arrays_slides.html#linear-algebra-operations",
    "title": "Multi-dimensional Arrays",
    "section": "Linear Algebra Operations",
    "text": "Linear Algebra Operations\n\n# Matrix multiplication with @\nresult = A @ x\n\n# Transpose with .T\nprint(\"b transpose:\", b.T)\n\n# Dot product\ndot_product = np.dot(b.T, b)\nprint(\"Dot product:\", dot_product)\n\n# Matrix inverse\nA_inv = np.linalg.inv(A)\nx_alt = A_inv @ b  # Alternative solution method\n\nb transpose: [[5 1 3]]\nDot product: [[35]]\n\n\nNumPy.linalg provides: inverse, solve, eigenvalues, SVD, etc."
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#arrays-as-images",
    "href": "slides/10_multidimensional_arrays_slides.html#arrays-as-images",
    "title": "Multi-dimensional Arrays",
    "section": "Arrays as Images",
    "text": "Arrays as Images\nVisualize 2D arrays as images:\n\nimport matplotlib.pyplot as plt\n\n# Simple matrix visualization\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\n\nax1.matshow(matrix)\nax1.set_title('matshow')\n\nax2.imshow(matrix, origin='lower')\nax2.set_title('imshow (origin=lower)')\n\nText(0.5, 1.0, 'imshow (origin=lower)')"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#working-with-real-images",
    "href": "slides/10_multidimensional_arrays_slides.html#working-with-real-images",
    "title": "Multi-dimensional Arrays",
    "section": "Working with Real Images",
    "text": "Working with Real Images\n\nfrom skimage import data\n\n# Grayscale image\ngray_image = data.camera()\nprint(\"Image shape:\", gray_image.shape)\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(gray_image, cmap='gray')\nax.set_title('Grayscale Image')\n\nImage shape: (512, 512)\n\n\nText(0.5, 1.0, 'Grayscale Image')\n\n\n\nImages are arrays: Each pixel is a number (intensity)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#color-images-3d-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#color-images-3d-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Color Images (3D Arrays)",
    "text": "Color Images (3D Arrays)\n\n# Color image has 3 channels: RGB\ncolor_image = data.chelsea()\nprint(\"Color image shape:\", color_image.shape)\n\nfig, axes = plt.subplots(1, 4, figsize=(15, 4))\n\naxes[0].imshow(color_image)\naxes[0].set_title('Full Color')\n\n# Individual color channels\nchannels = ['Reds', 'Greens', 'Blues']\ntitles = ['Red Channel', 'Green Channel', 'Blue Channel']\n\nfor i, (cmap, title) in enumerate(zip(channels, titles)):\n    axes[i+1].imshow(color_image[:, :, i], cmap=cmap)\n    axes[i+1].set_title(title)\n\nColor image shape: (300, 451, 3)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#boolean-operations-on-images",
    "href": "slides/10_multidimensional_arrays_slides.html#boolean-operations-on-images",
    "title": "Multi-dimensional Arrays",
    "section": "Boolean Operations on Images",
    "text": "Boolean Operations on Images\n\n# Extract green channel\ngreen = color_image[:, :, 1]\n\n# Create binary mask\nthreshold_mask = green &gt; 120\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n\nax1.imshow(green, cmap='Greens')\nax1.set_title('Green Channel')\n\nax2.imshow(threshold_mask, cmap='gray')\nax2.set_title('Thresholded (&gt;120)')\n\nText(0.5, 1.0, 'Thresholded (&gt;120)')\n\n\n\nLogical operations: & (AND), | (OR), ~ (NOT)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#key-takeaways",
    "href": "slides/10_multidimensional_arrays_slides.html#key-takeaways",
    "title": "Multi-dimensional Arrays",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nMulti-dimensional arrays represent grids, images, tensors\nIndexing: [row, col] for 2D arrays\nAxis operations reduce along specific dimensions\nReshaping changes shape without changing data\nBroadcasting enables operations on different shapes\nLinear algebra operations available in np.linalg\nImages are just arrays of pixel values\nBoolean indexing works on multi-dimensional arrays"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#array-indexing-slicing",
    "href": "slides/08_working_numpy_slides.html#array-indexing-slicing",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Array Indexing & Slicing",
    "text": "Array Indexing & Slicing\n\nimport numpy as np\narr = np.array([10, 20, 30, 40, 50])\n\n# Integer indexing\nprint(\"Element at index 1:\", arr[1])\n\n# Basic slicing\nprint(\"Slice [1:4]:\", arr[1:4])\n\nElement at index 1: 20\nSlice [1:4]: [20 30 40]\n\n\nAdvanced slicing:\n\nprint(\"Every other element:\", arr[::2])\nprint(\"Last three elements:\", arr[-3:])\nprint(\"Reversed array:\", arr[::-1])\n\nEvery other element: [10 30 50]\nLast three elements: [30 40 50]\nReversed array: [50 40 30 20 10]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#views-vs-copies",
    "href": "slides/08_working_numpy_slides.html#views-vs-copies",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Views vs Copies",
    "text": "Views vs Copies\nSlicing creates views (shared data):\n\nslice_view = arr[2:5]\nslice_view[0] = 99\nprint(\"Original after view modification:\", arr)\n\nOriginal after view modification: [10 20 99 40 50]\n\n\nCreating independent copies:\n\narr = np.array([10, 20, 30, 40, 50])  # Reset\narr_copy = arr[2:5].copy()\narr_copy[0] = 100\nprint(\"Copy:\", arr_copy)\nprint(\"Original unchanged:\", arr)\n\nCopy: [100  40  50]\nOriginal unchanged: [10 20 30 40 50]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#boolean-indexing",
    "href": "slides/08_working_numpy_slides.html#boolean-indexing",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Boolean Indexing",
    "text": "Boolean Indexing\nFilter data with conditions:\n\narr = np.array([1, 2, 3, 4, 5, 6])\nthreshold = 3\n\nbool_mask = arr &gt; threshold\nprint(\"Boolean mask:\", bool_mask)\nprint(\"Filtered values:\", arr[bool_mask])\n\nBoolean mask: [False False False  True  True  True]\nFiltered values: [4 5 6]\n\n\nUsing np.where:\n\n# Get indices where condition is True\nindices = np.where(arr &gt; threshold)[0]\nprint(\"Indices:\", indices)\n\n# Conditional selection\nresult = np.where(arr &gt; 3, arr, 0)\nprint(\"Conditional result:\", result)\n\nIndices: [3 4 5]\nConditional result: [0 0 0 4 5 6]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#generating-sequences",
    "href": "slides/08_working_numpy_slides.html#generating-sequences",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Generating Sequences",
    "text": "Generating Sequences\nnp.arange - step-based:\n\nprint(\"Integers:\", np.arange(0, 10, 2))\nprint(\"Floats:\", np.arange(0.0, 1.0, 0.2))\n\nIntegers: [0 2 4 6 8]\nFloats: [0.  0.2 0.4 0.6 0.8]\n\n\nnp.linspace - count-based:\n\nprint(\"5 points from 0 to 1:\", np.linspace(0, 1, 5))\n\n5 points from 0 to 1: [0.   0.25 0.5  0.75 1.  ]\n\n\n\narange: Use when you know the step size\nlinspace: Use when you know the number of points"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#filled-arrays",
    "href": "slides/08_working_numpy_slides.html#filled-arrays",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Filled Arrays",
    "text": "Filled Arrays\n\n# Create arrays with specific values\nzeros_arr = np.zeros(5)\nones_arr = np.ones(4)\nfull_arr = np.full(3, 7)\n\nprint(\"Zeros:\", zeros_arr)\nprint(\"Ones:\", ones_arr)\nprint(\"Full:\", full_arr)\n\nZeros: [0. 0. 0. 0. 0.]\nOnes: [1. 1. 1. 1.]\nFull: [7 7 7]\n\n\nSame shape as existing array:\n\ntemplate = np.array([1, 2, 3])\nprint(\"Zeros like:\", np.zeros_like(template))\nprint(\"Ones like:\", np.ones_like(template))\nprint(\"Full like:\", np.full_like(template, 9))\n\nZeros like: [0 0 0]\nOnes like: [1 1 1]\nFull like: [9 9 9]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#random-number-generation",
    "href": "slides/08_working_numpy_slides.html#random-number-generation",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Random Number Generation",
    "text": "Random Number Generation\nInitialize generator (for reproducibility):\n\nrng = np.random.default_rng(seed=123)\n\nDifferent distributions:\n\n# Random integers\nprint(\"Random integers:\", rng.integers(0, 100, size=5))\n\n# Uniform floats [0, 1)\nprint(\"Uniform [0,1):\", rng.random(5))\n\n# Normal distribution\nnormal_samples = rng.normal(loc=0, scale=1, size=5)\nprint(\"Normal samples:\", normal_samples)\n\nRandom integers: [ 1 68 59  5 90]\nUniform [0,1): [0.18437181 0.1759059  0.81209451 0.923345   0.2765744 ]\nNormal samples: [-0.31659545 -0.32238912  0.09716732 -1.52593041  1.1921661 ]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#pseudo-random-numbers",
    "href": "slides/08_working_numpy_slides.html#pseudo-random-numbers",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Pseudo-Random Numbers",
    "text": "Pseudo-Random Numbers\nComputers are deterministic - they use algorithms to generate “pseudo-random” sequences\nLinear Congruential Generator example: \\[x_{n+1} = (a \\times x_n + c) \\bmod m\\]\nKey concept: Seeds enable reproducibility\n\n# Same seed = same sequence\nrng1 = np.random.default_rng(seed=42)\nrng2 = np.random.default_rng(seed=42)\n\nprint(\"RNG1:\", rng1.integers(0, 10, size=3))\nprint(\"RNG2:\", rng2.integers(0, 10, size=3))  # Same output!\n\nRNG1: [0 7 6]\nRNG2: [0 7 6]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#performance-tips",
    "href": "slides/08_working_numpy_slides.html#performance-tips",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Performance Tips",
    "text": "Performance Tips\nPreallocate for efficiency:\n\n# Less efficient: generate one at a time\n# for _ in range(1000):\n#     val = rng.integers(0, 100)\n\n# More efficient: preallocate\nprealloc = rng.integers(0, 100, size=1000)\n# Then use values from prealloc array\n\nMemory vs Speed tradeoff: - Small tasks: 100-1,000 elements - Medium tasks: 10,000-100,000 elements\n- Large tasks: 1,000,000+ elements"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#key-takeaways",
    "href": "slides/08_working_numpy_slides.html#key-takeaways",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nViews share data, copies are independent\nBoolean indexing enables powerful data filtering\narange vs linspace serve different use cases\nRandom generators need seeds for reproducibility\nPreallocating arrays improves performance\nChoose array generation method based on your needs"
  },
  {
    "objectID": "10/exercises_part2_solutions.html",
    "href": "10/exercises_part2_solutions.html",
    "title": "Answers",
    "section": "",
    "text": "One application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\nfrom PIL import Image\nimport numpy as np\n\nim_filename = \"ngc253_small.png\"\nim = np.array(Image.open(im_filename))\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\nprint(im.shape)\n\n(907, 1000, 3)\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im, origin=\"lower\")\n\n\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed.\n\n\n\nThe inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\ndef inside_ellipse(x, y, centre=(0,0), a=2, b=1, alpha=0):\n    \n    x0,y0 = centre\n    \n    # Convert alpha in degrees to radians for use with cos/sin function\n    alpha_rad = np.radians(alpha)\n    \n    term1 = ((x-x0)*np.cos(alpha_rad) + (y-y0)*np.sin(alpha_rad))**2 / a**2\n    term2 = ((x-x0)*np.sin(alpha_rad) - (y-y0)*np.cos(alpha_rad))**2 / b**2\n    \n    total = term1 + term2\n\n    return total&lt;1\n\n\n\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\nx1 = 0\ny1 = 0\nposition_is_in_ellipse1 = inside_ellipse(x1, y1, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x1}, {y1}) inside the ellipse? {position_is_in_ellipse1}\")\n\nx2 = 0\ny2 = 4\nposition_is_in_ellipse2 = inside_ellipse(x2, y2, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x2}, {y2}) inside the ellipse? {position_is_in_ellipse2}\")\n\nIs position (0, 0) inside the ellipse? True\nIs position (0, 4) inside the ellipse? False\n\n\n\n\n\n\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel).\n\n# ADD CODE HERE\nrows, cols = np.indices((im.shape[0], im.shape[1]))\ncentre = (500,470)\na = 365\nb = 70\nalpha = 33\nmask = inside_ellipse (cols, rows, centre, a, b , alpha)\n\nim_masked = im.copy()\nim_masked[np.logical_not(mask),:] = 0 # you can use ~ instead of the logical_not function\n\n\n# UNCOMMENT THIS CODE TO PLOT YOUR MASKED IMAGE\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im_masked.astype(int),origin=\"lower\")\n\n\n\n\n\n\n\n\n\n\n\n\nNow that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\n\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html\n\n# ADD CODE HERE\n\n# Select the third channel (B) and calculate the sum\nim_B_channel = im_masked[:, :, 2]\nsummed_B = np.sum(im_B_channel)\n\n# Apply the scale factor to get approximated flux value\nscale_factor = 2.8e-7\nflux_scaled_B = summed_B*scale_factor\n\n# Calculate the magnitude using the np.log10 function\nmagnitude_B = -2.5*np.log10(flux_scaled_B) + 8.90\nprint(magnitude_B)\n\n8.070961081466722",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 2"
    ]
  },
  {
    "objectID": "10/exercises_part2_solutions.html#masking-a-galaxy",
    "href": "10/exercises_part2_solutions.html#masking-a-galaxy",
    "title": "Answers",
    "section": "",
    "text": "One application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\nfrom PIL import Image\nimport numpy as np\n\nim_filename = \"ngc253_small.png\"\nim = np.array(Image.open(im_filename))\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\nprint(im.shape)\n\n(907, 1000, 3)\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im, origin=\"lower\")\n\n\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 2"
    ]
  },
  {
    "objectID": "10/exercises_part2_solutions.html#creating-an-elliptical-mask",
    "href": "10/exercises_part2_solutions.html#creating-an-elliptical-mask",
    "title": "Answers",
    "section": "",
    "text": "The inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\ndef inside_ellipse(x, y, centre=(0,0), a=2, b=1, alpha=0):\n    \n    x0,y0 = centre\n    \n    # Convert alpha in degrees to radians for use with cos/sin function\n    alpha_rad = np.radians(alpha)\n    \n    term1 = ((x-x0)*np.cos(alpha_rad) + (y-y0)*np.sin(alpha_rad))**2 / a**2\n    term2 = ((x-x0)*np.sin(alpha_rad) - (y-y0)*np.cos(alpha_rad))**2 / b**2\n    \n    total = term1 + term2\n\n    return total&lt;1\n\n\n\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\nx1 = 0\ny1 = 0\nposition_is_in_ellipse1 = inside_ellipse(x1, y1, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x1}, {y1}) inside the ellipse? {position_is_in_ellipse1}\")\n\nx2 = 0\ny2 = 4\nposition_is_in_ellipse2 = inside_ellipse(x2, y2, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x2}, {y2}) inside the ellipse? {position_is_in_ellipse2}\")\n\nIs position (0, 0) inside the ellipse? True\nIs position (0, 4) inside the ellipse? False\n\n\n\n\n\n\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel).\n\n# ADD CODE HERE\nrows, cols = np.indices((im.shape[0], im.shape[1]))\ncentre = (500,470)\na = 365\nb = 70\nalpha = 33\nmask = inside_ellipse (cols, rows, centre, a, b , alpha)\n\nim_masked = im.copy()\nim_masked[np.logical_not(mask),:] = 0 # you can use ~ instead of the logical_not function\n\n\n# UNCOMMENT THIS CODE TO PLOT YOUR MASKED IMAGE\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im_masked.astype(int),origin=\"lower\")",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 2"
    ]
  },
  {
    "objectID": "10/exercises_part2_solutions.html#calculating-the-magnitude",
    "href": "10/exercises_part2_solutions.html#calculating-the-magnitude",
    "title": "Answers",
    "section": "",
    "text": "Now that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\n\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html\n\n# ADD CODE HERE\n\n# Select the third channel (B) and calculate the sum\nim_B_channel = im_masked[:, :, 2]\nsummed_B = np.sum(im_B_channel)\n\n# Apply the scale factor to get approximated flux value\nscale_factor = 2.8e-7\nflux_scaled_B = summed_B*scale_factor\n\n# Calculate the magnitude using the np.log10 function\nmagnitude_B = -2.5*np.log10(flux_scaled_B) + 8.90\nprint(magnitude_B)\n\n8.070961081466722",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 2"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html",
    "href": "10/lecture_multidimensionalArrays.html",
    "title": "Multi-dimensional arrays",
    "section": "",
    "text": "A numpy.ndarray is the more complete term for a numpy array object. Up until this point we have mainly been dealing with and using one dimensional arrays. Numpy arrays (unlike lists) have the concept of shape whicih means they can be multi-dimensional. This means they can represent a grid (2D), a cuboid (3D) and so forth.\nThe code below generates a numpy.array object containing random numbers. This is a 2D array with a 3 x 3 shape:\nfrom numpy import random\n\nrng = random.default_rng(seed=24)\nimport numpy as np\n\nshape = (3,3)\narray1 = rng.random(shape)\nprint(array1.shape)\nprint(array1)\n\n(3, 3)\n[[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]\n [0.87411653 0.08643046 0.74247527]]\nWe can select one element from this array using the following syntax. We still use square brackets and pass an index value but now we can pass values for each dimension seperated by a comma (,). This index is selecting the third column within the second row:\nprint(array1[1, 2])\n\n0.5696873105084019\nUsing slicing (Start:Stop) syntax you can select an entire dimension at once by omitting both the Start and Stop values and just using :. You can see how this works if you try the slice with just the Start or just the Stop e.g.\nprint(array1[:2])\nprint(array1[2:])\n\n[[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]]\n[[0.87411653 0.08643046 0.74247527]]\nNot including a Start index includes values from the beginning of the array/list etc. up to (but not including) the Stop.\nNot including a Stop index reads from the Start to the end of the array/list etc.\nSo just using : with no Start or Stop selects all elements for that dimension.\nThis following syntax returns first row (first row, every column):\nprint(array1[0,:])\n\n[0.33026884 0.40517732 0.57473782]\nAnd this would return the first column (every row, first column):\nprint(array1[:,0])\n\n[0.33026884 0.50639977 0.87411653]\nnumpy array objects store data in row-major order. Essentially this means for a 2D index this would be the equivalent of [y, x] rather than [x, y].",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#basic-properties-of-multi-dimensional-arrays",
    "href": "10/lecture_multidimensionalArrays.html#basic-properties-of-multi-dimensional-arrays",
    "title": "Multi-dimensional arrays",
    "section": "Basic properties of multi-dimensional arrays",
    "text": "Basic properties of multi-dimensional arrays\n\nShape\nThe shape of a multi-dimensional array is a tuple that describes the size of each dimension. For example, a 2D array with 3 rows and 4 columns has a shape of (3, 4). You can access the shape of an array using the .shape attribute.\nWe can use many of the array initialisation functions we haver seen for 1d arrays also to create multi-dimensional arrays. For example, we can use np.zeros to create a 2D array of zeros, or np.ones to create a 2D array of ones. We can also use np.random.rand to create a 2D array of random numbers.\n\narray_of_zeros = np.zeros(shape=(2, 3)) # 2 rows, 3 columns\n\n\nnp.ones_like(array_of_zeros)\n\narray([[1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\n\nAxis and Rank\nA multi-dimensional array has multiple dimensions, each of which can be thought of as an axis. The number of dimensions is called the rank of the array. For example, a 2D array has a rank of 2, while a 3D array has a rank of 3. It is accessible via the .ndim attribute.\nWe typically call a rank 2 array a matrix. A rank 3 array (or higher) is often called a tensor.\n\nrng = random.default_rng(seed=24)\nrandom_matrix = rng.uniform(-1,1,size=(2,5)) # random floats between -1 and 1, 2 rows, 5 columns\nrandom_matrix\n\narray([[-0.33946233, -0.18964537,  0.14947564,  0.01279953,  0.12842501],\n       [ 0.13937462,  0.74823306, -0.82713908,  0.48495054,  0.64073453]])\n\n\n\nrandom_matrix.ndim # two dimensions, rank 2, a matrix\n\n2\n\n\n\nrandom_tensor = rng.integers(0,3,size=(2,3,4)) # random integes in [0,3), 2x3x4 tensor\nrandom_tensor\n\narray([[[0, 2, 1, 1],\n        [2, 2, 0, 0],\n        [1, 2, 0, 1]],\n\n       [[2, 0, 1, 0],\n        [0, 1, 1, 0],\n        [0, 1, 0, 1]]])\n\n\n\nrandom_tensor.ndim\n\n3\n\n\nWe can perform operations along specific axes of a multi-dimensional array. For example, we can sum all the elements along a specific axis using the np.sum function with the axis parameter.\n\nsmall_matrix = rng.integers(0,2,size=(3,2)) \nsmall_matrix\n\narray([[1, 1],\n       [1, 0],\n       [1, 0]])\n\n\n\nsmall_matrix.sum(axis=0) # sum along the first axis (rows)\n\narray([3, 1])\n\n\n\nsmall_matrix.sum(axis=1) # sum along the second axis (columns), can you explain the resulting shape?\n\narray([2, 1, 1])\n\n\nOne can do the same also with useful statistical descriptors such as np.mean, np.std, etc.\n\nnp.mean(small_matrix, axis=0) # mean along the first axis (rows)\n\narray([1.        , 0.33333333])\n\n\n\n\nSlicing\nSlicing works similarly to 1D arrays, but you can slice along multiple axes. For example, you can slice a 2D array to get a submatrix or a specific row or column.\n\nsmall_matrix[:, 0] # all rows, first column\n\narray([1, 1, 1])\n\n\n\nsmall_matrix[:2,:] # first two rows, all columns\n\narray([[1, 1],\n       [1, 0]])\n\n\n\nsmall_matrix[::-1,:1]\n\narray([[1],\n       [1],\n       [1]])\n\n\n\n\nReshaping and flattening\nThe last example show an inetresting case: we extracted a single column from the matrix, but it is still a 2D array with shape (3, 1).\n\nselection = small_matrix[::-1,:1]\n\nprint(\"shape\", selection.shape)\nprint(\"rank\", selection.ndim)\n\nshape (3, 1)\nrank 2\n\n\nWhat if we wanted a truly 1d array (rank 1)? We need to reshape the array.\nWe can use the np.reshape function to change the shape of an array without changing its data. For example, we can reshape a 2D array into a 1D array or vice versa.\nReshape takes a tuple of the new shape as an argument. If you want to flatten an array (convert it to a 1D array), you can use -1 as one of the dimensions, which tells NumPy to infer the size of that dimension based on the total number of elements.\n\nselection = small_matrix[::-1,:1]\nreshaped_selection = selection.reshape((3,))  # reshape to a 1D array excplicitly\nprint(\"reshaped shape\", reshaped_selection.shape)\nprint(\"reshaped rank\", reshaped_selection.ndim)\nprint(\"reshaped selection\", reshaped_selection)\n\nreshaped shape (3,)\nreshaped rank 1\nreshaped selection [1 1 1]\n\n\n\n#same code as above, but with inferred shape\nselection = small_matrix[::-1,:1]\nreshaped_selection = selection.reshape(-1)  # infererd shape\nprint(\"reshaped shape\", reshaped_selection.shape)\nprint(\"reshaped rank\", reshaped_selection.ndim)\nprint(\"reshaped selection\", reshaped_selection)\n\nreshaped shape (3,)\nreshaped rank 1\nreshaped selection [1 1 1]\n\n\nAnother way to cast a multi-dimensional array to a 1D array is to use the np.ravel() function, which returns a flattened view of the array (not a copy).\n\na_matrix = rng.integers(0,10,size=(2,3)) # random integers in [0,10), 2x3 matrix\nprint(\"Original matrix:\\n\", a_matrix)\nravelled_view = a_matrix.ravel()\nprint(\"Flattened view:\", ravelled_view)  # flatten the array to a 1D array\n\nOriginal matrix:\n [[4 7 8]\n [7 7 0]]\nFlattened view: [4 7 8 7 7 0]\n\n\nIf we modify the view, we modify the original array as well.\n\nravelled_view[0] = 100  # modify the view\nprint(\"Modified view:\", ravelled_view)  # the view is modified\nprint(\"Original array:\", a_matrix)  # the original array is modified as well\n\nModified view: [100   7   8   7   7   0]\nOriginal array: [[100   7   8]\n [  7   7   0]]\n\n\nTo obtain a completely independent flattened copy of the array, you can use the np.flatten() method, which returns a copy of the array in a 1D format.\n\na_matrix = rng.integers(0,10,size=(2,3)) # random integers in [0,10), 2x3 matrix\nprint(\"The original:\\n\",a_matrix)\nflattened_copy = a_matrix.flatten()\nprint(\"Flattened:\",flattened_copy)  # flatten the array to a 1D array\nflattened_copy[0] = 100  # modify the copy\nprint(\"Flattened after modification:\",flattened_copy)  # the copy is modified\nprint(\"The original:\\n\",a_matrix)  # the original array is not modified\n\nThe original:\n [[4 4 7]\n [4 6 9]]\nFlattened: [4 4 7 4 6 9]\nFlattened after modification: [100   4   7   4   6   9]\nThe original:\n [[4 4 7]\n [4 6 9]]\n\n\nWe can also do the opposite and increase the rank of an array by reshaping it. For example, we can reshape a 1D array into a 2D array with one column or one row.\n\none_dimensional_array = rng.integers(0,10,size=(5,))  # random integers in [0,10), 1D array\nprint(\"One-dimensional array:\", one_dimensional_array)\nreshaped_array = one_dimensional_array.reshape((5,1))  # reshape to a  2D array with one column\nprint(\"Reshaped array:\\n\", reshaped_array)\n\nOne-dimensional array: [5 5 5 3 2]\nReshaped array:\n [[5]\n [5]\n [5]\n [3]\n [2]]\n\n\n\n\nBroadcasting\nCombining arrays of different shapes is possible in NumPy using a feature called broadcasting. Broadcasting allows NumPy to perform operations on arrays of different shapes by automatically expanding the smaller array to match the shape of the larger one.\n\n# Minimal broadcasting example: rank 2 (matrix) with rank 1 (vector)\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6]])\nvector = np.array([10, 20, 30])\n\n# Broadcasting addition: vector is added to each row of the matrix\nresult = matrix + vector\nprint(\"Matrix:\\n\", matrix)\nprint(\"Vector:\", vector)\nprint(\"Result of broadcasting:\\n\", result)\n\nMatrix:\n [[1 2 3]\n [4 5 6]]\nVector: [10 20 30]\nResult of broadcasting:\n [[11 22 33]\n [14 25 36]]\n\n\nYou can reshape a 1D array to a column or row vector and use broadcasting to expand it into a large table. For example, to create a table where each row is the original 1D array, or each column is the original array:\n\none_dimensional_array = np.linspace(1, 5, num=5)  # create a 1D array with 5 elements\nprint(\"One-dimensional array:\", one_dimensional_array)\n# Expand one_dimensional_array to a table with 5 rows and 5 columns\nrow_vector = one_dimensional_array.reshape(1, -1)  # shape (1, 5)\ncolumn_vector = one_dimensional_array.reshape(-1, 1)  # shape (5, 1)\n\n# Broadcasting to create a table\ntable = column_vector + row_vector\nprint(\"BroadcastedTable:\\n\",table)\n\nOne-dimensional array: [1. 2. 3. 4. 5.]\nBroadcastedTable:\n [[ 2.  3.  4.  5.  6.]\n [ 3.  4.  5.  6.  7.]\n [ 4.  5.  6.  7.  8.]\n [ 5.  6.  7.  8.  9.]\n [ 6.  7.  8.  9. 10.]]",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#two-dimensional-arrays-as-matrices-some-linear-algebra",
    "href": "10/lecture_multidimensionalArrays.html#two-dimensional-arrays-as-matrices-some-linear-algebra",
    "title": "Multi-dimensional arrays",
    "section": "Two-dimensional arrays as matrices: some linear algebra",
    "text": "Two-dimensional arrays as matrices: some linear algebra\nTwo-dimensional arrays are often used to represent matrices or images. In a matrix, each element can be accessed using two indices: - one for the row - one for the column.\nA matrix is a rectangular array of numbers, symbols, or expressions arranged in rows and columns and is an essential concept in linear algebra.\nFor examplle, let’s consider the simple system of simultaneous equations:\n\\[ \\begin{align*}\n2x + 3y +z &= 5 \\\\\n4x - y &= 1 \\\\\n2y +z &= 3\n\\end{align*} \\]\nThis can be represented in matrix form as: \\[ \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n=\n\\begin{bmatrix}5 \\\\\n1\\\\\n3\n\\end{bmatrix} \\]\nAnd if we call \\(A\\) the matrix of coefficients, \\(\\mathbf{x}\\) the vector of variables, and \\(b\\) the vector of constants, we can write this as: \\[ A \\mathbf{x} = \\mathbf{b} \\]\nwhere \\[A = \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}, \\quad\n\\mathbf{x} = \\begin{bmatrix}\nx \\\\\ny\\\\\nz\n\\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix}\n5 \\\\\n1\\\\\n3\n\\end{bmatrix} \\]\nA key result of linear algebra is that if \\(A\\) is invertible, we can solve for \\(\\mathbf{x}\\) by multiplying both sides of the equation by the inverse of \\(A\\): \\[ \\mathbf{x} = A^{-1} \\mathbf{b} \\]\nwhere \\(A^{-1}\\) is the inverse of matrix \\(A\\).\nNumPy has a dedicated linear algebra submodule called numpy.linalg that provides functions for performing various linear algebra operations, including matrix inversion, solving systems of equations, and computing eigenvalues and eigenvectors.\n\nA = np.array([[2, 3,1], [4, -1,0],[0,2,1]])\nb = np.array([[5], [1], [3]]) # we use double brackets to create a column vector\nprint(\"Matrix A:\\n\", A)\nprint(\"Vector b:\\n\", b)\n\nMatrix A:\n [[ 2  3  1]\n [ 4 -1  0]\n [ 0  2  1]]\nVector b:\n [[5]\n [1]\n [3]]\n\n\nThe linear algebra submodule has a function called solve which can be used to solve the above equation efficiently:\n\nx = np.linalg.solve(A, b)\n\nx\n\narray([[0.5],\n       [1. ],\n       [1. ]])\n\n\nBut we can use numpy to verify that this is correct. We can use the symbol @ to perform matrix multiplication in numpy.\n\nA @ x\n\narray([[5.],\n       [1.],\n       [3.]])\n\n\nWe can also directly calculate the inverse of a matrix using the inv function from the numpy.linalg and use it to solve the equation\n\nx = np.linalg.inv(A) @ b\n\nx\n\narray([[0.5],\n       [1. ],\n       [1. ]])\n\n\nAll the most common linear algebra operations are available in the numpy.linalg submodule:\n\ntranpose\n\n\nb.T\n\narray([[5, 1, 3]])\n\n\n\nscalar (dot) product (which takes two vectors and returns a scalar)\n\n\nnp.dot(b.T,b)\n\narray([[35]])\n\n\n\ncross product\n\n\nnp.cross(b.T, b.T) #takes row vectors and returns a row vector\n\narray([[0, 0, 0]])\n\n\nLinear algebra applications are beyond the scope of this course (so, there will be no assessment of these), but they are widely used in various fields such as physics, computer science, and engineering. For example, they are essential in computer graphics for transformations, in machine learning for optimization, and in physics for solving systems of equations. So it is important for you to know that all these can be implemented efficiently using numpy.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#matrices-as-images",
    "href": "10/lecture_multidimensionalArrays.html#matrices-as-images",
    "title": "Multi-dimensional arrays",
    "section": "Matrices as images",
    "text": "Matrices as images\nA two-dimensional table of numbers can also be used to represent an image. Each number in the table corresponds to a pixel in the image, and the value of the number represents the color or intensity of that pixel.\nmatplotlib provides a convenient way to visualize 2D arrays as images. The matshow function can be used to display a 2D matrix as an image, where the values in the array are mapped to colors.\n\nimport matplotlib.pyplot as plt\nplt.matshow(A)\nplt.colorbar()\nprint(A)\n\n[[ 2  3  1]\n [ 4 -1  0]\n [ 0  2  1]]\n\n\n\n\n\n\n\n\n\nNotice that the indices of the y-axis increase as we go down. These are the indices of the rows in the matrix.\nFor a matrix of a given shape we can get the indices using the np.indices function, which returns a grid of indices for each dimension. This can be useful for creating masks or selecting specific regions of the matrix.\n\nrow_index, col_index = np.indices(A.shape)\nprint(\"Row indices:\\n\", row_index)\nprint(\"Column indices:\\n\", col_index)\n\nRow indices:\n [[0 0 0]\n [1 1 1]\n [2 2 2]]\nColumn indices:\n [[0 1 2]\n [0 1 2]\n [0 1 2]]\n\n\nAn alternative function is imshow, which is more general and can be used for both 2D arrays and images.\nHere we can set the origin of the axis:\n\nplt.imshow(A, origin='lower')  # origin='lower' to set the origin at the bottom left\n\n\n\n\n\n\n\n\n\nplt.imshow(A, origin='upper')  # origin=\"upper\" to set the origin at the top left\n\n\n\n\n\n\n\n\nThe main difference between matshow and imshow is that matshow is specifically designed for displaying matrices, while imshow is more general and can be used for both 2D arrays and images. matshow automatically adjusts the aspect ratio to make the matrix square, while imshow does not. Also the interpolation method used by matshow is different from that used by imshow, which can affect the appearance of the image.\nImages are represneted as 3d arays: every entry is a the intensity of a pixel (if the image is grayscale) or the intensity of a colour (e.g. red, green or blue) if the image is in colour.\n\nfrom skimage import data # importing images from a popular image library\n\nimage = data.camera() # a grayscale image\n\nplt.imshow(image, cmap='gray')  # display the image in grayscale\nplt.colorbar()\n\n\n\n\n\n\n\n\nLet’s take a colour image\n\ncolor_image = data.chelsea()\nplt.imshow(color_image)  # display the color image\n\n\n\n\n\n\n\n\nThis is no longer just a 2d array, it has a third dimension for the colour channels (red, green, blue). We can access the individual colour channels by slicing the array along the third dimension.\n\ncolor_image.shape\n\n(300, 451, 3)\n\n\nWe can slice the array to get the various channels (notice that we specify the colormap cmap argument to display the channels in the appropriate colour):\n\nfig,ax = plt.subplots(1, 3, figsize=(15, 5))  # create a figure with 3 subplots\nax[0].imshow(color_image[:, :, 0], cmap='Reds')  # display the red channel\nax[0].set_title('Red Channel')\nax[1].imshow(color_image[:, :, 1], cmap='Greens')  # display the green channel\nax[1].set_title('Green Channel')\nax[2].imshow(color_image[:, :, 2], cmap='Blues')  # display the blue channel\nax[2].set_title('Blue Channel')\n\nText(0.5, 1.0, 'Blue Channel')\n\n\n\n\n\n\n\n\n\nIf we want to subsample regions of an image, we can simply slice the array further in its rows and columns.\n\nplt.imshow(color_image[100:250, 100:, 1], cmap='Greens')  # display the green channel\n\n\n\n\n\n\n\n\nWe can also use boolean indexing to filter the image based on conditions.\nFor example, we can binarise it by applying a threshold\n\ngreen = color_image[:,:,1]\n\nplt.imshow(green&gt;100, cmap='gray')  # display a binary image where pixels with green channel value &gt; 100 are white\n\n\n\n\n\n\n\n\nWe can even perform logical operations using numpy\n\nAND with &\nOR with |\nNOT with ~ or np.logical_not\n\n\ngreen = color_image[:,:,1]\nred = color_image[:,:,0]\nplt.imshow( (green&gt;120) & (red&gt;120) , cmap='gray')\n\n\n\n\n\n\n\n\n\nplt.imshow(np.logical_not(green&gt;100), cmap='gray')",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#pair-programming",
    "href": "10/lecture_multidimensionalArrays.html#pair-programming",
    "title": "Multi-dimensional arrays",
    "section": "Pair programming",
    "text": "Pair programming\nThe following exercise will allow you explore multi-dimensional arrays by working in pairs. One person will write the code, while the other will explain what the code does. You can switch roles after each exercise.\nThere are two parts so, you can switch roles after each part.\n\nPart1\nPart2",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/exercises_part2.html",
    "href": "10/exercises_part2.html",
    "title": "Using a mask",
    "section": "",
    "text": "For the second part of this activity you will remain in the same pairs/threes as the first part and you should continue writing code in the same way using pair programming. However, you should swap your roles, so one of the people directing (the navigator) should now be writing the code (the driver) and vice versa.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#pair-programming-part-2",
    "href": "10/exercises_part2.html#pair-programming-part-2",
    "title": "Using a mask",
    "section": "",
    "text": "For the second part of this activity you will remain in the same pairs/threes as the first part and you should continue writing code in the same way using pair programming. However, you should swap your roles, so one of the people directing (the navigator) should now be writing the code (the driver) and vice versa.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#masking-a-galaxy",
    "href": "10/exercises_part2.html#masking-a-galaxy",
    "title": "Using a mask",
    "section": "Masking a galaxy",
    "text": "Masking a galaxy\nOne application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\nfrom PIL import Image\nimport numpy as np\n\nim_filename = \"ngc253_small.png\"\nim = np.array(Image.open(im_filename))\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\nprint(im.shape)\n\n(907, 1000, 3)\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im, origin=\"lower\")\n\n\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#creating-an-elliptical-mask",
    "href": "10/exercises_part2.html#creating-an-elliptical-mask",
    "title": "Using a mask",
    "section": "Creating an elliptical mask",
    "text": "Creating an elliptical mask\nThe inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\ndef inside_ellipse(x, y, centre=(0,0), a=2, b=1, alpha=0):\n    \n    x0,y0 = centre\n    \n    # Convert alpha in degrees to radians for use with cos/sin function\n    alpha_rad = np.radians(alpha)\n    \n    term1 = ((x-x0)*np.cos(alpha_rad) + (y-y0)*np.sin(alpha_rad))**2 / a**2\n    term2 = ((x-x0)*np.sin(alpha_rad) - (y-y0)*np.cos(alpha_rad))**2 / b**2\n    \n    total = term1 + term2\n\n    return total&lt;1\n\n\nEquations for an ellipse\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\nx1 = 0\ny1 = 0\nposition_is_in_ellipse1 = inside_ellipse(x1, y1, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x1}, {y1}) inside the ellipse? {position_is_in_ellipse1}\")\n\nx2 = 0\ny2 = 4\nposition_is_in_ellipse2 = inside_ellipse(x2, y2, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x2}, {y2}) inside the ellipse? {position_is_in_ellipse2}\")\n\nIs position (0, 0) inside the ellipse? True\nIs position (0, 4) inside the ellipse? False\n\n\n\n\n\nExercise B\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel).\n\n# ADD CODE HERE\n\n\n# ADD CODE HERE\n\n\n# UNCOMMENT THIS CODE TO PLOT YOUR MASKED IMAGE\n\n#import matplotlib.pyplot as plt\n#\n#fig, ax = plt.subplots(figsize=(8,8))\n#ax.imshow(im_masked.astype(int),origin=\"lower\")\n\nTake time to discuss this but if you are both really stuck, there is a hint notebook available which shows how you would apply a mask which includes a rectangle to an image.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#calculating-the-magnitude",
    "href": "10/exercises_part2.html#calculating-the-magnitude",
    "title": "Using a mask",
    "section": "Calculating the magnitude",
    "text": "Calculating the magnitude\nNow that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\nExercise C\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html\n\n# ADD CODE HERE",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/hint2_apply_mask.html",
    "href": "10/hint2_apply_mask.html",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "",
    "text": "Example: Applying a mask containing a rectangle to an image\nI have downloaded an online image of a house for this example (from Vector Stock). This image contains four different rooms and I want to use a rectangular mask so that only the office room is displayed. As described previously, we can open this image using a the Image sub-module of a module called pillow (imported as PIL) which understands how to read image files. We can then convert this input into a numpy array object.\nfrom PIL import Image\nimport numpy as np\n\nim_filename = \"images/image-house-vector-stock.jpg\"\nim = np.array(Image.open(im_filename))\nim is a three dimensional numpy array object - includes height, width and colour channel (R, G, B).\nshape = im.shape\nprint(shape)\n\n(780, 1000, 3)\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im)\nThe imshow function knows how to interpret this 3D shape to show a colour image.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Hint 2 - applying a rectangular mask"
    ]
  },
  {
    "objectID": "10/hint2_apply_mask.html#create-a-rectanglar-mask-using-a-function",
    "href": "10/hint2_apply_mask.html#create-a-rectanglar-mask-using-a-function",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "Create a rectanglar mask using a function",
    "text": "Create a rectanglar mask using a function\nI can define an function called inside_rectangle() to tell me whether a given (x, y) position is within a rectangle for a set of parameters. This will return True if the position is inside the rectangle and False otherwise.\nThe rectangle can be evaluated using the conditions:\n\\[|x - x_0| = w/2\\] and \\[|y - y_0| = h/2\\]\nwhere - \\(x\\), \\(y\\) are the x, y positions within the grid - \\(x_0\\), \\(y_0\\) are the centre of the rectangle - \\(w\\), \\(h\\) - are the full width and height of the rectangle - \\(| |\\) means the magnitude of the difference\n\ndef inside_rectangle(x,y,centre=(0,0),width=20,height=10):\n    \n    x0 = centre[0]\n    y0 = centre[1]\n    \n    distance_x = np.abs(x - x0) # Magnitude of distance\n    distance_y = np.abs(y - y0) # Magnitude of distance\n    \n    # Check if (x, y) position is within the rectangle\n    if distance_x &lt; width/2 and distance_y &lt; height/2:\n        return True\n    else:\n        return False\n\nFor this mask, I want to define the parameters as follows:\n\n# Input parameters\ncentre = (382,320)\nwidth = 280\nheight = 218\n\nThe inside_rectangle function allows you to pass the parameters for your position and your rectangle and can tell you whether the position is within your rectangle (returns a True value) or not (returns a False value). For example if we had a position of (50, 50) we could use the function as follows:\n\nx = 50\ny = 50\n\nposition_is_in_rectangle = inside_rectangle(x, y, centre=centre, width=width, height=height)\n\nif position_is_in_rectangle:\n    print(f\"Position ({x}, {y}) is within the rectangle\")\nelse:\n    print(f\"Not within rectangle\")\n\nNot within rectangle\n\n\nHere we used the output of inside_rectangle as our condition directly (Python sees this if True or if False and follows the logic accordingly).\nWe can use the inside_rectangle() function to define our mask - looping over every element and checking the x, y position with the inside_rectangle() function with the appropriate parameters:\n\nncol = shape[0]\nnrow = shape[1]\n\n# Create array of zeros based on shape of input image - height x width\nrect_mask = np.zeros(shape[0:2],dtype=int)\n\nfor y in range(ncol): # iterate over first dimension\n    for x in range(nrow): # iterate over second dimension\n        # Check whether x, y position is within defined rectangle\n        position_is_in_rectangle = inside_rectangle(x, y, centre=centre, width=width, height=height)\n        if position_is_in_rectangle:\n            rect_mask[y, x] = 1\n\nprint(f\"Shape of mask: {rect_mask.shape}\")\n\nShape of mask: (780, 1000)\n\n\nAs before, we don’t need an else block here because the array we have defined already contains zeros.\nExtended: See alternative numpy method mask in Hint 1 notebook for a more efficient way to create a square mask. Could you extend this method to reproduce a rectangular mask (without the need for the inside_rectangle function)?",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Hint 2 - applying a rectangular mask"
    ]
  },
  {
    "objectID": "10/hint2_apply_mask.html#apply-mask-to-the-image",
    "href": "10/hint2_apply_mask.html#apply-mask-to-the-image",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "Apply mask to the image",
    "text": "Apply mask to the image\nNow we have created rect_mask, we need to apply this to my image. We can do this by multiplying im by rect_mask and this will combine element-wise. This means that each pixel in the image will be multiplied by the corresponding value within the mask. Multipying by 0 will result in the output pixel also being 0 but multiplying by 1 will retain the original value in that pixel.\nFor creating the im_masked output there a few ways you could do this - the upshot is that you want to create an array of the right shape: - Create an empty array of the right shape - Create a new variable called im_masked which is a copy of the im using the copy() function (method)\nBecause im is a three dimensional array (height x weight x colour channel), one way to apply the mask is to do this for each of the three colours (R, G, B channels) separately.\n\n## Create an empty array of the right shape\nim_masked = np.empty(shape)\n## OR make a copy and then apply mask\n#im_masked = im.copy()\n\n# Update the values within this array for each colour channel\nim_masked[:,:,0] = im[:,:,0]*rect_mask # shapes match (780, 1000) x (780, 1000)\nim_masked[:,:,1] = im[:,:,1]*rect_mask # shapes match (780, 1000) x (780, 1000)\nim_masked[:,:,2] = im[:,:,2]*rect_mask # shapes match (780, 1000) x (780, 1000)\n\n# # Another way to write this would be to add an extra dimension to our mask\n# # - This can be done using the np.newaxis constant to add an extra dimension\n# # - Numpy can then *broadcast* along this new dimension to combine correctly\n# im_masked = im*rect_mask[:,:,np.newaxis] # shapes (780, 1000, 3) x (780, 1000, 1)\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im_masked.astype(int))",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Hint 2 - applying a rectangular mask"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html",
    "href": "11/lecture_beyond_the_notebook.html",
    "title": "Beyond the notebook",
    "section": "",
    "text": "Our notebooks in jupyter do not exist in the void. They are stored in a directory on an online account on the Noteable server. These directories have a structure, the file system, and we can navigate this structure using dedicated commands.\nThese are not python commands, but are in fact specific to the file system itself, and follow different logic and conventions. For this reason, we prepend them with the ! character. At the moment, we will use one command per cell.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#our-file-system",
    "href": "11/lecture_beyond_the_notebook.html#our-file-system",
    "title": "Beyond the notebook",
    "section": "",
    "text": "Our notebooks in jupyter do not exist in the void. They are stored in a directory on an online account on the Noteable server. These directories have a structure, the file system, and we can navigate this structure using dedicated commands.\nThese are not python commands, but are in fact specific to the file system itself, and follow different logic and conventions. For this reason, we prepend them with the ! character. At the moment, we will use one command per cell.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#pathway-to-the-current-directory",
    "href": "11/lecture_beyond_the_notebook.html#pathway-to-the-current-directory",
    "title": "Beyond the notebook",
    "section": "Pathway to the current directory",
    "text": "Pathway to the current directory\nFirst, let’s check where we are right now in the file system. To do so, we query the pathway to the working directory with the pwd command.\n\n! pwd\n\n/Users/ft14968/Repos/intro-coding-data-analysis/quarto/11\n\n\nThis shows where we currently are, and each of you should have a different path, with a different username.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#listing-the-content-of-the-current-directory",
    "href": "11/lecture_beyond_the_notebook.html#listing-the-content-of-the-current-directory",
    "title": "Beyond the notebook",
    "section": "Listing the content of the current directory",
    "text": "Listing the content of the current directory\nThe ls command lists the files and directories in the current directory. The current directory is represented by a . (dot).\n\n! ls \n\n\nexample.html\n\nexample.qmd\n\nexercises_numpy_riddles_solutions_files\n\nexercises_numpy_riddles_solutions.html\n\nexercises_numpy_riddles_solutions.qmd\n\nexercises_numpy_riddles.html\n\nexercises_numpy_riddles.qmd\n\nexercises_python_riddles_solutions.html\n\nexercises_python_riddles_solutions.qmd\n\nexercises_python_riddles.qmd\n\nlecture_beyond_the_notebook.qmd\n\nlecture_beyond_the_notebook.quarto_ipynb\n\nparabola.png\n\nsrc2",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#creating-a-new-directory",
    "href": "11/lecture_beyond_the_notebook.html#creating-a-new-directory",
    "title": "Beyond the notebook",
    "section": "Creating a new directory",
    "text": "Creating a new directory\nThe mkdir command creates a new directory in the specified path. For example, to create a new directory in the current directory we can write\n\n! mkdir new_directory \n\nWe can check its existence with ls.\n\n! ls\n\n\nexample.html\n\nexample.qmd\n\nexercises_numpy_riddles_solutions_files\n\nexercises_numpy_riddles_solutions.html\n\nexercises_numpy_riddles_solutions.qmd\n\nexercises_numpy_riddles.html\n\nexercises_numpy_riddles.qmd\n\nexercises_python_riddles_solutions.html\n\nexercises_python_riddles_solutions.qmd\n\nexercises_python_riddles.qmd\n\nlecture_beyond_the_notebook.qmd\n\nlecture_beyond_the_notebook.quarto_ipynb\n\nnew_directory\n\nparabola.png\n\nsrc2\n\n\n\n\nEqually, we can go back to the jupyter interface and see the new directory in the graphical user interface.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#changing-directory",
    "href": "11/lecture_beyond_the_notebook.html#changing-directory",
    "title": "Beyond the notebook",
    "section": "Changing directory",
    "text": "Changing directory\nIt is easy to change the current directory with the cd command. For example, to go to the new_directory with\n\n! cd new_directory\n\nAnd we we can go back to the previous directory with the cd command again using ..\n\n! cd ..",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#creating-an-empty-file",
    "href": "11/lecture_beyond_the_notebook.html#creating-an-empty-file",
    "title": "Beyond the notebook",
    "section": "Creating an empty file",
    "text": "Creating an empty file\nThe touch command creates a new file in the specified path. For example, to create a new file in the current directory we can write\n\n! touch new_directory/new_file.txt\n\nWe can check its existence with ls.\n\n! ls new_directory\n\nnew_file.txt\n\n\nWe can open this file in the graphical user interface and edit the contents\n[follows demonstration in Noteable with dummy text in the file new_file.txt]",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#viewing-file-content",
    "href": "11/lecture_beyond_the_notebook.html#viewing-file-content",
    "title": "Beyond the notebook",
    "section": "Viewing file content",
    "text": "Viewing file content\nThe cat command prints the content of a file. For example, to view the content of new_file.txt we can write\n\n! cat new_directory/new_file.txt \n\nSeveral other commands exist to display parts of files, such as head, tail etc. Try them if you like!",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise",
    "href": "11/lecture_beyond_the_notebook.html#exercise",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\n\nCreate a new jupyter notebook using the graphical user interface.\nFrom the notebook, use the commands above to create:\n\na new directory called src\na new file inside the directory called naive_script.py\nopen it with double click for the files tab in jupyter and write a minimal code\n\nprint(\"Hello, World!\")\n\nsave the file\nuse the cat command from the notebook to view the content of naive_script.py",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#running-scripts-from-the-notebook",
    "href": "11/lecture_beyond_the_notebook.html#running-scripts-from-the-notebook",
    "title": "Beyond the notebook",
    "section": "Running scripts: from the notebook",
    "text": "Running scripts: from the notebook\nFor the entire duration of this course, you have been running python codes by typing them inside the notebook cells and executing the code cells.\nThe notebooks are complex files, that contain a lot of information beyond your code: the markdown, images, and a lot of extra data (called metadata).\nA much more essential way to store python code is to use scripts. These are files with the .py extension, like your naive_script.py file. Inside a script you can only have\n\npython code\npython comments to the code (i.e. lines prepended by the #)\n\nThis means that the scripts are simple, portable pure text files containing instructions in the python language.\nCan we execute such instructions? Yes, we run a script in various way. A simple way is to do it directly from a code cell in the notebook. For this we use a special jupyter command called run followed by the path to the script.\n[check that you are in the correct path and the script exist]\n\nrun src/naive_script.py\n\n\n---------------------------------------------------------------------------\nOSError                                   Traceback (most recent call last)\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:727, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    726     fpath = arg_lst[0]\n--&gt; 727     filename = file_finder(fpath)\n    728 except IndexError as e:\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/utils/path.py:90, in get_py_filename(name)\n     89         return py_name\n---&gt; 90 raise IOError(\"File `%r` not found.\" % name)\n\nOSError: File `'src/naive_script.py'` not found.\n\nThe above exception was the direct cause of the following exception:\n\nException                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 get_ipython().run_line_magic('run', 'src/naive_script.py')\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/interactiveshell.py:2481, in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\n   2479     kwargs['local_ns'] = self.get_local_scope(stack_depth)\n   2480 with self.builtin_trap:\n-&gt; 2481     result = fn(*args, **kwargs)\n   2483 # The code below prevents the output from being displayed\n   2484 # when using magics with decorator @output_can_be_silenced\n   2485 # when the last Python token in the expression is a ';'.\n   2486 if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:738, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    736     if os.name == 'nt' and re.match(r\"^'.*'$\",fpath):\n    737         warn('For Windows, use double quotes to wrap a filename: %run \"mypath\\\\myfile.py\"')\n--&gt; 738     raise Exception(msg) from e\n    739 except TypeError:\n    740     if fpath in sys.meta_path:\n\nException: File `'src/naive_script.py'` not found.\n\n\n\nAs you can see, we have executed the instructions of the script and its textual output has been printed in the notebook. No variables are created during the process.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#the-terminal",
    "title": "Beyond the notebook",
    "section": "The Terminal",
    "text": "The Terminal\nAll the commands that we have seen above can be used in a pure-text environment called the terminal. The terminal is a text-based interface to an operating system (local or remote).\nYou do not use the mouse to perform actions. Instead, you write commands. These commands belong to the scripting language called bash (see here for more information). It is different from python, they can interact together in the notebook.\nYou can launch a terminal directly from Noteable by clicking on the New button, then selecting Terminal.\n\n\n\nimage.png",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-1",
    "href": "11/lecture_beyond_the_notebook.html#exercise-1",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\n\nWe try to navigate folders from the terminal and create a file\nOpen the terminal and\n\nchange the directory to src (using cd)\ncreate a new file inside the directory called parabola.py (use touch)\ngo back to the Noteable file tab, refresh the web-page and open the parabola.py file\nopen it and write a minimal code to plot a parabola. For example:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\na = 1.\nb =1.\nc = 2\nxlo = 0\nxhi = 10\nnpoints = 100\nx = np.linspace(xlo, xhi, npoints)\ny = a*x**2 + b*x + c\nplt.plot(x,y)\nplt.savefig(\"parabola.png\")\n\n\nsave the file and go back to the Terminal tab\nuse the cat command to check the content",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-running-scripts-from-the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#exercise-running-scripts-from-the-terminal",
    "title": "Beyond the notebook",
    "section": "Exercise: Running scripts from the Terminal",
    "text": "Exercise: Running scripts from the Terminal\nWe have seen that we can run the scripts from the notebook using the run command. In a very similar way, we can run scripts from the terminal, just by using the python command followed by the path to the script.\nDo the following:\n\nfirst run the parabola script from the notebook using run: you should see the plot appear in the notebook.\nthen go back to the Terminal and run the parabola.py script using the python command followed by the path to the script: e.g. python src/parabola.py. Where is the output?\n\n\nrun src/parabola.py\n\n\n---------------------------------------------------------------------------\nOSError                                   Traceback (most recent call last)\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:727, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    726     fpath = arg_lst[0]\n--&gt; 727     filename = file_finder(fpath)\n    728 except IndexError as e:\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/utils/path.py:90, in get_py_filename(name)\n     89         return py_name\n---&gt; 90 raise IOError(\"File `%r` not found.\" % name)\n\nOSError: File `'src/parabola.py'` not found.\n\nThe above exception was the direct cause of the following exception:\n\nException                                 Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 get_ipython().run_line_magic('run', 'src/parabola.py')\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/interactiveshell.py:2481, in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\n   2479     kwargs['local_ns'] = self.get_local_scope(stack_depth)\n   2480 with self.builtin_trap:\n-&gt; 2481     result = fn(*args, **kwargs)\n   2483 # The code below prevents the output from being displayed\n   2484 # when using magics with decorator @output_can_be_silenced\n   2485 # when the last Python token in the expression is a ';'.\n   2486 if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:738, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    736     if os.name == 'nt' and re.match(r\"^'.*'$\",fpath):\n    737         warn('For Windows, use double quotes to wrap a filename: %run \"mypath\\\\myfile.py\"')\n--&gt; 738     raise Exception(msg) from e\n    739 except TypeError:\n    740     if fpath in sys.meta_path:\n\nException: File `'src/parabola.py'` not found.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#reusing-code",
    "href": "11/lecture_beyond_the_notebook.html#reusing-code",
    "title": "Beyond the notebook",
    "section": "Reusing code",
    "text": "Reusing code\nThe most useful feature of the scripts is that they can store code for future usage in an organized manner. We do not need to have all of our code in a single notebook: we can split the relvant bits, put them into scripts and use them again and again in different projects.\nWhat allows us to do this is the special python keywork import, that we have already used many times.\nLet’s move our working directory to src and try importing our parabola.py script\n\ncd src\n\n[Errno 2] No such file or directory: 'src'\n/Users/ft14968/Repos/intro-coding-data-analysis/quarto/11\n\n\nIn python we can only import .py files, so we drop the .py extension when importing.\n\nimport parabola\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 import parabola\n\nModuleNotFoundError: No module named 'parabola'\n\n\n\nNow the variables defined in parabola.py are available in our current notebook.\n\nprint(parabola.xhi)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 print(parabola.xhi)\n\nNameError: name 'parabola' is not defined\n\n\n\nCongratulations! You have written your first python module!",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-2",
    "href": "11/lecture_beyond_the_notebook.html#exercise-2",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\nThe module above is not very useful. A better way to reuse code is to encapsulate it in a **custom .\n\nModify your parabola.py script to create a function plot_parabola that takes a, b, c, xlo, xhi as parameters.\nThen, import your parabola module in the present notebook using the following line:\nimport parabola as pb\nCan you find a way to access your function plot_parabola from pb ?\nImprove your function to customize the appearence of the plot (adding custom labels, colors, linestyles) and use the function with such changes. Important you will need to restart the notebook for these to take effect, because a module is loaded only once.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#more-exercises-on-the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#more-exercises-on-the-terminal",
    "title": "Beyond the notebook",
    "section": "More exercises on the terminal",
    "text": "More exercises on the terminal\n\nMost commands in bash allow you to acces their documentation with &lt;name_of_the_command&gt; --help. Can you find out what the command mv does?\n\n\n##YOUR CODE HERE\n\n\nFind a way to rename your parabola.py script to geometry.py\n\n\n##YOUR CODE HERE\n\nMost commands in bash support options, using the dash - sytax. For example, ls -l will list the files in a long format. Can you use ls --help to find out what the -l option does\n\nls --help\n\nls: unrecognized option `--help'\nusage: ls [-@ABCFGHILOPRSTUWXabcdefghiklmnopqrstuvwxy1%,] [--color=when] [-D format] [file ...]\n\n\n\nCan you find an additional option for ls -l to fils files in reverse time order?\n\n\n##YOUR CODE HERE",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#riddles",
    "href": "11/lecture_beyond_the_notebook.html#riddles",
    "title": "Beyond the notebook",
    "section": "Riddles",
    "text": "Riddles\nTo revise the material from the previous lectures, we can try to solve some riddles.\nYou can find the exercises here below\n\nPython Riddles\nNumpy Riddles",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/exercises_numpy_riddles.html",
    "href": "11/exercises_numpy_riddles.html",
    "title": "Consolidation - numpy riddles",
    "section": "",
    "text": "Solve the following numpy riddles using numpy and its documentation.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\n\nimport numpy as np\n\nDiagonal Sum: - Riddle: Write a function that takes a square 2D NumPy array as input and returns the sum of the elements along the main diagonal. - Example: diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -&gt; 15\n\n## YOUR CODE HERE\n\nUnique Elements Count: - Riddle: Write a function that takes a 1D NumPy array as input and returns the count of unique elements in the array. - Example: unique_count([1, 2, 3, 2, 4, 1, 5]) -&gt; 5\n\n## YOUR CODE HERE\n\nRandom sample ands cumulative sum: - Riddle: A fair coin is tossed 20 times, and we win 1£ for every head and lose 1£ for every tail. Assuming that we start with no money at the beginning, and that the seed of teh default random number generator is seed=1234, how much money do we have at every succesive step?\n\n## YOUR CODE HERE\n\nRolling Window: - Riddle: Write a function that takes a 1D NumPy array and a window size as input, and returns a 2D array where each row is a sliding window of the input array of a given size. - For example, a 1d array with a rolling window of size 3: rolling_window([1, 2, 3, 4, 5], 3) -&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nHint: you can use list comprehension and convert the final list to an array.\n\n## YOUR CODE HERE\n\nProduct of elements: - Riddle: The geometric mean of a number of observations \\(x_1, x_2,\\dots, x_n\\) is defined as \\(M = \\sqrt{x_1\\times x_2\\times \\dots x_n }\\). Define a custom function to calculate the geometric mean. - Example: geometric_mean([1, 2, 3, 4, 5]) -&gt; 10.954451150103322\n\n## YOUR CODE HERE\n\nVectorised calculations and visualisation: - Riddle: Draw 100 thousand points uniformly distributed inside a circle of radius 1 centered at (0,0). Plot them using scatter() from matplotlib according to their radial coordinate: - use the hexadecimal colour \"#76d6ff\" for points at a distance below 0.5 from the origin$. - use the hexadecimal colour \"ffe701\" for points furtehr away.\nHint1: disk point picking is not trivial: https://mathworld.wolfram.com/DiskPointPicking.html\nHint2: For matplotlib’s plot, use the pixel style ',', and remmber to set the axis to be in the same units (\"equal\")\n\n## YOUR CODE HERE",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Consolidation - `numpy` riddles"
    ]
  },
  {
    "objectID": "11/exercises_numpy_riddles_solutions.html",
    "href": "11/exercises_numpy_riddles_solutions.html",
    "title": "Consolidation - numpy riddles",
    "section": "",
    "text": "Solve the following numpy riddles using numpy and its documentation.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\n\nimport numpy as np\n\nDiagonal Sum: - Riddle: Write a function that takes a square 2D NumPy array as input and returns the sum of the elements along the main diagonal. - Example: diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -&gt; 15\n\n## YOUR CODE HERE\n\ndef diagonal_sum(seq):\n    arr = np.asarray(seq)\n    return np.diagonal(arr).sum()\n\ndiagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n15\n\n\nUnique Elements Count: - Riddle: Write a function that takes a 1D NumPy array as input and returns the count of unique elements in the array. - Example: unique_count([1, 2, 3, 2, 4, 1, 5]) -&gt; 5\n\n## YOUR CODE HERE\ndef unique_count(sequence):\n    return np.unique(sequence).size\n\nunique_count([1, 2, 3, 2, 4, 1, 5]) \n\n5\n\n\nRandom sample ands cumulative sum: - Riddle: A fair coin is tossed 20 times, and we win 1£ for every head and lose 1£ for every tail. Assuming that we start with no money at the beginning, and that the seed of teh default random number generator is seed=1234, how much money do we have at every succesive step?\n\n## YOUR CODE HERE\n\nn_trials = 20\nrng = np.random.default_rng(1234)\nprint(\"The amount we have after every coin tossing is\", rng.choice([-1,1],n_trials).cumsum())\n\nThe amount we have after every coin tossing is [ 1  2  3  2  1  2  1  0 -1 -2 -1 -2 -1 -2 -1 -2 -1  0  1  0]\n\n\nRolling Window: - Riddle: Write a function that takes a 1D NumPy array and a window size as input, and returns a 2D array where each row is a sliding window of the input array of a given size. - For example, a 1d array with a rolling window of size 3: rolling_window([1, 2, 3, 4, 5], 3) -&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nHint: you can use list comprehension and convert the final list to an array.\n\n## YOUR CODE HERE\n\ndef rolling_window(seq,window):\n    arr = np.asarray(seq)\n    num_rows  = len(seq)- window + 1\n    return np.array([arr[i:i+window] for i in range(num_rows)])\n    \n\nrolling_window([1, 2, 3, 4, 5], 3)\n\narray([[1, 2, 3],\n       [2, 3, 4],\n       [3, 4, 5]])\n\n\nProduct of elements: - Riddle: The geometric mean of a number of observations \\(x_1, x_2,\\dots, x_n\\) is defined as \\(M = \\sqrt{x_1\\times x_2\\times \\dots x_n }\\). Define a custom function to calculate the geometric mean. - Example: geometric_mean([1, 2, 3, 4, 5]) -&gt; 10.954451150103322\n\n## YOUR CODE HERE\n\n\ndef geometric_mean(seq):\n    return np.sqrt(np.prod(seq))\n\n\ngeometric_mean([1, 2, 3, 4, 5])\n\n10.954451150103322\n\n\nVectorised calculations and visualisation: - Riddle: Draw 100 thousand points uniformly distributed inside a circle of radius 1 centered at (0,0). Plot them using scatplotter() from matplotlibacoording to their radial coordinate: - use the hexadecimal colour \"#76d6ff\" for points at a distance below 0.5 from the origin$. - use the hexadecimal colour \"ffe701\" for points furtehr away.\nHint1: disk point picking is not trivial: https://mathworld.wolfram.com/DiskPointPicking.html\nHint2: For matplotlib’s plot, use the pixel style ',', and remmber to set the axis to be in the same units (\"equal\")\n\n## YOUR CODE HERE\nnpoints = 100_000\ntheta = np.random.uniform(0, 2*np.pi, npoints)\nr = np.sqrt(np.random.uniform(0, 1, npoints))\nx = r * np.cos(theta)\ny = r * np.sin(theta)\n\ninside = r&lt;0.5\n\nimport matplotlib.pyplot as plt\n\nplt.plot(x[inside],y[inside],',',color=\"#76d6ff\")\nplt.plot(x[~inside],y[~inside],',',color=\"#ffe701\")\nplt.axis(\"equal\")\n\n(-1.0996463517906905,\n 1.0992516399542742,\n -1.0994327729527829,\n 1.098998268565109)",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Solutions - NumPy Riddles"
    ]
  },
  {
    "objectID": "formative/basic_structures.html",
    "href": "formative/basic_structures.html",
    "title": "Variables, lists, dictionaries and branches",
    "section": "",
    "text": "This is a formative test. It is an occasion to practice the course material. It does not contribute to your final grade.\nUsing the topics covered within the workshops (or otherwise), complete the questions below.\nMake sure to use any described variable names exactly and do not change the name of this file. This ensures the nbgrader tool can grade your work correctly.\n\n\n\n\nQuestion 1\n1A) Using the pi variable defined below (representing \\(\\pi\\) to 6 decimal places), calculate the circumference of a circle with radius of 5 and assign to a variable called circum_circle.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nRemember to define the radius and use the formula: circum_circle = 2 * pi * radius.\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nradius = 5\ncircum_circle = 2 * pi * radius\n\n\n\n\n\n1B) Calculate the area of a circle with radius 2.5 and assign to area_circle.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse Area = pi * radius**2.\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\narea_circle = pi * radius**2\n\n\n\n\n\n\n\nQuestion 2\n\n\n2A) Access the second name in the names list and assign to chemist.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nSecond element has index 1.\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nchemist = names[1]\n\n\n\n\n\n2B) Add \"Albert Einstein\" to the names list.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse names.append(\"Albert Einstein\").\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nnames.append(\"Albert Einstein\")\n\n\n\n\n\n\n\nQuestion 3\n\n\n3A) Access the value for quantity = \"temperature\" in quantity_units and assign to units.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nAccess dictionary values with dictionary[key].\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nunits = quantity_units[quantity]\n\n\n\n\n\n3B) For the variable second_quantity defined below, check whether this key is present in the quantity_units dictionary. If this is in the dictionary create a variable called quantity_present and assign this to a value of True, otherwise assign this to a value of False.\nNotes:\n\nYou can use the print function to check the value within your quantity_present variable (boolean). If this produces a NameError, you may need to check that quantity_present has been successfully created.\nCheck your Week 3 notes for examples of how to check membership (i.e. whether a value is contained within a collection like a list or a dictionary).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse key in dictionary to check membership.\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nif second_quantity in quantity_units:\n    quantity_present = True\nelse:\n    quantity_present = False\n# OR\nquantity_present = second_quantity in quantity_units\n\n\n\n\n\n\n\nQuestion 4\n4A) Two values of heights in units of feet are provided below in a list called height_feet. Convert these values to metres and calculate the difference in metres. Store this difference in a variable called height_difference_m.\nConversion from feet to metres can be done using the equation:\nThe conversion equation is: \\[ \\mathrm{height_{feet}} = \\mathrm{height_{m}} \\times 3.28084\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nConvert each height to metres and subtract: (h2 * conversion - h1 * conversion).\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nheight_metre = [height_feet[0]/feet_per_metre, height_feet[1]/feet_per_metre]\n# or if you have learnt about loops and list comprehension\nheight_metre = [h/feet_per_metre for h in height_feet]\n\nheight_difference_m = height_metre[1]-height_metre[0]\n\n\n\n\n\n4B) Check whether height_difference_m is:\n\nIf height_difference_m is greater than 0.5 metres (50cm), create a variable called check and set this to 1\nIf height_difference_m is between 0.3 and 0.5 metres (30 to 50cm), create a variable called check and set this to 2\nIf height_difference_m is something else, create a variable called check and set this to 3\n\ndo this by constructing and if–else block.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou need an if, elif else construct.\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\ncheck = 0\nif height_difference_m &gt; 0.5:\n    print(f\"{height_difference_m:.3f} is greater than 0.5m\")\n    check=1\nelif height_difference_m &gt; 0.3 and height_difference_m &lt;= 0.5:\n    print(f\"{height_difference_m:.3f} is greater than 0.3m but less than or equal to 0.5m\")\n    check=2\nelse:\n    print(height_difference_m)\n    check=3"
  },
  {
    "objectID": "11/exercises_python_riddles_solutions.html",
    "href": "11/exercises_python_riddles_solutions.html",
    "title": "Consolidation - Python riddles",
    "section": "",
    "text": "Solve the following using standard Python features and built-in functions.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\nSum of Digits - Riddle: Write a function sum_digits(n) that takes an integer n and returns the sum of its digits. - Test it with the following test cases: sum_digits(145)--&gt;10 and sum_digits(102)--&gt;3\nHint: remember that you can convert an integer to a string with str(n) and a character c to integer with int(c).\n\ndef sum_digits(n):\n    return sum(int(c) for c in str(n))\n\nassert sum_digits(102)==3\nassert sum_digits(145)==10\n\nPalyndrome checker\n\nRiddle: A word is a palyndrome if it reads the same forwards and backwards. Write a function is_palindrome(s) that takes an object s, checks that it is a string and returns True if s is a palindrome and False otherwise.\nTest it with the following test cases: is_palindrome(\"racecar\")--&gt;True , is_palindrome(\"hello\")--&gt;False and is_palindrome(3)--&gt;error\n\nHint: an object is a string if typ(s) returns str.\n\n#YOUR CODE HERE\ndef is_palindrome(s):\n    if type(s) == str:\n        return s == s[::-1]\n    else:\n        print(\"Error: Input is not a string.\")\n        return\n\nassert is_palindrome(\"racecar\")==True\nassert is_palindrome(\"hello\")==False\n\nis_palindrome(3)\n\nError: Input is not a string.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Solutions - Python Riddles"
    ]
  },
  {
    "objectID": "11/example.html",
    "href": "11/example.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\n! mkdir src2\n\n\n! touch src2/naive_script.py\n\n\n! cat src2/naive_script.py\n\n\nrun src2/naive_script.py\n\n\npath = ! pwd\n\n\npath\n\n['/Users/ft14968/Repos/intro-coding-data-analysis/quarto/11']\n\n\n\nrun src2/parabola.py\n\n\n---------------------------------------------------------------------------\nOSError                                   Traceback (most recent call last)\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:727, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    726     fpath = arg_lst[0]\n--&gt; 727     filename = file_finder(fpath)\n    728 except IndexError as e:\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/utils/path.py:90, in get_py_filename(name)\n     89         return py_name\n---&gt; 90 raise IOError(\"File `%r` not found.\" % name)\n\nOSError: File `'src2/parabola.py'` not found.\n\nThe above exception was the direct cause of the following exception:\n\nException                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 get_ipython().run_line_magic('run', 'src2/parabola.py')\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/interactiveshell.py:2481, in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\n   2479     kwargs['local_ns'] = self.get_local_scope(stack_depth)\n   2480 with self.builtin_trap:\n-&gt; 2481     result = fn(*args, **kwargs)\n   2483 # The code below prevents the output from being displayed\n   2484 # when using magics with decorator @output_can_be_silenced\n   2485 # when the last Python token in the expression is a ';'.\n   2486 if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:738, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    736     if os.name == 'nt' and re.match(r\"^'.*'$\",fpath):\n    737         warn('For Windows, use double quotes to wrap a filename: %run \"mypath\\\\myfile.py\"')\n--&gt; 738     raise Exception(msg) from e\n    739 except TypeError:\n    740     if fpath in sys.meta_path:\n\nException: File `'src2/parabola.py'` not found.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "example.html"
    ]
  },
  {
    "objectID": "11/exercises_python_riddles.html",
    "href": "11/exercises_python_riddles.html",
    "title": "Consolidation - Python riddles",
    "section": "",
    "text": "Solve the following using standard Python features and built-in functions.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\nSum of Digits - Riddle: Write a function sum_digits(n) that takes an integer n and returns the sum of its digits. - Test it with the following test cases: sum_digits(145)--&gt;10 and sum_digits(102)--&gt;3\nHint: remember that you can convert an integer to a string with str(n) and a character c to integer with int(c).\n\n# YOUR CODE HERE\n\nPalyndrome checker\n\nRiddle: A word is a palyndrome if it reads the same forwards and backwards. Write a function is_palindrome(s) that takes an object s, checks that it is a string and returns True if s is a palindrome and False otherwise.\nTest it with the following test cases: is_palindrome(\"racecar\")--&gt;True , is_palindrome(\"hello\")--&gt;False and is_palindrome(3)--&gt;error\n\nHint: an object is a string if typ(s) returns str.\n\n#YOUR CODE HERE",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Consolidation - `Python` riddles"
    ]
  },
  {
    "objectID": "10/exercises_part1.html",
    "href": "10/exercises_part1.html",
    "title": "Creating a mask containing a circle",
    "section": "",
    "text": "As part of this activity you have been split into pairs/threes and are being asked to create code together using a technique called pair programming.\nFor this exercise, one of you will be writing the code (the driver) and the others will be directing and advising on what should be written (the navigator(s)) with lots of discussion in between. Decide between yourselves who would like each role to start with. For the second exercise you will swap some of your roles but carry on working together in the same pairs/threes.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1.html#pair-programming-part-1",
    "href": "10/exercises_part1.html#pair-programming-part-1",
    "title": "Creating a mask containing a circle",
    "section": "",
    "text": "As part of this activity you have been split into pairs/threes and are being asked to create code together using a technique called pair programming.\nFor this exercise, one of you will be writing the code (the driver) and the others will be directing and advising on what should be written (the navigator(s)) with lots of discussion in between. Decide between yourselves who would like each role to start with. For the second exercise you will swap some of your roles but carry on working together in the same pairs/threes.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1.html#how-a-mask-could-be-used",
    "href": "10/exercises_part1.html#how-a-mask-could-be-used",
    "title": "Creating a mask containing a circle",
    "section": "How a mask could be used",
    "text": "How a mask could be used\nIn this workbook, we want you to create a mask. By this we mean a square (or rectangular) grid of zeros (0s) and ones (1s) with values of 1 in the positions you want to keep and values of 0 in the positions you don’t. This mask could then be applied to another image for example:\n \nWithin the mask the edge would look something like this:\n\nwhere the thin green line represents the edge of where the real circle would be.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1.html#circle-within-a-square",
    "href": "10/exercises_part1.html#circle-within-a-square",
    "title": "Creating a mask containing a circle",
    "section": "Circle within a square",
    "text": "Circle within a square\nThe mask we want you to create should represent a circle (defined within the grid). The equation governing the edge of a circle is:\n\\[ (x-x_0)^2 + (y-y_0)^2 = r^2 \\]\nwhere\n\n\\(x\\), \\(y\\) are the x, y positions within the grid\n\\(x_0\\), \\(y_0\\) are the centre of the circle\n\\(r\\) is the radius\n\nFor example, for a circle with radius of 2 with a centre point of (4, 3), if we looked at position (5, 4), then this would be inside that circle since:\n\\[\\sqrt{((5 - 4)^2 + (4 - 3)^2)}\\] \\[ = \\sqrt{1^2 + 1^2} = \\sqrt{1 + 1} = \\sqrt{2} = 1.41\\]\nwhich is less than the radius of 2.\n\n\nExercise A\nCreate a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n# ADD CODE HERE\n\n\n### UNCOMMENT THIS CODE TO PLOT YOUR MASK WHEN COMPLETED\n#\n#import matplotlib.pyplot as plt\n#\n#fig, ax = plt.subplots(figsize=(6, 3.2))\n#\n#ax.set_title('Circular Mask')\n#ax.imshow(circular_mask,cmap=\"bone\",origin=\"lower\") # Setting colourmap (cmap) and the position of 0,0 (origin) on the plot\n\nTake time to discuss this but if you are really stuck, there is a hint notebook available which shows how you would create a mask for a square rather than a circle as an example of how you could approach this.\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)\n\nMore complex:\n\nWhat are some other ways a mask could created using the features of numpy?\n\n\nLook other numpy (np) functions e.g.\n\nmeshgrid() - link (or ogrid() - link)\nwhere() - link functions.\n\nLook at the more complex ways that numpy.array objects can be indexed - indexing multi-dimensional arrays\nConsider how values can be assigned to whole sections of an array directly.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1_solutions.html",
    "href": "10/exercises_part1_solutions.html",
    "title": "Answers",
    "section": "",
    "text": "Create a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n# ADD CODE HERE\nimport numpy as np\n\nn  = 100\ncircular_mask = np.zeros((n,n))\nx0, y0 = 40,50\nradius = 10\nrows, cols = np.indices(circular_mask.shape)\n\ncircular_mask = ((rows-y0)**2+(cols-x0)**2)&lt;=radius**2\n\n\n### UNCOMMENT THIS CODE TO PLOT YOUR MASK WHEN COMPLETED\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Circular Mask')\nax.imshow(circular_mask,cmap=\"bone\",origin=\"lower\") # Setting colourmap (cmap) and the position of 0,0 (origin) on the plot\n\n\n\n\n\n\n\n\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)\n\n\n# 10 by 20 rectangle from x0,y0\nLx = 10\nLy= 20\nmask = (rows-y0&gt;0) & (rows-y0&lt;Ly)  & (cols-x0&gt;0) & (cols-x0&lt;Lx)\nplt.imshow(mask,cmap=\"bone\",origin=\"lower\")",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 1"
    ]
  },
  {
    "objectID": "10/exercises_part1_solutions.html#pair-programming-part-1",
    "href": "10/exercises_part1_solutions.html#pair-programming-part-1",
    "title": "Answers",
    "section": "",
    "text": "Create a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n# ADD CODE HERE\nimport numpy as np\n\nn  = 100\ncircular_mask = np.zeros((n,n))\nx0, y0 = 40,50\nradius = 10\nrows, cols = np.indices(circular_mask.shape)\n\ncircular_mask = ((rows-y0)**2+(cols-x0)**2)&lt;=radius**2\n\n\n### UNCOMMENT THIS CODE TO PLOT YOUR MASK WHEN COMPLETED\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Circular Mask')\nax.imshow(circular_mask,cmap=\"bone\",origin=\"lower\") # Setting colourmap (cmap) and the position of 0,0 (origin) on the plot\n\n\n\n\n\n\n\n\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)\n\n\n# 10 by 20 rectangle from x0,y0\nLx = 10\nLy= 20\nmask = (rows-y0&gt;0) & (rows-y0&lt;Ly)  & (cols-x0&gt;0) & (cols-x0&lt;Lx)\nplt.imshow(mask,cmap=\"bone\",origin=\"lower\")",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 1"
    ]
  },
  {
    "objectID": "10/hint1_mask.html",
    "href": "10/hint1_mask.html",
    "title": "Hint 1 - creating a square mask",
    "section": "",
    "text": "Example: Creating a 100 x 100 grid containing a square where the centre of that square is at (80, 40) and the width is 30.\nTo check whether an (x, y) position is within the square we want to define, we want to evaluate if these two conditions are both satisfied: \\[|x - x_0| = w/2\\] and \\[|y - y_0| = w/2\\]\nwhere - \\(x\\), \\(y\\) are the x, y positions within the grid - \\(x_0\\), \\(y_0\\) are the centre of the square - \\(w\\) - is both the full width and height of the square - \\(| |\\) means the magnitude of the difference\nThis code will show one way to create a mask which contains a square. This will take the most direct approach and evaluate every index in the 2D array one at a time.\n\nimport numpy as np\n\nshape = (100, 100)\n\nStart by creating an array of zeros for our overall grid:\n\nsquare_mask = np.zeros(shape)\nprint(square_mask)\n\n[[0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n ...\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]]\n\n\nNext we can define the parameters we need for the square:\n\ncentre = (80, 40) # Centre (x, y)\nwidth = 30 # Width of square\n\nSo, to check whether a given position is within our mask (the square we are defining), we need to find a way to use our equations above and write them in code.\nWe’ve created a grid of size of 100 x 100 so, as an example, let’s use the position (50, 50) for our grid:\n\nx = 50\ny = 50\n\nx0 = centre[0] # Define central x position for the square\ny0 = centre[1] # Define central y position for the square\n\n# Edge of square\n# |x - x0| = width/2\n# |y - y0| = width/2\n\ndistance_x = np.abs(x - x0) # Magnitude of distance - x-x0\ndistance_y = np.abs(y - y0) # Magnitude of distance - y-y0\n\n# Use our conditions to check whether this (y, x) position is inside the square\nif distance_x &lt; width/2 and distance_y &lt; width/2:\n    print(\"Position is inside the mask\")\n    square_mask[y, x] = 1 # Using our index values, set to value within our array to 1 if this is inside the square\nelse:\n    print(\"Position is not inside the mask\")\n\nPosition is not inside the mask\n\n\nNow we can build this up to look at every element in the 2D array we have created and check whether this is inside the square (we will leave the value as 0) or outside the square (we will set the value to 1). To do this we can loop through every column and every row and check the result of our conditions:\n\nx0 = centre[0]\ny0 = centre[1]\n\nncol = shape[0]\nnrow = shape[1]\n\nfor y in range(nrow): # iterate over first dimension\n    for x in range(ncol): # iterate over second dimension\n        \n        distance_x = np.abs(x - x0) # Magnitude of distance\n        distance_y = np.abs(y - y0) # Magnitude of distance\n        \n        # Check whether each position is inside the square\n        if distance_x &lt; width/2 and distance_y &lt; width/2:\n            square_mask[y, x] = 1 # Set to 1 if inside the square\n\nWe don’t need an else block here because the array we have defined already contains zeros. This means if our conditin doesn’t match we don’t need to update the values within the array.\nWe could check where our mask has been set to 1 using the np.where function. For a two-dimensional array like square_mask, this will return two arrays containing the positions of the match - one for the first dimension and one for the second dimension.\nEach pair of values (one in the first array and one the second) represents a 2D position in our array:\n\n# Where have we created our mask in our overall grid\nnp.where(square_mask == 1)\n\n(array([26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n        26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27,\n        27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n        27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n        28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n        28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n        29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30,\n        30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n        30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31,\n        31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n        31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33,\n        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,\n        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34,\n        34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n        34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n        35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n        35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n        36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37,\n        37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,\n        37, 37, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n        38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n        38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,\n        39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40,\n        40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n        40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 41, 41,\n        41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,\n        41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,\n        42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,\n        43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n        43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44,\n        44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n        44, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n        45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n        45, 45, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,\n        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 47, 47, 47,\n        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,\n        47, 47, 47, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 48, 48, 48,\n        48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n        48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\n        49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 50,\n        50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n        50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51,\n        51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,\n        51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n        52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n        52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53,\n        53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54,\n        54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,\n        54, 54, 54, 54, 54, 54, 54, 54]),\n array([66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,\n        83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\n        88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,\n        76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92,\n        93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n        81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68,\n        69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\n        86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73,\n        74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,\n        91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,\n        79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66,\n        67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\n        84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71,\n        72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,\n        89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\n        77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,\n        82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69,\n        70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,\n        87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74,\n        75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,\n        92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67,\n        68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\n        85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72,\n        73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n        90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,\n        78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,\n        66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,\n        83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\n        88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,\n        76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92,\n        93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n        81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68,\n        69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\n        86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73,\n        74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,\n        91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,\n        79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66,\n        67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\n        84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71,\n        72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,\n        89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\n        77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,\n        82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69,\n        70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,\n        87, 88, 89, 90, 91, 92, 93, 94]))\n\n\nWe can look at this mask using matplotlib and a plotting option called imshow (documentation; example from image gallery):\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Square Mask')\nax.imshow(square_mask,cmap=\"bone\",origin=\"lower\")\n\n\n\n\n\n\n\n\nIn this plot, the white represents the values in the mask (values of 1) and the black represents the values outside the mask (values of 0).\n\n\nExtended: Leveraging numpy functionality\nAn alternative and more efficient way to do this would be to leverage the properties of numpy arrays and the available numpy functions and indexing.\nWe can start in the same way and create our array of zeros of the right shape\n\nsquare_mask_2 = np.zeros(shape)\n\nWe can represent the pixel position for our x and y dimensions using numbers for 0 to 99 (for x) and 0 to 99 (for y) since our shape is 100 x 100.\nWe can then create a pair of 2D grids, X and Y, to match to the shape of our mask using a function called np.meshgrid(). This stretches our x and y coordinate values to create our 2D numpy arrays.\n\n# Create arrays matching to our size along our x and y axes\nx = np.arange(shape[1])\ny = np.arange(shape[0])\n\nX, Y = np.meshgrid(x, y)\n\nprint(f\"X array: {X.shape}\")\nprint(X)\nprint(f\"Y array: {Y.shape}\")\nprint(Y)\n\nX array: (100, 100)\n[[ 0  1  2 ... 97 98 99]\n [ 0  1  2 ... 97 98 99]\n [ 0  1  2 ... 97 98 99]\n ...\n [ 0  1  2 ... 97 98 99]\n [ 0  1  2 ... 97 98 99]\n [ 0  1  2 ... 97 98 99]]\nY array: (100, 100)\n[[ 0  0  0 ...  0  0  0]\n [ 1  1  1 ...  1  1  1]\n [ 2  2  2 ...  2  2  2]\n ...\n [97 97 97 ... 97 97 97]\n [98 98 98 ... 98 98 98]\n [99 99 99 ... 99 99 99]]\n\n\nWe can find the positions where our conditions are met within our grid using the np.where() function. From here we can filter our mask using integer array indexing and change these values from 0 to 1 within our mask.\n\n# We can calculate the x and y distances for each value in our 2D grids\ndistance_x = np.abs(X - x0) # Magnitude of distance\ndistance_y = np.abs(Y - y0) # Magnitude of distance\n\n# We can use the numpy where function to find the positions where our conditions are matched\n# - to include multiple conditions we have included an & (known as a bitwise operator)\nindices = np.where((distance_x &lt; width/2) & (distance_y &lt; width/2))\n\n# And using these indices change the values to 1\nsquare_mask_2[indices] = 1\n\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Square Mask (alternative method)')\nax.imshow(square_mask_2,cmap=\"bone\",origin=\"lower\")",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Hint 1 - creating a square mask"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Coding and Data Analysis",
    "section": "",
    "text": "This is the course material for *Introduction to coding and data analysis”, SCIF10002.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#welcome-to-the-course",
    "href": "index.html#welcome-to-the-course",
    "title": "Introduction to Coding and Data Analysis",
    "section": "",
    "text": "This is the course material for *Introduction to coding and data analysis”, SCIF10002.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Introduction to Coding and Data Analysis",
    "section": "How to use",
    "text": "How to use\n\nYou will find the more theoretical introduction undr Lesson\nThe hands-on exercises will be under Exercises\nOver the course of the weeeks the solutions will be released under Solution\n\n**Importnant*. You can use the",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#course-material",
    "href": "index.html#course-material",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Course material",
    "text": "Course material",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Getting Started",
    "text": "Getting Started\nNavigate through the course using the sidebar or the navigation menu above. Each Week builds upon the previous one, so it’s recommended to work through them in order.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Features",
    "text": "Features\n\nInteractive Jupyter notebooks\nStep-by-step exercises with solutions\nComprehensive coverage of NumPy and Matplotlib\nReal-world examples and applications",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#file-system-navigation",
    "href": "slides/11_beyond_notebook_slides.html#file-system-navigation",
    "title": "Beyond the Notebook",
    "section": "File System Navigation",
    "text": "File System Navigation\nNotebooks exist in directories - we can navigate using bash commands\nKey commands (use ! prefix in notebooks):\n# Current directory location\n! pwd\n\n# List files and directories\n! ls\n\n# Create new directory\n! mkdir new_folder\n\n# Change directory\n! cd new_folder\n! cd ..  # Go back to parent directory"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#working-with-files",
    "href": "slides/11_beyond_notebook_slides.html#working-with-files",
    "title": "Beyond the Notebook",
    "section": "Working with Files",
    "text": "Working with Files\nCreating and viewing files:\n# Create empty file\n! touch filename.txt\n\n# View file contents\n! cat filename.txt\n\n# View first/last lines\n! head filename.txt\n! tail filename.txt\nFile system navigation: - . = current directory - .. = parent directory - Paths can be absolute (/full/path) or relative (folder/file)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#python-scripts-vs-notebooks",
    "href": "slides/11_beyond_notebook_slides.html#python-scripts-vs-notebooks",
    "title": "Beyond the Notebook",
    "section": "Python Scripts vs Notebooks",
    "text": "Python Scripts vs Notebooks\nNotebooks (.ipynb): - Rich multimedia content - Markdown, images, metadata - Interactive development - Complex file format\nScripts (.py): - Pure Python code only - Comments with # - Simple text files - Portable and lightweight"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#running-scripts",
    "href": "slides/11_beyond_notebook_slides.html#running-scripts",
    "title": "Beyond the Notebook",
    "section": "Running Scripts",
    "text": "Running Scripts\nFrom notebook:\n# Using the 'run' magic command\nrun path/to/script.py\nFrom terminal:\n# Using python command\npython path/to/script.py\nExample script (hello.py):\nprint(\"Hello, World!\")\nx = 42\nprint(f\"The answer is {x}\")"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#the-terminal",
    "href": "slides/11_beyond_notebook_slides.html#the-terminal",
    "title": "Beyond the Notebook",
    "section": "The Terminal",
    "text": "The Terminal\nText-based interface to the operating system\nAccessing terminal: - In Noteable: New → Terminal - Pure command-line environment - No mouse interaction - Uses bash scripting language\nBasic terminal workflow: 1. Navigate to directory (cd) 2. Create/edit files (touch, text editor) 3. Run Python scripts (python script.py)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#creating-python-modules",
    "href": "slides/11_beyond_notebook_slides.html#creating-python-modules",
    "title": "Beyond the Notebook",
    "section": "Creating Python Modules",
    "text": "Creating Python Modules\nScripts can be imported as modules:\nStep 1: Create math_utils.py:\ndef add_numbers(a, b):\n    return a + b\n\ndef square(x):\n    return x ** 2\n\nPI = 3.14159\nStep 2: Import and use:\nimport math_utils as mu\n\nresult = mu.add_numbers(5, 3)\narea = mu.PI * mu.square(radius)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#practical-example-plotting-module",
    "href": "slides/11_beyond_notebook_slides.html#practical-example-plotting-module",
    "title": "Beyond the Notebook",
    "section": "Practical Example: Plotting Module",
    "text": "Practical Example: Plotting Module\nCreate plotting.py:\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plot_parabola(a, b, c, xlo=0, xhi=10, npoints=100):\n    x = np.linspace(xlo, xhi, npoints)\n    y = a * x**2 + b * x + c\n    \n    plt.figure()\n    plt.plot(x, y, 'b-', linewidth=2)\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.title(f'Parabola: y = {a}x² + {b}x + {c}')\n    plt.grid(True)\n    plt.show()"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#using-custom-modules",
    "href": "slides/11_beyond_notebook_slides.html#using-custom-modules",
    "title": "Beyond the Notebook",
    "section": "Using Custom Modules",
    "text": "Using Custom Modules\nImport your module:\nimport plotting as plt_mod\n\n# Use your custom function\nplt_mod.plot_parabola(a=1, b=-2, c=1)\nBenefits of modules: - Reusability: Use same code across projects - Organization: Separate concerns - Maintainability: Update code in one place - Collaboration: Share functionality"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#bash-command-options",
    "href": "slides/11_beyond_notebook_slides.html#bash-command-options",
    "title": "Beyond the Notebook",
    "section": "Bash Command Options",
    "text": "Bash Command Options\nCommands often have options using - syntax:\n# List files in long format\nls -l\n\n# List files in reverse time order\nls -lt\n\n# Get help for any command\ncommand_name --help\nCommon file operations:\n# Move/rename files\nmv old_name.py new_name.py\n\n# Copy files\ncp source.py destination.py\n\n# Remove files (careful!)\nrm filename.py"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#script-vs.-notebook-output",
    "href": "slides/11_beyond_notebook_slides.html#script-vs.-notebook-output",
    "title": "Beyond the Notebook",
    "section": "Script vs. Notebook Output",
    "text": "Script vs. Notebook Output\nNotebook execution: - Output appears inline - Variables remain in memory - Interactive environment\nScript execution: - Output goes to terminal/file - No persistent variables - One-time execution - For plots: use plt.savefig() instead of plt.show()"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#best-practices",
    "href": "slides/11_beyond_notebook_slides.html#best-practices",
    "title": "Beyond the Notebook",
    "section": "Best Practices",
    "text": "Best Practices\nWhen to use scripts: - Reusable functions - Production code - Automated tasks - Sharing with others\nWhen to use notebooks: - Exploratory analysis - Documentation with results - Teaching/presentations - Prototyping\nModule organization: - Group related functions - Clear, descriptive names - Add docstrings to functions"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#key-takeaways",
    "href": "slides/11_beyond_notebook_slides.html#key-takeaways",
    "title": "Beyond the Notebook",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nFile system navigation with bash commands\nScripts are portable, reusable Python code\nTerminal provides direct system access\nModules enable code organization and reuse\nChoose the right tool: notebooks for exploration, scripts for production\nPractice using both environments effectively\n\nNext steps: Start organizing your code into reusable modules!"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#introduction-to-matplotlib",
    "href": "slides/09_intro_matplotlib_slides.html#introduction-to-matplotlib",
    "title": "Plotting with matplotlib",
    "section": "Introduction to matplotlib",
    "text": "Introduction to matplotlib\nmatplotlib - Powerful Python library for creating visualizations\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nKey concepts: - Figure: The canvas - Axes: The x-y plotting area - Object-oriented approach (recommended)\n\nfig, ax = plt.subplots()  # Create figure and axes"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#two-plotting-approaches",
    "href": "slides/09_intro_matplotlib_slides.html#two-plotting-approaches",
    "title": "Plotting with matplotlib",
    "section": "Two Plotting Approaches",
    "text": "Two Plotting Approaches\nPyplot (MATLAB-style):\nplt.plot(x, y)  # Direct plotting\nObject-oriented (Recommended):\n\nfig, ax = plt.subplots()\nax.plot(x, y)  # Plot using axes object\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 2\n      1 fig, ax = plt.subplots()\n----&gt; 2 ax.plot(x, y)  # Plot using axes object\n\nNameError: name 'x' is not defined\n\n\n\n\nWhy object-oriented? - More explicit control - Better for complex plots - Modern best practice"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#basic-plot-types",
    "href": "slides/09_intro_matplotlib_slides.html#basic-plot-types",
    "title": "Plotting with matplotlib",
    "section": "Basic Plot Types",
    "text": "Basic Plot Types\n\n# Sample data\nrng = np.random.default_rng(seed=124)\nx = np.arange(1, 20, 2)\ny1 = x**2\ny2 = x**2 + rng.normal(size=len(x))*50\n\nfig, ax = plt.subplots()\nax.plot(x, y1, label=\"Line plot\")        # Line plot\nax.scatter(x, y2, label=\"Scatter plot\")  # Scatter plot\nax.legend()"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#customizing-appearance",
    "href": "slides/09_intro_matplotlib_slides.html#customizing-appearance",
    "title": "Plotting with matplotlib",
    "section": "Customizing Appearance",
    "text": "Customizing Appearance\n\nfig, ax = plt.subplots(figsize=(8, 4))\n\n# Styling options\nax.plot(x, y1, color=\"slategrey\", linestyle=\"--\", linewidth=2)\nax.scatter(x, y2, color=\"indianred\", marker='+', s=60)\n\n# Labels and limits\nax.set_xlabel(\"X values\")\nax.set_ylabel(\"Y values\")\nax.set_xlim(0, 20)\nax.set_title(\"Customized Plot\")\n\nText(0.5, 1.0, 'Customized Plot')"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#common-style-options",
    "href": "slides/09_intro_matplotlib_slides.html#common-style-options",
    "title": "Plotting with matplotlib",
    "section": "Common Style Options",
    "text": "Common Style Options\nColors: Named colors, hex codes, RGB - color=\"red\", color=\"#FF0000\", color=(1,0,0)\nLine styles: - linestyle=\"-\" (solid), \"--\" (dashed), \":\" (dotted)\nMarkers: - marker=\"o\" (circle), \"+\" (plus), \"^\" (triangle)\nTransparency: - alpha=0.7 (70% opaque)"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#legends-and-annotations",
    "href": "slides/09_intro_matplotlib_slides.html#legends-and-annotations",
    "title": "Plotting with matplotlib",
    "section": "Legends and Annotations",
    "text": "Legends and Annotations\n\nfig, ax = plt.subplots()\n\nax.plot(x, y1, label=\"Fitted line\", color=\"blue\", linestyle=\"--\")\nax.scatter(x, y2, label=\"Measurements\", color=\"red\", marker='o')\n\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\") \nax.legend()  # Uses the label parameters\nax.set_title(\"Plot with Legend\")\n\nText(0.5, 1.0, 'Plot with Legend')"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#histograms",
    "href": "slides/09_intro_matplotlib_slides.html#histograms",
    "title": "Plotting with matplotlib",
    "section": "Histograms",
    "text": "Histograms\n\n# Generate random data\nrng = np.random.default_rng(seed=68)\ndata1 = rng.normal(0, 1, 5000)\ndata2 = rng.normal(1, 1.5, 1000)\n\nfig, ax = plt.subplots()\nbins = np.arange(-4, 6, 0.3)\n\nax.hist(data1, bins=bins, alpha=0.7, color=\"skyblue\", \n        density=True, label=\"Dataset 1\")\nax.hist(data2, bins=bins, alpha=0.7, color=\"orange\", \n        density=True, label=\"Dataset 2\")\n\nax.set_xlabel(\"Value\")\nax.set_ylabel(\"Density\")\nax.legend()"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#histogram-options",
    "href": "slides/09_intro_matplotlib_slides.html#histogram-options",
    "title": "Plotting with matplotlib",
    "section": "Histogram Options",
    "text": "Histogram Options\nKey parameters: - bins: Number or explicit bin edges - alpha: Transparency (0-1) - density: Normalize to show probability density - histtype: ‘bar’, ‘step’, ‘stepfilled’\n\nfig, ax = plt.subplots()\nax.hist(data1, bins=30, alpha=0.6, histtype='step', \n        color='purple', linewidth=2)\n\n(array([  1.,   0.,   1.,   5.,   6.,  24.,  38.,  56., 132., 135., 204.,\n        272., 376., 442., 452., 515., 502., 494., 393., 305., 229., 160.,\n        107.,  76.,  28.,  32.,   9.,   3.,   2.,   1.]),\n array([-4.01393721, -3.75715456, -3.50037191, -3.24358926, -2.9868066 ,\n        -2.73002395, -2.4732413 , -2.21645865, -1.95967599, -1.70289334,\n        -1.44611069, -1.18932804, -0.93254538, -0.67576273, -0.41898008,\n        -0.16219743,  0.09458523,  0.35136788,  0.60815053,  0.86493318,\n         1.12171584,  1.37849849,  1.63528114,  1.89206379,  2.14884645,\n         2.4056291 ,  2.66241175,  2.9191944 ,  3.17597706,  3.43275971,\n         3.68954236]),\n [&lt;matplotlib.patches.Polygon at 0x12ffb8e90&gt;])"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#multiple-plots-on-same-axes",
    "href": "slides/09_intro_matplotlib_slides.html#multiple-plots-on-same-axes",
    "title": "Plotting with matplotlib",
    "section": "Multiple Plots on Same Axes",
    "text": "Multiple Plots on Same Axes\n\nfig, ax = plt.subplots(figsize=(10, 5))\n\n# Multiple data series\nx_vals = np.linspace(0, 2*np.pi, 100)\ny1 = np.sin(x_vals)\ny2 = np.cos(x_vals)\ny3 = np.sin(2*x_vals)\n\nax.plot(x_vals, y1, label=\"sin(x)\")\nax.plot(x_vals, y2, label=\"cos(x)\", linestyle='--')\nax.scatter(x_vals[::10], y3[::10], label=\"sin(2x)\", marker='o')\n\nax.legend()\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\n\nText(0, 0.5, 'y')"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#anatomy-of-a-figure",
    "href": "slides/09_intro_matplotlib_slides.html#anatomy-of-a-figure",
    "title": "Plotting with matplotlib",
    "section": "Anatomy of a Figure",
    "text": "Anatomy of a Figure\n\nMatplotlib anatomy shows the components: Figure, Axes, Labels, Legend, Ticks, etc.Key components: - Figure: Overall container - Axes: Plot area with data - Axis labels: x/y descriptions\n- Ticks: Scale markers - Legend: Data series identification"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#figure-size-and-layout",
    "href": "slides/09_intro_matplotlib_slides.html#figure-size-and-layout",
    "title": "Plotting with matplotlib",
    "section": "Figure Size and Layout",
    "text": "Figure Size and Layout\n\n# Control figure size\nfig, ax = plt.subplots(figsize=(12, 6))\n\n# Multiple subplots (brief example)\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\nax1.plot([1, 2, 3], [1, 4, 2])\nax2.scatter([1, 2, 3], [2, 1, 3])\nax1.set_title(\"Plot 1\")\nax2.set_title(\"Plot 2\")\n\nText(0.5, 1.0, 'Plot 2')"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#best-practices",
    "href": "slides/09_intro_matplotlib_slides.html#best-practices",
    "title": "Plotting with matplotlib",
    "section": "Best Practices",
    "text": "Best Practices\n\nAlways label your axes\nUse legends for multiple data series\nChoose appropriate plot types for your data\nControl figure size for readability\nUse colors wisely - consider colorblind accessibility\nKeep it simple - don’t over-decorate\n\n\n# Good example\nfig, ax = plt.subplots(figsize=(8, 5))\nax.plot(x, y1, label=\"Data\")\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Amplitude (V)\")\nax.set_title(\"Signal vs Time\")\nax.legend()\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[11], line 3\n      1 # Good example\n      2 fig, ax = plt.subplots(figsize=(8, 5))\n----&gt; 3 ax.plot(x, y1, label=\"Data\")\n      4 ax.set_xlabel(\"Time (s)\")\n      5 ax.set_ylabel(\"Amplitude (V)\")\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/matplotlib/axes/_axes.py:1724, in Axes.plot(self, scalex, scaley, data, *args, **kwargs)\n   1481 \"\"\"\n   1482 Plot y versus x as lines and/or markers.\n   1483 \n   (...)   1721 (``'green'``) or hex strings (``'#008000'``).\n   1722 \"\"\"\n   1723 kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n-&gt; 1724 lines = [*self._get_lines(self, *args, data=data, **kwargs)]\n   1725 for line in lines:\n   1726     self.add_line(line)\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/matplotlib/axes/_base.py:303, in _process_plot_var_args.__call__(self, axes, data, *args, **kwargs)\n    301     this += args[0],\n    302     args = args[1:]\n--&gt; 303 yield from self._plot_args(\n    304     axes, this, kwargs, ambiguous_fmt_datakey=ambiguous_fmt_datakey)\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/matplotlib/axes/_base.py:499, in _process_plot_var_args._plot_args(self, axes, tup, kwargs, return_kwargs, ambiguous_fmt_datakey)\n    496     axes.yaxis.update_units(y)\n    498 if x.shape[0] != y.shape[0]:\n--&gt; 499     raise ValueError(f\"x and y must have same first dimension, but \"\n    500                      f\"have shapes {x.shape} and {y.shape}\")\n    501 if x.ndim &gt; 2 or y.ndim &gt; 2:\n    502     raise ValueError(f\"x and y can be no greater than 2D, but have \"\n    503                      f\"shapes {x.shape} and {y.shape}\")\n\nValueError: x and y must have same first dimension, but have shapes (10,) and (100,)"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#key-takeaways",
    "href": "slides/09_intro_matplotlib_slides.html#key-takeaways",
    "title": "Plotting with matplotlib",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nmatplotlib is the standard Python plotting library\nObject-oriented approach with fig, ax is recommended\nCustomization options for colors, styles, markers\nMultiple plot types: line, scatter, histogram\nAlways annotate with labels, legends, titles\nPractice with different plot types and styling options"
  },
  {
    "objectID": "07/exercises_numpy.html",
    "href": "07/exercises_numpy.html",
    "title": "numpy Exercises",
    "section": "",
    "text": "These exercises test your understanding of the NumPy concepts covered in the introduction notebook.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-1-import-and-basic-array-creation",
    "href": "07/exercises_numpy.html#exercise-1-import-and-basic-array-creation",
    "title": "numpy Exercises",
    "section": "Exercise 1: Import and Basic Array Creation",
    "text": "Exercise 1: Import and Basic Array Creation\nTask: Import NumPy with the standard import command and create a NumPy array from the list [2, 4, 6, 8, 10, 12]. Print the array, its data type, and its shape.\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-2-array-indexing-and-slicing",
    "href": "07/exercises_numpy.html#exercise-2-array-indexing-and-slicing",
    "title": "numpy Exercises",
    "section": "Exercise 2: Array Indexing and Slicing",
    "text": "Exercise 2: Array Indexing and Slicing\nTask: Using the array you created in Exercise 1:\n\nPrint the first element\nPrint the last element\nPrint elements from index 2 to 4 (inclusive of 2, exclusive of 5)\nPrint every second element\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-3-element-wise-operations",
    "href": "07/exercises_numpy.html#exercise-3-element-wise-operations",
    "title": "numpy Exercises",
    "section": "Exercise 3: Element-wise Operations",
    "text": "Exercise 3: Element-wise Operations\nTask: Create a NumPy array arr = np.array([1, 4, 9, 16, 25]). Perform the following operations and print the results:\n\nMultiply each element by 3\nAdd 10 to each element\nCalculate the square root of each element\nApply the sine function to each element\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-4-array-operations-with-two-arrays",
    "href": "07/exercises_numpy.html#exercise-4-array-operations-with-two-arrays",
    "title": "numpy Exercises",
    "section": "Exercise 4: Array Operations with Two Arrays",
    "text": "Exercise 4: Array Operations with Two Arrays\nTask: Create two NumPy arrays:\n\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([10, 20, 30, 40, 50])\n\nPerform element-wise operations and print the results:\n\nAdd the two arrays\nSubtract arr1 from arr2\nMultiply the two arrays\nDivide arr2 by arr1\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-5-shape-mismatch-error",
    "href": "07/exercises_numpy.html#exercise-5-shape-mismatch-error",
    "title": "numpy Exercises",
    "section": "Exercise 5: Shape Mismatch Error",
    "text": "Exercise 5: Shape Mismatch Error\nTask: Create two arrays with different lengths:\n\narr_a = np.array([1, 2, 3, 4])\narr_b = np.array([10, 20])\n\nTry to add these arrays together. What happens? Write the code and explain the error in a comment.\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-6-reductive-operations",
    "href": "07/exercises_numpy.html#exercise-6-reductive-operations",
    "title": "numpy Exercises",
    "section": "Exercise 6: Reductive Operations",
    "text": "Exercise 6: Reductive Operations\nTask: Create a NumPy array data = np.array([12, 8, 15, 3, 7, 20, 11, 9]). Calculate and print:\n\nThe sum of all elements\nThe mean (average) of all elements\nThe maximum value\nThe minimum value\nThe standard deviation\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-7-array-manipulation",
    "href": "07/exercises_numpy.html#exercise-7-array-manipulation",
    "title": "numpy Exercises",
    "section": "Exercise 7: Array Manipulation",
    "text": "Exercise 7: Array Manipulation\nTask: Create a NumPy array numbers = np.array([5, 2, 8, 1, 9, 3]). Perform the following operations:\n\nSort the array and print the result\nCalculate the cumulative sum and print the result\nCreate a new array with duplicates: with_duplicates = np.array([5, 2, 8, 1, 9, 3, 5, 2, 1]) and find the unique elements\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-8-list-vs-numpy-comparison",
    "href": "07/exercises_numpy.html#exercise-8-list-vs-numpy-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 8: List vs NumPy Comparison",
    "text": "Exercise 8: List vs NumPy Comparison\nTask: Compare the flexibility of lists vs NumPy arrays:\n\nCreate a Python list containing mixed data types: mixed_list = [1, 'hello', 3.14, True]\nTry to create a NumPy array from this list. What happens to the data types?\nCreate a list of numbers: num_list = [1, 2, 3, 4, 5]\nTry to multiply the entire list by 2 using num_list * 2. What happens?\nCreate a NumPy array from the same numbers and multiply by 2. Compare the results.\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-9-performance-comparison",
    "href": "07/exercises_numpy.html#exercise-9-performance-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 9: Performance Comparison",
    "text": "Exercise 9: Performance Comparison\nTask: Compare the performance of list comprehension vs NumPy operations:\n\nImport the time module\nCreate a range of 50,000 numbers using numpy np.arange()\nTime how long it takes to square each number using a list comprehension, i.e. the syntax [x**2 for x in myarray]\nTime how long it takes to square each number using NumPy operations\nCalculate and print how many times faster the NumPy operation is\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-10-complex-operations",
    "href": "07/exercises_numpy.html#exercise-10-complex-operations",
    "title": "numpy Exercises",
    "section": "Exercise 10: Complex Operations",
    "text": "Exercise 10: Complex Operations\nTask: Create a NumPy array representing angles in degrees: angles_deg = np.array([0, 30, 45, 60, 90, 120, 180]) 1. Convert these angles to radians (hint: multiply by π/180, use np.pi) 2. Calculate the sine and cosine of each angle 3. Verify that sin²(x) + cos²(x) = 1 for each angle (use np.sin() and np.cos()) 4. Print all results\n\n# Your code here\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-1-temperature-conversion",
    "href": "07/exercises_numpy.html#challenge-1-temperature-conversion",
    "title": "numpy Exercises",
    "section": "Challenge 1: Temperature Conversion",
    "text": "Challenge 1: Temperature Conversion\nTask: You have temperature readings in Celsius: celsius_temps = np.array([0, 10, 20, 25, 30, 35, 40])\n\nConvert all temperatures to Fahrenheit using the formula: F = (C × 9/5) + 32\nConvert all temperatures to Kelvin using the formula: K = C + 273.15\nCalculate the temperature range (max - min) for each scale\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-2-kinetic-energy",
    "href": "07/exercises_numpy.html#challenge-2-kinetic-energy",
    "title": "numpy Exercises",
    "section": "Challenge 2: Kinetic energy",
    "text": "Challenge 2: Kinetic energy\nTask Given arrays of mass (kg) and velocity (m/s) for several objects:\n# copy and paste this code below\nmasses = np.array([2.0, 1.5, 3.0, 0.5])      # in kilograms\nvelocities = np.array([10.0, 20.0, 15.0, 5.0]) # in meters per second\n\nCalculate the kinetic energy \\(K\\) for each object using the formula:\n\n\\[K =  \\dfrac{1}{2}m v^2\\]\n\nCalculate the total kinetic energy of the system (sum of all objects)\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-3-temperature-analysis",
    "href": "07/exercises_numpy.html#challenge-3-temperature-analysis",
    "title": "numpy Exercises",
    "section": "Challenge 3: Temperature Analysis",
    "text": "Challenge 3: Temperature Analysis\nTask: Given a NumPy array of daily temperatures for 30 days:\ntemperatures = np.array([23.5, 24.0, 21.2, 25.6, 22.8, 23.9, 26.1, 27.3, 21.7, 22.5,\n                         24.6, 25.8, 20.9, 22.3, 24.7, 26.0, 27.5, 21.0, 22.9, 24.8,\n                         25.9, 27.6, 20.8, 22.7, 24.5, 26.2, 27.7, 20.5, 22.6, 24.9])\nPerform the following tasks:\n\nFind the top 3 hottest days and their temperatures.\nCalculate the day-to-day percentage change in temperature.\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html",
    "href": "07/lecture_intro_numpy.html",
    "title": "The numpy module",
    "section": "",
    "text": "A collection of many functions is called a module. One of the most useful modules in Python is called numpy (numerical Python) – it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we’ve been focussing on so far but now comes as standard in most Python installations.\nThe numpy module builds on the core functionality but also adds additional features including:\n\nIt is performant which means it is well optimised\nIt offers additional numerical computing tools\nIt adds an additional object called an n-dimensional array\n\n\n\nOne thing we can use the numpy module for is to create a new object called a numpy array. This is another data structure, in addition to the in-built Python types we’ve been learning about, and is similiar to a list.\n\n\n\nNumpy arrays\n\nNumpy module (and arrays) are a Python extension (but often come as standard)  Ordered  Mutable  Less flexible - One data type per array  Allows implicit element-wise operations  Generally quicker (optimised) More memory efficient\n\nLists\n\nLists are part of Python in-built functionality  Ordered  Mutable  Very flexible - All types in any list  Needs explicit element-wise operations  Generally slower performance Less memory efficient\n\n\nWhen using these objects, list objects are highly flexible, in both content and shape whereas numpy.array objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n\n\nnumpy.array objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\nTo use the numpy module we first need to import it.\nThe as part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case np. This is the convention most often used for the numpy module. import statements themselves are the way we access additional Python modules such as numpy or matplotlib.\nOne way to create a numpy.array is from a list:\nwhere we need the np. at the start of the function to tell python to access the numpy module.\nWe can also index and slice numpy.arrays in a similar way to other iterable objects (i.e. objects with length like lists):\n\n\n1.0\n[2. 3. 5.]\n\n\nAnd a numpy.array has an additional properties (attributes) called dtype which tells us what is contained within the array and shape which tells us the dimensions of the array.\n\n\nfloat64\n(6,)\n\n\n\n\n\nThe numpy module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we’ve shown before one way to act on every item in a list using a for loop:\n\n\n[4.0, 4.0, 8.0, 12.0, 20.0, 32.0]\n\n\nThere is actually a short hand for creating a new list using a for loop for very simple operations called a list comprehension.\n\n\n[4.0, 4.0, 8.0, 12.0, 20.0, 32.0]\n\n\nBut this is still more complex than using a numpy.array, where the same operation can be performed using an operator directly on the whole array:\n\n\n[ 4.  4.  8. 12. 20. 32.]\n\n\n\n\n\nFor large numbers of elements the time difference between operations using lists and numpy.arrays can start to be measurable. We can quickly check this my importing the time module:\nComparing the two operations we can see that performing this operation with the list takes longer than within a numpy.array (this is highly variable though):\n\n\nArray operation is 1 times faster for 100,000 numbers\n\n\nYou may recall, when we first introduced list and dict objects, we also mentioned other Python objects which were similar but with some differences in functionality (tuple and set objects). In Python, as in many languages, there are often many tools which can be used to complete a task and it’s up to you to choose the correct tool for the job. Overall, list objects may be more appropriate when you need to store a set of strings or if you don’t know the number of elements in advance (appending to a list is faster than appending to an numpy.array due to the way the data is stored in memory). Whereas numpy.array objects would be more appropriate when performance is a factor or for simpler numerical operations.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#what-is-the-numpy-module",
    "href": "07/lecture_intro_numpy.html#what-is-the-numpy-module",
    "title": "The numpy module",
    "section": "",
    "text": "A collection of many functions is called a module. One of the most useful modules in Python is called numpy (numerical Python) – it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we’ve been focussing on so far but now comes as standard in most Python installations.\nThe numpy module builds on the core functionality but also adds additional features including:\n\nIt is performant which means it is well optimised\nIt offers additional numerical computing tools\nIt adds an additional object called an n-dimensional array\n\n\n\nOne thing we can use the numpy module for is to create a new object called a numpy array. This is another data structure, in addition to the in-built Python types we’ve been learning about, and is similiar to a list.\n\n\n\nNumpy arrays\n\nNumpy module (and arrays) are a Python extension (but often come as standard)  Ordered  Mutable  Less flexible - One data type per array  Allows implicit element-wise operations  Generally quicker (optimised) More memory efficient\n\nLists\n\nLists are part of Python in-built functionality  Ordered  Mutable  Very flexible - All types in any list  Needs explicit element-wise operations  Generally slower performance Less memory efficient\n\n\nWhen using these objects, list objects are highly flexible, in both content and shape whereas numpy.array objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n\n\nnumpy.array objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\nTo use the numpy module we first need to import it.\nThe as part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case np. This is the convention most often used for the numpy module. import statements themselves are the way we access additional Python modules such as numpy or matplotlib.\nOne way to create a numpy.array is from a list:\nwhere we need the np. at the start of the function to tell python to access the numpy module.\nWe can also index and slice numpy.arrays in a similar way to other iterable objects (i.e. objects with length like lists):\n\n\n1.0\n[2. 3. 5.]\n\n\nAnd a numpy.array has an additional properties (attributes) called dtype which tells us what is contained within the array and shape which tells us the dimensions of the array.\n\n\nfloat64\n(6,)\n\n\n\n\n\nThe numpy module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we’ve shown before one way to act on every item in a list using a for loop:\n\n\n[4.0, 4.0, 8.0, 12.0, 20.0, 32.0]\n\n\nThere is actually a short hand for creating a new list using a for loop for very simple operations called a list comprehension.\n\n\n[4.0, 4.0, 8.0, 12.0, 20.0, 32.0]\n\n\nBut this is still more complex than using a numpy.array, where the same operation can be performed using an operator directly on the whole array:\n\n\n[ 4.  4.  8. 12. 20. 32.]\n\n\n\n\n\nFor large numbers of elements the time difference between operations using lists and numpy.arrays can start to be measurable. We can quickly check this my importing the time module:\nComparing the two operations we can see that performing this operation with the list takes longer than within a numpy.array (this is highly variable though):\n\n\nArray operation is 1 times faster for 100,000 numbers\n\n\nYou may recall, when we first introduced list and dict objects, we also mentioned other Python objects which were similar but with some differences in functionality (tuple and set objects). In Python, as in many languages, there are often many tools which can be used to complete a task and it’s up to you to choose the correct tool for the job. Overall, list objects may be more appropriate when you need to store a set of strings or if you don’t know the number of elements in advance (appending to a list is faster than appending to an numpy.array due to the way the data is stored in memory). Whereas numpy.array objects would be more appropriate when performance is a factor or for simpler numerical operations.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#working-with-numpy",
    "href": "07/lecture_intro_numpy.html#working-with-numpy",
    "title": "The numpy module",
    "section": "Working with numpy",
    "text": "Working with numpy\nTo use the numpy module we always need to start by using an import statement. In this case we import the numpy module and use the shorthand np:\nWe’ve seen that we can apply operators directly to a numpy.array:\n\n\narray([ 6.5,  6.5,  8. ,  9.5, 12.5, 17. ])\n\n\nSimilarly you can use additional functions provided by the numpy module to do something to each element in the array. For example you can apply a square root:\n\n\n[1.         1.         1.41421356 1.73205081 2.23606798 2.82842712]\n\n\nOr perform a reductive operation such as calculating the mean of all the elements:\n\n\n3.3333333333333335\n\n\nWe can also apply mathematical operations over the whole array. For instance we can look at the np.cos function which produces applies the cosine function element-wise:\nThe help states that this wants an array-like object and wants the input in radians. We can write this as:\n\n\n[ 0.54030231  0.54030231 -0.41614684 -0.9899925   0.28366219 -0.14550003]\n\n\nIf we look at arr1 we can see that this has not been updated by the application of these operations - when using this functionality a copy of the array is returned which you can choose to re-assign to the original variable name or create a new variable:\n\n\n[1. 1. 2. 3. 5. 8.]\n[ 6.5  6.5  8.   9.5 12.5 17. ]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#element-wise-operations-on-1d-arrays",
    "href": "07/lecture_intro_numpy.html#element-wise-operations-on-1d-arrays",
    "title": "The numpy module",
    "section": "Element-wise operations on 1D arrays",
    "text": "Element-wise operations on 1D arrays\nElement-wise operations in numpy allow you to perform arithmetic or mathematical functions on each corresponding element of arrays. For example, if you have two arrays of the same length, arr1 and arr2, you can add them directly: arr1 + arr2. This will produce a new array where each element is the sum of the elements at the same position in the original arrays. Similarly, you can use other operators (-, *, /) or numpy functions (np.sqrt(arr1), np.cos(arr1)) to apply operations to each element individually. The arrays must have compatible shapes for these operations.\n\n\n[ 7.5  7.5 10.  12.5 17.5 25. ]\n[-5.5 -5.5 -6.  -6.5 -7.5 -9. ]\n\n\n\n\nElement-wise multiplication: [  6.5   6.5  16.   28.5  62.5 136. ]\nElement-wise division: [0.15384615 0.15384615 0.25       0.31578947 0.4        0.47058824]\n\n\nWhen 1D arrays have different lengths, you need to be careful about the operations you perform. Element-wise operations: Operations such as arr1 + arr3 or arr1 * arr3 require arrays to have the same length or compatible shapes. If the lengths differ, numpy will raise a ValueError due to shape mismatch.\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[22], line 2\n      1 # This will raise a ValueError because arr1 and arr3 have different lengths\n----&gt; 2 result = arr1 + arr3\n\nNameError: name 'arr3' is not defined",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#basic-operations-on-1d-arrays",
    "href": "07/lecture_intro_numpy.html#basic-operations-on-1d-arrays",
    "title": "The numpy module",
    "section": "Basic operations on 1D arrays",
    "text": "Basic operations on 1D arrays\nSumming all elements in a 1D numpy array can be done with np.sum(arr1).\nFor cumulative summing, use np.cumsum(arr1), which returns an array where each element is the sum of all previous elements.\nSorting is performed with np.sort(arr1), which returns a sorted copy of the array.\nTo concatenate two arrays, use np.concatenate([arr1, arr2]). This joins the arrays end-to-end, creating a new array containing all elements from both arrays in order. Concatenation is useful for combining datasets or extending arrays.\nTo find unique elements, use np.unique(arr1), which returns an array of the distinct values in arr1. These operations are efficient and commonly used for data analysis.\n\n\nSum of arr1: 20.0\nCumulative sum of arr1: [ 1.  2.  4.  7. 12. 20.]\nSorted arr1: [1. 1. 2. 3. 5. 8.]\nCombined array: [ 1.   1.   2.   3.   5.   8.   6.5  6.5  8.   9.5 12.5 17. ]\nUnique elements in combined: [ 1.   2.   3.   5.   6.5  8.   9.5 12.5 17. ]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html",
    "href": "09/fun_matplotlib_decoration.html",
    "title": "Add some decoration",
    "section": "",
    "text": "There are two options below of template plots to build upon: a tree and a snowman.\nAs a group, decorate an image (or multiple images) and when completed you can save this figure to file (uncomment the appropriate cell to do so). This can then be downloaded from Noteable and uploaded to the Padlet with your group name:\nhttps://uob.padlet.org/fturci/adding-decorations-zk4khqfwj17l2377",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Add some decoration"
    ]
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html#decorate-a-tree",
    "href": "09/fun_matplotlib_decoration.html#decorate-a-tree",
    "title": "Add some decoration",
    "section": "Decorate a tree",
    "text": "Decorate a tree\nThe code below creates the outline of a tree which you can add your decoration to:\n\n### Code to create the template ###\n# Modify this code if you wish but this creates your background template\n\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nplt.rcdefaults()         # Set axes labels to be default style\nfig, ax = plt.subplots()\nplt.xkcd()               # Set xkcd (sketch style) for everything else\n\n## Define parameters for the tree\ntree_x = [1.0, 2.0, 3.0]\ntree_y = [1.0, 5.0, 1.0]\ntree_colour = \"green\"\n\ntree = list(zip(tree_x,tree_y)) # create [x,y] pairs for Polygon function\n\n## Define parameters for the tree trunk\ntrunk_x = [1.8, 1.8, 2.2, 2.2]\ntrunk_y = [0.0, 1.0, 1.0, 0.0]\ntrunk_colour = \"brown\"\n\ntrunk = list(zip(trunk_x,trunk_y)) # create [x,y] pairs for Polygon function\n\n## Plot the both aspects of the tree (using Polygon patches)\n# Set zorder to make sure any other features are on top of this\nt1 = plt.Polygon(tree, color=tree_colour,zorder=-1)\nax.add_patch(t1)\n\nt2 = plt.Polygon(trunk, color=trunk_colour,zorder=-2)\nax.add_patch(t2)\n\n## Limit the plotting area\nax.set_xlim([0,4])\nax.set_ylim([0,5.5])\n\n#### ADD ADDITIONAL FEATURES BELOW ####\n\n\n\n\n\n\n\n\n\n## To save the figure to file - uncomment the code below\n#fig.savefig(\"my_decorated_tree.png\")",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Add some decoration"
    ]
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html#decorate-a-snowman",
    "href": "09/fun_matplotlib_decoration.html#decorate-a-snowman",
    "title": "Add some decoration",
    "section": "Decorate a snowman",
    "text": "Decorate a snowman\nAs an alternative, the code below creates the outline of a snowman which you can add features to:\n\n### Code to create the template ###\n# Modify this code if you wish but this creates your background template\n\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nplt.rcdefaults()         # Set axes labels to be default style\nfig, ax = plt.subplots()\nplt.xkcd()               # Set xkcd (sketch style) for everything else\nax.set_aspect(\"equal\")   # Make x aspect = y aspect so circles are not squashed\n\nax.set_facecolor(\"xkcd:navy blue\") # Set colour of plotting area\n\n## Define details for the snowman\nsnowman_centre = [(2.0, 0.4), (2.0, 1.4), (2.0, 2.2)]\nsnowman_colour = \"white\"\nsnowman_radius = [0.6, 0.5, 0.4]\n\n## Plot the snowman (using Circle patches)\n# Set zorder to make sure any other features are on top of this\nt1 = plt.Circle(snowman_centre[0], snowman_radius[0], color=snowman_colour,zorder=-3)\nt2 = plt.Circle(snowman_centre[1], snowman_radius[1], color=snowman_colour,zorder=-2)\nt3 = plt.Circle(snowman_centre[2], snowman_radius[2], color=snowman_colour,zorder=-1)\n\nax.add_patch(t1)\nax.add_patch(t2)\nax.add_patch(t3)\n\n## Limit the plotting area\nax.set_xlim([0,4])\nax.set_ylim([0,4])\n\n#### ADD ADDITIONAL FEATURES BELOW ####\n\n\n\n\n\n\n\n\n\n## To save the figure to file - uncomment the code below\n#fig.savefig(\"my_decorated_snowman.png\")\n\n\n\nSome options in matplotlib\nHere are some examples of some matplotlib options and functionality that you could use:\n\n# Lines to set up the plot\nplt.rcdefaults()\nfig2, ax2 = plt.subplots()\nplt.xkcd()\n\n## You can add points using the `scatter(x, y)` function setting:\n## the colour (`color`), point size (`s`) and shape (`marker`)\nax2.scatter([2.0],[2.9],color=\"magenta\",marker=\"o\",s=30)\nax2.scatter([2.5, 1.5],[2.5, 2.5],color=\"red\",marker=\"*\",s=400)\n\n\n## Or you can add lines using the `plot(x, y)` function setting:\n## the colour (`color`), line width (`linewidth`) and line style (`linestyle`)\nax2.plot([1.2,2.8],[3.2,2.8],color=\"yellow\",linewidth=\"2\",linestyle=\"-\")\nax2.plot([1.2,2.8],[1.9,2.1],color=\"blue\",linewidth=\"10\",linestyle=\":\")\n\n\n## Or add a patch such as a rectangle (using `plt.Rectangle` definition)\n## or `plt.Polygon()` or `plt.Circle()` as defined in previous cells.\n# plt.Rectangle((x, y), width, height, angle, color=color)\nrectangle = plt.Rectangle((1.9,2.2), width=0.2, height=0.2, color=\"#660033\")\nax2.add_patch(rectangle)\n\n\n\n\n\n\n\n\n\n\nMore options\nColour options: - https://matplotlib.org/3.1.0/gallery/color/named_colors.html\nMarker and line style options: - https://matplotlib.org/stable/api/markers_api.html - https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html\nPatches (Rectangle, Circle, Polygon) - https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html - https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Polygon.html - https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Circle.html\nOr look in the matplotlib gallery to see if anything provides inspiration: - https://matplotlib.org/stable/gallery/index.html\n\nExtra Challenge: can you use random number generation to add detail to your picture?",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Add some decoration"
    ]
  },
  {
    "objectID": "09/exercises_plotting_data_from_file_solutions.html",
    "href": "09/exercises_plotting_data_from_file_solutions.html",
    "title": "Plotting data from file",
    "section": "",
    "text": "How can we use what we have learnt in the past few workshops to read data from a file? And how can we plot this?\nOne way to then plot this data would be to extract the index and/or multiple columns we are interested in plotting and use matplotlib as we have done before.\nAs an example, we’ll look at a new data file. This contains a simulation of the (fractional) concentration change for two species in a reaction, “A” and “B” where \\(A \\rightarrow B\\).\n\ndata_filename = \"data/FIRST ORDER_k=0.0005.txt\"\n\nIf we open this file more directly in Python when we looked at a text file) we can take quick look at the contents to see what this looks like:\n\nopen_file = open(data_filename)\ndata_from_file = open_file.read()\nprint(data_from_file[0:200])\n\nTime    A   B   \n0   1   0   \n100 0.950565    0.0494353   \n200 0.903573    0.0964268   \n300 0.858905    0.141095    \n400 0.816445    0.183555    \n500 0.776083    0.223917    \n600 0.737717    0.262283    \n700 0.701248    0.298752    \n800 0.666582    0.33341\n\n\nFrom printing out the first 200 characters, we can see this looks like a table of data with each column separated by spaces. This looks nicely formatted with a title row including the column names and no extra header rows.\nWe will see in the next year that there are dedicate packages to manipulate large tabulated files. However, for now we can exploit numpy as a quick and effective way to read such input.\n\nimport numpy as np\n\ndata_kinetic_k0005 = np.genfromtxt(\"data/FIRST ORDER_k=0.0005.txt\", names=True)\n\nThis is a special kind of array called a structured array, because it has named fields. You can check this by querying the subproperties of the array:\n\ndata_kinetic_k0005.dtype.names\n\n('Time', 'A', 'B')\n\n\nThese various names are the fields of the array, corresponding to the columns in the file. This syntax is reminiscent of what we have seen in the case of dictionaries, where keys are used to specific other objects stored in the dictionary.\n\ndata_kinetic_k0005['A']\n\narray([1.        , 0.950565  , 0.903573  , 0.858905  , 0.816445  ,\n       0.776083  , 0.737717  , 0.701248  , 0.666582  , 0.633629  ,\n       0.602305  , 0.57253   , 0.544227  , 0.517323  , 0.491749  ,\n       0.467439  , 0.444331  , 0.422365  , 0.401486  , 0.381638  ,\n       0.362772  , 0.344838  , 0.327791  , 0.311586  , 0.296183  ,\n       0.281541  , 0.267623  , 0.254393  , 0.241817  , 0.229863  ,\n       0.218499  , 0.207698  , 0.19743   , 0.18767   , 0.178393  ,\n       0.169574  , 0.161191  , 0.153222  , 0.145648  , 0.138447  ,\n       0.131603  , 0.125097  , 0.118913  , 0.113035  , 0.107447  ,\n       0.102135  , 0.097086  , 0.0922865 , 0.0877243 , 0.0833876 ,\n       0.0792653 , 0.0753468 , 0.071622  , 0.0680813 , 0.0647157 ,\n       0.0615165 , 0.0584754 , 0.0555846 , 0.0528368 , 0.0502248 ,\n       0.0477419 , 0.0453818 , 0.0431383 , 0.0410057 , 0.0389786 ,\n       0.0370517 , 0.03522   , 0.0334789 , 0.0318239 , 0.0302506 ,\n       0.0287552 , 0.0273337 , 0.0259824 , 0.024698  , 0.023477  ,\n       0.0223164 , 0.0212132 , 0.0201645 , 0.0191677 , 0.0182201 ,\n       0.0173194 , 0.0164632 , 0.0156493 , 0.0148757 , 0.0141403 ,\n       0.0134413 , 0.0127768 , 0.0121452 , 0.0115448 , 0.0109741 ,\n       0.0104316 , 0.00991587, 0.00942568, 0.00895972, 0.00851679,\n       0.00809576, 0.00769554, 0.00731511, 0.00695349, 0.00660974,\n       0.00628298])\n\n\nThis data also has a column for “Time” as the number of seconds elapsed.\n\ndata_kinetic_k0005 ['Time']\n\narray([    0.,   100.,   200.,   300.,   400.,   500.,   600.,   700.,\n         800.,   900.,  1000.,  1100.,  1200.,  1300.,  1400.,  1500.,\n        1600.,  1700.,  1800.,  1900.,  2000.,  2100.,  2200.,  2300.,\n        2400.,  2500.,  2600.,  2700.,  2800.,  2900.,  3000.,  3100.,\n        3200.,  3300.,  3400.,  3500.,  3600.,  3700.,  3800.,  3900.,\n        4000.,  4100.,  4200.,  4300.,  4400.,  4500.,  4600.,  4700.,\n        4800.,  4900.,  5000.,  5100.,  5200.,  5300.,  5400.,  5500.,\n        5600.,  5700.,  5800.,  5900.,  6000.,  6100.,  6200.,  6300.,\n        6400.,  6500.,  6600.,  6700.,  6800.,  6900.,  7000.,  7100.,\n        7200.,  7300.,  7400.,  7500.,  7600.,  7700.,  7800.,  7900.,\n        8000.,  8100.,  8200.,  8300.,  8400.,  8500.,  8600.,  8700.,\n        8800.,  8900.,  9000.,  9100.,  9200.,  9300.,  9400.,  9500.,\n        9600.,  9700.,  9800.,  9900., 10000.])\n\n\nTo create a plot for time vs concentration of A, we can extract this data from our array\n\n# Extract time and concentration of A from our array\ntime = data_kinetic_k0005['Time']\nconcentration_A = data_kinetic_k0005[\"A\"]\n\nWe could then use matplotlib to plot this:\n\nimport matplotlib.pyplot as plt\n\n# Create our Figure and Axes objects for plotting\nfig, ax = plt.subplots()\n\n# Plot our data - time vs concentration of A\nax.plot(time, concentration_A)\n\n# Add x and y labels for this data\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Concentration\")\n\nText(0, 0.5, 'Concentration')\n\n\n\n\n\n\n\n\n\nThis simulation shows a clean relationship as concentration decreases over time (in an exponential way).\nSuppose we want to filter our data and plot only concentrations less than 0.5. We can simply create a boolean array that masks the invalid data.\n\nmask = concentration_A &lt;= 0.5\nconcentration_A_low = concentration_A[mask]\n# Make sure to match the time values (index) to our filtered data\ntime_low = time[mask]\n\nHere we have filtered our data to include all fractional concentrations less than (or equal to) 0.5. Notice we have also matched our time values to plot to these concentrations by extracting the index from our new array concentration_A_low.\n\n# Create our Figure and Axes objects for plotting\nfig, ax = plt.subplots()\n\n# Plot our data - time vs concentration of A\nax.plot(time_low, concentration_A_low)\n\n# Note: Alternative syntax! we can set multiple properties at once\nax.set(xlabel = \"Time (s)\",  ylabel=\"Concentration\")\n\n\n\n\n\n\n\n\nYou can also see the slope is similiar (in fact it is the same) between our unfiltered and filtered data (this is due to the exponential relationship).\n\n\nExercise\n\nRe-plot the un-filtered graph created above and add another line to show concentration of B vs time from the data_kinetic_k0005 array on the same plot.\n\n\nCan you include a label for A and B?\n\n\n### ADD CODE HERE (copy code from above and add to this)\n\nfig, ax = plt.subplots()\n\nax.plot(time, concentration_A, label=\"A\")\nax.plot(time, data_kinetic_k0005[\"B\"], label=\"B\")\n\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Concentration\")\nax.legend()\n\n\n\n\n\n\n\n\n\nCalculate the the sum of the concentrations for these two columns (A and B).\n\n\n### ADD CODE HERE\n\nsum_concentration = concentration_A + data_kinetic_k0005[\"B\"]\nprint(sum_concentration)\n\n[1.         1.0000003  0.9999998  1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.0000005\n 1.0000003  0.9999996  1.0000003  0.9999998  1.         1.0000003\n 0.9999997  1.0000005  1.0000004  0.9999996  0.9999998  0.9999998\n 0.9999999  0.9999998  1.0000003  0.9999997  0.9999996  0.9999997\n 1.         0.9999999  0.9999999  0.9999996  1.0000002  0.9999997\n 1.0000004  1.         1.         1.0000004  1.0000002  0.9999995\n 0.9999997  1.0000001  1.0000004  1.0000002  1.0000003  0.9999997\n 1.0000003  1.0000003  0.9999998  1.0000002  0.9999998  1.0000001\n 0.9999996  0.99999987 0.99999968 0.99999972 0.99999979 0.99999976\n 0.99999954 1.00000011 1.00000049 0.99999974 0.99999998]\n\n\n\nRe-plot the graph created in the previous question and add this sum as a third line.\n\n\nConsider: What does this sum tell us about “A” is decaying into “B”?\n\n\n### ADD CODE HERE (copy code from previous question and add to this)\n\nfig, ax = plt.subplots()\n\nax.plot(time, concentration_A, label=\"A\")\nax.plot(time, data_kinetic_k0005[\"B\"], label=\"B\")\n\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Concentration\")\nax.plot(time, sum_concentration, label=\"A+B\")\nax.legend()\n\n\n\n\n\n\n\n\n\nWe add the sum of concentrations (A+B) as a third line to the plot. This sum remains very close to 1 throughout the reaction, indicating that as “A” decays, it is converted into “B” without significant loss or gain of total concentration. This demonstrates conservation of mass in the reaction: all of “A” is accounted for as it becomes “B”.",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Solutions"
    ]
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy_solutions.html",
    "href": "08/exercises_lecture_working_with_numpy_solutions.html",
    "title": "Exercises - Working with NumPy",
    "section": "",
    "text": "Create a 1D NumPy array arr of integers from 10 to 19. Access the element at index 3.\n\nimport numpy as np\narr = np.arange(10, 20)\narr[3]\n\n13",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy_solutions.html#exercise-9-problem-solving-with-numpy",
    "href": "08/exercises_lecture_working_with_numpy_solutions.html#exercise-9-problem-solving-with-numpy",
    "title": "Exercises - Working with NumPy",
    "section": "Exercise 9: Problem solving with NumPy",
    "text": "Exercise 9: Problem solving with NumPy\nConsider the following problem:\n\nA panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.\n\nThe problem is a two-dimensional problem. The passenger has coordinates \\(x(t), y(t)\\) and is performing uniform rotational motion, with angular velocity \\(\\omega\\) and radius \\(R\\).\nThe angle formed at which the passenger is located is \\(\\theta(t)\\) and simply evolves as\n\\[\\theta(t) = \\omega t +\\theta_0\\]\nwhere \\(\\theta_0\\) is the initial angle (\\(\\theta_0=0\\) in our case).\nHence, the trajectory is expressed by\n\\[\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n\\]\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\nThe first approach is via using vanilla Python\n\nimport math\nR = 10.0 #in metres\nomega = 2.0*2*math.pi/60. # in radians per second\nx0 = R # in metres\ny0 = 0 # in metres\ndt = 2.0 # in seconds\nduration = 20.0 #in seconds\nnum_iterations  = int(duration/dt)\nx, y = [], []\nt = 0\nfor _ in range(num_iterations):\n    x.append(R*math.cos(omega*t)+x0)\n    y.append(R*math.sin(omega*t)+y0)\n    t += dt \n\n# plotting, ignore the details for now sicne we will cover this in a later lecture\nimport matplotlib.pyplot as plt\nplt.scatter(x,y)\nplt.axis(\"equal\")\nplt.show()\n\n\n\n\n\n\n\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on avoiding for loops and using NumPy’s array operations instead.\n\n# solution\nimport numpy as np\nR = 10.0\n# numpy also contains all the useful mathematical constants\nomega = 2.0*2*np.pi/60.\ntheta0 = 0\ndt = 2.0\nduration = 20.0\n\n# using numpy arrays, the for loop is replaced by the creation of an array\nt = np.arange(0,duration,dt) \n# from the array t, we can generate any other array, for example  by multiplying by a scalar\ntheta = omega*t+theta0\n# now theta is another array, and we can apply a numpy function, such as np.cos\nx = R*np.cos(theta)\ny = R*np.sin(theta)\n\n# plotting, ignore the details for now\nimport matplotlib.pyplot as plt\nplt.scatter(x,y)\nplt.axis(\"equal\")\n\n(-10.77054980770496,\n 10.989073800366903,\n -6.669006096755103,\n 10.736372527513106)",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html",
    "href": "01/week_01_intro_to_data_types_beginner.html",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "Welcome to the Week 1 Beginner Python Notebook. This notebook is designed for students who are just starting out with the Python programming language.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are an important part of the learning process and will help you check your understanding.\n\nImportant: You have three options for today’s work: Beginner, Intermediate, or Advanced. If you are new to Python, please choose this Beginner notebook. You will have plenty of opportunities later in the course to explore the other levels.\n\nIn this notebook, you will be introduced to the numeric, boolean, and string Python data types. Gaining experience with these data types is essential, as they form the foundation for everything else you will learn in Python.\nBe sure to work through the examples and attempt all the exercises. They are designed to reinforce your learning and build your confidence.\n\n\n\nWelcome Page\nBeginner: Basic Data Types\n\nWhat are Data Types?\nIntegers and floats\nStrings\nBooleans\nCasting Between Data Types\nExercises\n\nIntermediate: Collections\nAdvanced: Copying and References\nSlides (Powerpoint)\n\n\n\n\nWriting code is a lot like writing a recipe for cooking. When writing a recipe, you might first list some ingredients, then give a careful sequence of steps, with the end result being some tasty and (hopefully!) digestible baked goods. Coding works the same way; we start with some inputs (the ingredients), ask the computer to perform a series of steps and produce some easy-to-digest result (the outputs).\nIn the same way that ingredients can be referred to as objects in the real-world, we refer to the data we use in coding as objects too.\nFurthermore, when cooking we might refer to objects by types of food. For instance, we may want to use 2 apples and an orange in a recipe, as opposed to 3 generic “food-objects”. Similarly, when coding we refer to types of data, or data types.\n\n\n\nIn Python there are many different data types with some of the most commonly used built-in data types being:\n\ninteger and floating point scalars\nboolean values\nstrings\ntuples\nlists\nsets\ndictionaries\n\n\nNote: This list is by no means comprehensive. Other data types are also supported through common packages (e.g., numpy, scipy, ...) and it is even possible to make your own custom datatypes! For now we will just focus on the built-in datatypes. However, packages such as numpy and pandas will be explored in later notebooks.\n\nThe “type” of a variable can be found using the type() function in python. Try changing and running the below code to see how this function is used.\n\na = 1\nb = 1.1e-6\nc = True\nd = 'word'\ne = (2,3)\nf = [1, 2, 3]\ng = {'key1' : '9', 'key2': 20}\n\ntype(a)\n\nint\n\n\nIn the above code, a, b, …, g are variables. A variable is a named reference to a piece of data, created using the = (assignment) operator. The type of a variable describes the kind of data it stores. For example, a stores an integer (a whole number), so its type is int.\n\nNote: Python allows for scientific notation for floats (decimal numbers). For example, in the above code 1.1e-6 means 1.1 times 10 to the minus 6.\n\nValues of variables can also be displayed with the print() function. If given many arguments, the print statement will print all of them. Try this below:\n\na = 0.01\nb = 'strrring'\nc = [1,2,3]\n\nprint(a)\nprint(a,b,c)\nprint(a,c)\n\n0.01\n0.01 strrring [1, 2, 3]\n0.01 [1, 2, 3]\n\n\nBy default, a Jupyter notebook will treat the last line of a code box as a print statement if it can.\n\n# Here is some arbitrary code\nd = 'another string'\n\n# The below line will print a, as it is the last line in this box\na\n\n0.01\n\n\n\n\n\nWhen first getting to grips with python, you can think of integers as “whole numbers” and floats as “numbers including decimals”. Integers are represented with the int datatype and floats are represented with the float datatype. Basic mathematical operations are available for int types and float types. Try a few below:\n\nWarning: A common mistake made by new users of Python is to use ^ for exponentiation (e.g. \\(2^5\\)). In fact, in Python ^ represents the logical XOR operator and the ** operator represents exponentiation. By performing your own research online, see if you can work out what the XOR function is doing here.\n\n\na = 3\nb = 2\n\n# Addition\nprint(a+b)\n\n# Subtraction\nprint(a-b)\n\n# Multiplication\nprint(a*b)\n\n# Exponentiation\nprint(a**b)\n\n# NOT EXPONENTIATION - ACTUALLY XOR\nprint(a^b)\n\n# Division\nprint(a/b)\n\n# Integer division (i.e. division with rounding down)\nprint(a//b)\n\n# Modulo\nprint(a % b)\n\n5\n1\n6\n9\n1\n1.5\n1\n1\n\n\nYou can combine operations using round brackets, ( and ), much in the same way you would in everyday math. For example:\n\nprint((a+b)/(b**2)+1/(3*a))\n\n1.3611111111111112\n\n\nOften, you may hear it mentioned that Python allows for arbitrary precision integers. This means that Python can accurately manipulate very large numbers stored as ints. For example;\n\na = 174129409583938905209834890385935802\nb = 417873297348327895798237589723987598\n\n# Both a and b are ints\nprint(type(a))\nprint(type(b))\n\n# You can check for yourself that this is correct!\nprint(a+b)\n\n&lt;class 'int'&gt;\n&lt;class 'int'&gt;\n592002706932266801008072480109923400\n\n\n\nWarning: Although ints can store arbitrary precision whole numbers in Python, floats cannot!! Failure to realize this can result in all sorts of strange errors. For example, consider the below;\n\n\n# Very big float\na = 1e30\n\n# Lets have a look at `a`\nprint(a)\nprint(type(a))\n\n# Now let's round `a` to the nearest whole number... this shouldn't change `a`... right?\nb = round(a)\n\n# Wrong... try repeating the above but with `a` as an integer (i.e. change the first line to `a=1000...00`)\nprint(b)\nprint(type(b))\n\n1e+30\n&lt;class 'float'&gt;\n1000000000000000019884624838656\n&lt;class 'int'&gt;\n\n\n\nCheck your understanding: What’s the difference between / and //? Why might 3 * 0.1 not equal 0.3 exactly in Python?\n\n\n\n\nIn this section we are going to look more at strings.\nA string is a finite sequence of characters (e.g., letters, numbers, symbols and punctuation marks). In python, strings can be specified with either double of single quotes like so:\n\nstring1 = 'This is a string'\nstring2 = \"This is also a string\"\nstring3 = \"\"\nstring4 = 'string3 is also a string!'\n\nprint(string1)\nprint(string2)\nprint(string3)\nprint(string4)\n\nThis is a string\nThis is also a string\n\nstring3 is also a string!\n\n\nAn important characteristic of each string is its length, which is the number of characters in it. The length can be any natural number (i.e., zero or any positive integer). In python we can see the length of a string by using the len() function. In fact, this function can be used to assess the length of many different variable types such as lists, tuples, sets and so on (more on those later).\n\nstring1 = 'loooooong string'\nstring2 = 'shor'\nstring3 = ''\n\n\nprint(len(string1))\nprint(len(string2))\nprint(len(string3))\n\n16\n4\n0\n\n\n\nBrief interlude: In Python, you can add comments to your code using the # symbol. Comments are lines of text that are ignored when the code runs, but they play an important role in explaining what your code is doing. Writing clear and meaningful comments as you code is considered best practice. It helps others (and your future self) understand your logic and what you are trying to do. Below is a simple example that shows how to use comments in Python. Make sure you are comfortable with this, as commenting is a crucial habit for anyone working with code.\n\n\n# The below line prints a string, this line is a comment\nprint('This statement is printed') # This is another comment\n\n# The below line is not a comment as the # is contained within quotes\ntext = \"# This is not a comment because it's inside quotes.\"\nprint(text)\n\nThis statement is printed\n# This is not a comment because it's inside quotes.\n\n\n\nCheck your understanding: What is the difference between print(2 + 3) and print(\"2\" + \"3\")? What happens if you try x = \"hello\" + 5? Using the below box, write some code to answer these questions.\n\n\n# Write your code here...\n\n\n\nPython has many useful tools for manipulating strings. One such function is the format function, which allows you to insert variables of different types into strings. Note that x in the below example does not need to be a string.\n\nx = 8\ny = 'John'\ns = \"{} is {} feet tall\".format(y, x)\nprint(s)\n\nJohn is 8 feet tall\n\n\nAnother useful tool is the concatenation operater; +. Concatenation in programming is another way for saying “join together”. See the below for an example of how this is done.\n\na = 'string1'\nb = 'string2'\nc = a + ' ' + b\n\nprint(c)\n\nstring1 string2\n\n\nIn fact, the previous example could be done using concatenation instead of the format funtion. Note though that we must be careful and convert x from an integer to a string, using str(), in this case.\n\nx = 8\ny = 'John'\n\nprint(y + ' is ' + str(x) + ' feet tall')\n\nJohn is 8 feet tall\n\n\nOther useful functions for string manipulation include\n\nstrip; which, by default, removes any white space from the beginning and end of a string. However, you can also specify which characters you wish to remove.\nsplit; splits a string by specified character (known as a seperator), and returns a list. By default, the separator is a space and this function splits a sentence into individual words.\nreplace; this returns a string with some specified value replaced with another specified value.\nupper; this makes a string all uppercase.\nlower; this makes a string all lowercase.\n\nSeveral examples are given below. Please make sure you understand what each of these functions does before moving on to the next section. There are many other functions available and a good resource for learning about each individual function and trying them for yourself is the w3 schools python reference site.\n\n# Demonstration of the strip function\nprint(\"Demonstration of strip function\\n\")\n\n\nx = '    this is a string     '\nprint(x)\nprint(x.strip())\ny = '...another string...'\nprint(y)\nprint(y.strip('.'))\n\n# -------------------------------------------------------------------\n# Demonstration of the split function\nprint(\"\\nDemonstration of split function\\n\")\n\n\nx = 'This is a string'\nprint(x)\nprint(x.split())\nprint(x.split('i'))\n\n# -------------------------------------------------------------------\n# Demonstration of the replace function\nprint(\"\\nDemonstration of replace function\\n\")\n\nx = 'I am not sure that I understand how the replace function works'\nprint(x)\ny = x.replace('am not sure', 'am totally sure')\nprint(y)\nz = y.replace('sure', 'sure, 100% sure in fact thanks to this (rather well put together) notebook,')\nprint(z)\n\n# -------------------------------------------------------------------\n# Demonstration of the upper and lower functions\nprint(\"\\nDemonstration of upper and lower functions\\n\")\n\nx = 'RaNDom CAseS'\nprint(x)\nprint(x.lower())\nprint(x.upper())\n\nDemonstration of strip function\n\n    this is a string     \nthis is a string\n...another string...\nanother string\n\nDemonstration of split function\n\nThis is a string\n['This', 'is', 'a', 'string']\n['Th', 's ', 's a str', 'ng']\n\nDemonstration of replace function\n\nI am not sure that I understand how the replace function works\nI am totally sure that I understand how the replace function works\nI am totally sure, 100% sure in fact thanks to this (rather well put together) notebook, that I understand how the replace function works\n\nDemonstration of upper and lower functions\n\nRaNDom CAseS\nrandom cases\nRANDOM CASES\n\n\n\n\n\n\nA boolean in python is a variable that can be either True or False. For instance:\n\n# Create a boolean variable \nmy_boolean = True\nprint(my_boolean)\n\nTrue\n\n\nBooleans arise in all sorts of situations. For example, consider the below code:\n\nprint(128 &gt; 100)\n\nTrue\n\n\nYou should see it print True, which makes sense as 128 is indeed larger than 100. Try changing the numbers above; can you make this print False?\nIn this code, the expression 128 &gt; 100 is a boolean statement. We can make this clearer like so:\n\nmy_boolean = 128 &gt; 100\nprint(my_boolean)\n\nTrue\n\n\nThe above code is identical to the previous, but we have now saved the True/False value as my_boolean.\nSome common boolean operators include:\n\nnot: This negates the value of a variable (i.e. turns True to False and False to True).\nand: This is a logical and.\nor: This is a logical or.\nis: This checks whether two variables point to the same object in memory.\n==: This checks whether two variables are equal in value (Note: This shouldn’t be confused for the assigment operator; =).\n!=: This checks whether two variables are not equal in value.\n\nBoolean operators in Python are designed to be intuitive and as close to natural language as possible. The below code demonstrates how the boolean operations and, or, == and != and not are used. Try changing the values of a and b to ensure you understand how these operations work.\n\na = True\nb = False\n\nprint(\"not a: \", not a)\nprint(\"a and b: \", a and b)\nprint(\"a or b: \", a or b)\nprint(\"a==b: \", a==b)\nprint(\"a!=b: \", a!=b)\n\n# Note: both c and b are treated as False, but they are not equal, see below;\nc = {}\nprint(\"not c: \", not c)\nprint(\"not b: \", not b)\nprint(\"b==c: \", b==c)\n\nnot a:  False\na and b:  False\na or b:  True\na==b:  False\na!=b:  True\nnot c:  True\nnot b:  True\nb==c:  False\n\n\nOther common relational expressions which give True/False output include &lt;=, &gt;=, &lt; and &gt; for numeric datatypes (e.g. ints and floats) and in for collection datatypes (such as lists or tuples, which we shall look at next).\n\na = 1\nb = 1.1\n\nprint(\"a&gt;b:    \", a&gt;b)\nprint(\"a&lt;b:    \", a&lt;b)\nprint(\"a&gt;=b:   \", a&gt;=b)\nprint(\"a&lt;=b:   \", a&lt;=b)\n\nc = \"Some string\"\nd = \"om\"\nprint(\"c in d: \", c in d)\nprint(\"d in c: \", d in c)\n\ne = 1\nf = 0.1\ng = [1,2,3]\nprint(\"e in g: \", e in g)\nprint(\"f in g: \", f in g)\n\na&gt;b:     False\na&lt;b:     True\na&gt;=b:    False\na&lt;=b:    True\nc in d:  False\nd in c:  True\ne in g:  True\nf in g:  False\n\n\n\n\n\nIn Python the data type of a variable is dynamic. This means that you do not need to specify the data type beforehand and that it can easily be changed. For example, try moving the type statement before and after the sum in the below block and see how the output is changed. Why does the output change?\n\na = 1\nb = 1.1\n\nprint(type(a))\n\na = a+b\n\n&lt;class 'int'&gt;\n\n\nSeveral inbuilt functions are available for converting between types. The most commonly used of these are the int, float and str functions. Try these out below. Caution: Note how converting z back to a float does not give the original value x. Why do you think this is?\n\nx = 1.1\ny = str(x)\nz = int(x)\n\nprint(x)\nprint(y)\nprint(z)\n\nprint(type(x))\nprint(type(y))\nprint(type(z))\n\nprint(x - float(z))\n\n1.1\n1.1\n1\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n&lt;class 'int'&gt;\n0.10000000000000009\n\n\nThe act of converting one data type to another is often referred to as casting. For instance, in the above code, we cast x from a float to a string and then from a string to an integer.\n\nCheck your Understanding: What happens if you try int(\"10.5\")? Why might you convert a number to a string using str()? Use the below code box to answer these questions.\n\n\n# Write your answers here...\n\n\n\n\nQuestion 1: Below are three variables x, y and z. By using the operators introduced in the Booleans section of this notebook, construct a boolean variable, my_boolean which is true if and only if \\(y\\) lies strictly between \\(x^2\\) and \\(z^3\\). That is, my_boolean should be true if and only if either \\(x^2&lt;y&lt;z^3\\) or \\(z^3&lt;y&lt;x^2\\).\n\n# Variables x, y and z\nx = 1\ny = 2\nz = 1.26\n\nmy_boolean = # Write your code here...\n\n\n  Cell In[24], line 6\n    my_boolean = # Write your code here...\n                 ^\nSyntaxError: invalid syntax\n\n\n\n\nQuestion 2: In the below code, we have two boolean variables; is_raining and have_umbrella. We will assume that these represent the sentences “It is raining outside” and “I have my umbrella with me”, respectively.\n\n# Boolean variables\nis_raining = True\nhave_umbrella = False\n\nWe will assume that you are going to get wet if and only if it is raining outside and you do not have your umbrella. Using logical operators (e.g. and, or, not…), make a new boolean variable that tells you if you are going to get wet.\n\n# Boolean telling you if you are going to get rained on\ngot_soaked = # Write your code here...\n\nprint('Question: Will I get rained on?')\nprint('Answer: ' + str(got_soaked))\n\n\n  Cell In[26], line 2\n    got_soaked = # Write your code here...\n                 ^\nSyntaxError: invalid syntax\n\n\n\n\nQuestion 3: In this question, we are interested in three boolean variables A, B and C. By performing your own research online, write down (on paper) a “Truth Table” for the expression (A and B) or (not C). Your table should have the following columns:\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\nA and B\nnot C\n(A and B) or (not C)\n\n\n\n\nTrue\nTrue\nTrue\n\n\n\n\n\nTrue\nTrue\nFalse\n\n\n\n\n\nTrue\nFalse\nTrue\n\n\n\n\n\nTrue\nFalse\nFalse\n\n\n\n\n\nFalse\nTrue\nTrue\n\n\n\n\n\nFalse\nTrue\nFalse\n\n\n\n\n\nFalse\nFalse\nTrue\n\n\n\n\n\nFalse\nFalse\nFalse\n\n\n\n\n\n\nIn the following box, write some code which computes (A and B) or (not C). By changing the values of A, B and C check the correctness of your truth table.\n\n# Boolean variables\nA = True\nB = False\nC = True\n\n# Compute new boolean\nmy_boolean = # Write your code here...\n\n\n  Cell In[27], line 7\n    my_boolean = # Write your code here...\n                 ^\nSyntaxError: invalid syntax\n\n\n\n\nQuestion 4: Below are two variables representing the width and height of a rectangle. Write some code that computes the area, perimeter and length of the diagonal of the rectangle. Your code should print the results.\n\n# Height and width variables\nheight = 10\nwidth = 3\n\n# Write your code here...\n\nQuestion 5: An object dropped from a height satisfies the SUVAT equations. In particular, it satisfies the following equation:\n\\[v^2 = u^2 + 2as\\]\nwhere - \\(v\\) is the final velocity, - \\(u\\) is the initial velocity, - \\(a\\) is the acceleration, equal to gravity in this case, - \\(s\\) is the distance.\nGiven the object is at rest initially and it’s final velocity is \\(10\\) meters per second, write code to compute the distance it has fallen.\n\n# Known variables\nv = 10\nu = # You must choose an appropriate value for this variable...\na = # You must choose an appropriate value for this variable...\n\n# Compute s\ns = # Write your code here.\n\n\n  Cell In[29], line 3\n    u = # You must choose an appropriate value for this variable...\n        ^\nSyntaxError: invalid syntax\n\n\n\n\nQuestion 6: Building on your answer to Question 5, by researching the SUVAT equations and writing code below, compute the time in seconds that the object spends in freefall.\n\n# Compute time using variables from Question 5\nt = # Write your answer here...\n\n\n  Cell In[30], line 2\n    t = # Write your answer here...\n        ^\nSyntaxError: invalid syntax\n\n\n\n\nQuestion 7: Without running code, predict the result of these, then check your answers in Python:\n\n(True and False) or True\nnot (False or False)\nTrue or False and False\nFalse ^ True\n(True and not True) and (False or not False)\n\n\n# Write your code here...\n\nHint: You may wish to look up Truthy and Falsy values.\nQuestion 8: The below code takes two numbers, x and y and computes \\(z=\\frac{x+y}{y^2}\\). For instance, when we set \\(x=1\\) and \\(y=5\\) we get \\(z=0.24\\).\n\n# Set the values of x and y\nx = 1\ny = 5\n\n# Add x and y together\nz = float(x + y)/float(y)**2\n\n# Print the result\nprint(z)\n\n0.24\n\n\nSuppose you were change the inputs, x and y, to 2 and 5. Work out by hand what you would expect \\(z\\) to equal.\nThe below code is the same as the above but the values of x and y have been changed. This time, something has gone wrong! z does not give the expected value. Explain what has happened and how you would fix it.\n\n# Set the values of x and y\nx = '2'\ny = '5'\n\n# Add x and y together\nz = float(x + y)/float(y)**2\n\n# Print the result\nprint(z)\n\n1.0\n\n\nQuestion 9: Explain why the first code box below prints nothing but the second prints True.\n\nthree = 2 + 1\n\n\n3 == 2 + 1\n\nTrue\n\n\nHint: Consider the below variable z. What is it’s datatype?\n\n# Set the vairable z.\nz = (3 == 2 + 1)\n\n# Print it's type\n# write your code here...\n\nGiven your answer to the above, you may expect the below code to also print True.\n\n0.3 == 0.1 + 0.2\n\nFalse\n\n\nHowever, it doesn’t! Why do you think this is?\nHint: Try printing (0.1 + 0.2) and 0.3 seperately. What do you notice?\nQuestion 10: In the code block below, you are given 12 strings:\n\none start_string\n\nten “helper” strings (string1 to string10)\n\none end_string\n\nYour task is to transform the start_string into the end_string using only:\n\nthe start_string\n\nthe helper strings (string1 … string10)\n\nthe .replace() function\n\nA complete solution can be given in 5 replacement steps. We’ve given you the first step to get you started.\nHint: You might not need all ten helper strings.\n\n# The string we want to transform\nstart_string = 'Thas as te arang we want!'\nprint('Start:  ', start_string)\n\n# Helper strings you can use for replacements\nstring1 = 'a'\nstring2 = 'st'\nstring3 = 'he a'\nstring4 = ' ge'\nstring5 = 'stri'\nstring6 = 'sts'\nstring7 = 'is'\nstring8 = 'ara'\nstring9 = 'gen'\nstring10 = 'e a'\n\n# Step 1 (given as an example)\nstep1 = start_string.replace(string1,string2)\nprint('Step 1: ',step1)\n\n# Step 2 (fill in the correct strings)\nstep2 = step1.replace(string_ , string_) # Fill in the underscores\nprint('Step 2: ', step2)\n\n# Step 3–5 (repeat the process until you reach the final string)\n\nprint('...')\n\n\n# Target string you should reach in 5 steps\nend_string = 'This is the string we want!'\nprint('End:    ', end_string)\n\nStart:   Thas as te arang we want!\nStep 1:  Thsts sts te strstng we wstnt!\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[38], line 22\n     19 print('Step 1: ',step1)\n     21 # Step 2 (fill in the correct strings)\n---&gt; 22 step2 = step1.replace(string_ , string_) # Fill in the underscores\n     23 print('Step 2: ', step2)\n     25 # Step 3–5 (repeat the process until you reach the final string)\n\nNameError: name 'string_' is not defined",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#what-are-data-types",
    "href": "01/week_01_intro_to_data_types_beginner.html#what-are-data-types",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "Writing code is a lot like writing a recipe for cooking. When writing a recipe, you might first list some ingredients, then give a careful sequence of steps, with the end result being some tasty and (hopefully!) digestible baked goods. Coding works the same way; we start with some inputs (the ingredients), ask the computer to perform a series of steps and produce some easy-to-digest result (the outputs).\nIn the same way that ingredients can be referred to as objects in the real-world, we refer to the data we use in coding as objects too.\nFurthermore, when cooking we might refer to objects by types of food. For instance, we may want to use 2 apples and an orange in a recipe, as opposed to 3 generic “food-objects”. Similarly, when coding we refer to types of data, or data types.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#basic-data-types",
    "href": "01/week_01_intro_to_data_types_beginner.html#basic-data-types",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "In Python there are many different data types with some of the most commonly used built-in data types being:\n\ninteger and floating point scalars\nboolean values\nstrings\ntuples\nlists\nsets\ndictionaries\n\n\nNote: This list is by no means comprehensive. Other data types are also supported through common packages (e.g., numpy, scipy, ...) and it is even possible to make your own custom datatypes! For now we will just focus on the built-in datatypes. However, packages such as numpy and pandas will be explored in later notebooks.\n\nThe “type” of a variable can be found using the type() function in python. Try changing and running the below code to see how this function is used.\n\na = 1\nb = 1.1e-6\nc = True\nd = 'word'\ne = (2,3)\nf = [1, 2, 3]\ng = {'key1' : '9', 'key2': 20}\n\ntype(a)\n\nint\n\n\nIn the above code, a, b, …, g are variables. A variable is a named reference to a piece of data, created using the = (assignment) operator. The type of a variable describes the kind of data it stores. For example, a stores an integer (a whole number), so its type is int.\n\nNote: Python allows for scientific notation for floats (decimal numbers). For example, in the above code 1.1e-6 means 1.1 times 10 to the minus 6.\n\nValues of variables can also be displayed with the print() function. If given many arguments, the print statement will print all of them. Try this below:\n\na = 0.01\nb = 'strrring'\nc = [1,2,3]\n\nprint(a)\nprint(a,b,c)\nprint(a,c)\n\n0.01\n0.01 strrring [1, 2, 3]\n0.01 [1, 2, 3]\n\n\nBy default, a Jupyter notebook will treat the last line of a code box as a print statement if it can.\n\n# Here is some arbitrary code\nd = 'another string'\n\n# The below line will print a, as it is the last line in this box\na\n\n0.01",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#integers-and-floats",
    "href": "01/week_01_intro_to_data_types_beginner.html#integers-and-floats",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "When first getting to grips with python, you can think of integers as “whole numbers” and floats as “numbers including decimals”. Integers are represented with the int datatype and floats are represented with the float datatype. Basic mathematical operations are available for int types and float types. Try a few below:\n\nWarning: A common mistake made by new users of Python is to use ^ for exponentiation (e.g. \\(2^5\\)). In fact, in Python ^ represents the logical XOR operator and the ** operator represents exponentiation. By performing your own research online, see if you can work out what the XOR function is doing here.\n\n\na = 3\nb = 2\n\n# Addition\nprint(a+b)\n\n# Subtraction\nprint(a-b)\n\n# Multiplication\nprint(a*b)\n\n# Exponentiation\nprint(a**b)\n\n# NOT EXPONENTIATION - ACTUALLY XOR\nprint(a^b)\n\n# Division\nprint(a/b)\n\n# Integer division (i.e. division with rounding down)\nprint(a//b)\n\n# Modulo\nprint(a % b)\n\n5\n1\n6\n9\n1\n1.5\n1\n1\n\n\nYou can combine operations using round brackets, ( and ), much in the same way you would in everyday math. For example:\n\nprint((a+b)/(b**2)+1/(3*a))\n\n1.3611111111111112\n\n\nOften, you may hear it mentioned that Python allows for arbitrary precision integers. This means that Python can accurately manipulate very large numbers stored as ints. For example;\n\na = 174129409583938905209834890385935802\nb = 417873297348327895798237589723987598\n\n# Both a and b are ints\nprint(type(a))\nprint(type(b))\n\n# You can check for yourself that this is correct!\nprint(a+b)\n\n&lt;class 'int'&gt;\n&lt;class 'int'&gt;\n592002706932266801008072480109923400\n\n\n\nWarning: Although ints can store arbitrary precision whole numbers in Python, floats cannot!! Failure to realize this can result in all sorts of strange errors. For example, consider the below;\n\n\n# Very big float\na = 1e30\n\n# Lets have a look at `a`\nprint(a)\nprint(type(a))\n\n# Now let's round `a` to the nearest whole number... this shouldn't change `a`... right?\nb = round(a)\n\n# Wrong... try repeating the above but with `a` as an integer (i.e. change the first line to `a=1000...00`)\nprint(b)\nprint(type(b))\n\n1e+30\n&lt;class 'float'&gt;\n1000000000000000019884624838656\n&lt;class 'int'&gt;\n\n\n\nCheck your understanding: What’s the difference between / and //? Why might 3 * 0.1 not equal 0.3 exactly in Python?",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#strings",
    "href": "01/week_01_intro_to_data_types_beginner.html#strings",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "In this section we are going to look more at strings.\nA string is a finite sequence of characters (e.g., letters, numbers, symbols and punctuation marks). In python, strings can be specified with either double of single quotes like so:\n\nstring1 = 'This is a string'\nstring2 = \"This is also a string\"\nstring3 = \"\"\nstring4 = 'string3 is also a string!'\n\nprint(string1)\nprint(string2)\nprint(string3)\nprint(string4)\n\nThis is a string\nThis is also a string\n\nstring3 is also a string!\n\n\nAn important characteristic of each string is its length, which is the number of characters in it. The length can be any natural number (i.e., zero or any positive integer). In python we can see the length of a string by using the len() function. In fact, this function can be used to assess the length of many different variable types such as lists, tuples, sets and so on (more on those later).\n\nstring1 = 'loooooong string'\nstring2 = 'shor'\nstring3 = ''\n\n\nprint(len(string1))\nprint(len(string2))\nprint(len(string3))\n\n16\n4\n0\n\n\n\nBrief interlude: In Python, you can add comments to your code using the # symbol. Comments are lines of text that are ignored when the code runs, but they play an important role in explaining what your code is doing. Writing clear and meaningful comments as you code is considered best practice. It helps others (and your future self) understand your logic and what you are trying to do. Below is a simple example that shows how to use comments in Python. Make sure you are comfortable with this, as commenting is a crucial habit for anyone working with code.\n\n\n# The below line prints a string, this line is a comment\nprint('This statement is printed') # This is another comment\n\n# The below line is not a comment as the # is contained within quotes\ntext = \"# This is not a comment because it's inside quotes.\"\nprint(text)\n\nThis statement is printed\n# This is not a comment because it's inside quotes.\n\n\n\nCheck your understanding: What is the difference between print(2 + 3) and print(\"2\" + \"3\")? What happens if you try x = \"hello\" + 5? Using the below box, write some code to answer these questions.\n\n\n# Write your code here...\n\n\n\nPython has many useful tools for manipulating strings. One such function is the format function, which allows you to insert variables of different types into strings. Note that x in the below example does not need to be a string.\n\nx = 8\ny = 'John'\ns = \"{} is {} feet tall\".format(y, x)\nprint(s)\n\nJohn is 8 feet tall\n\n\nAnother useful tool is the concatenation operater; +. Concatenation in programming is another way for saying “join together”. See the below for an example of how this is done.\n\na = 'string1'\nb = 'string2'\nc = a + ' ' + b\n\nprint(c)\n\nstring1 string2\n\n\nIn fact, the previous example could be done using concatenation instead of the format funtion. Note though that we must be careful and convert x from an integer to a string, using str(), in this case.\n\nx = 8\ny = 'John'\n\nprint(y + ' is ' + str(x) + ' feet tall')\n\nJohn is 8 feet tall\n\n\nOther useful functions for string manipulation include\n\nstrip; which, by default, removes any white space from the beginning and end of a string. However, you can also specify which characters you wish to remove.\nsplit; splits a string by specified character (known as a seperator), and returns a list. By default, the separator is a space and this function splits a sentence into individual words.\nreplace; this returns a string with some specified value replaced with another specified value.\nupper; this makes a string all uppercase.\nlower; this makes a string all lowercase.\n\nSeveral examples are given below. Please make sure you understand what each of these functions does before moving on to the next section. There are many other functions available and a good resource for learning about each individual function and trying them for yourself is the w3 schools python reference site.\n\n# Demonstration of the strip function\nprint(\"Demonstration of strip function\\n\")\n\n\nx = '    this is a string     '\nprint(x)\nprint(x.strip())\ny = '...another string...'\nprint(y)\nprint(y.strip('.'))\n\n# -------------------------------------------------------------------\n# Demonstration of the split function\nprint(\"\\nDemonstration of split function\\n\")\n\n\nx = 'This is a string'\nprint(x)\nprint(x.split())\nprint(x.split('i'))\n\n# -------------------------------------------------------------------\n# Demonstration of the replace function\nprint(\"\\nDemonstration of replace function\\n\")\n\nx = 'I am not sure that I understand how the replace function works'\nprint(x)\ny = x.replace('am not sure', 'am totally sure')\nprint(y)\nz = y.replace('sure', 'sure, 100% sure in fact thanks to this (rather well put together) notebook,')\nprint(z)\n\n# -------------------------------------------------------------------\n# Demonstration of the upper and lower functions\nprint(\"\\nDemonstration of upper and lower functions\\n\")\n\nx = 'RaNDom CAseS'\nprint(x)\nprint(x.lower())\nprint(x.upper())\n\nDemonstration of strip function\n\n    this is a string     \nthis is a string\n...another string...\nanother string\n\nDemonstration of split function\n\nThis is a string\n['This', 'is', 'a', 'string']\n['Th', 's ', 's a str', 'ng']\n\nDemonstration of replace function\n\nI am not sure that I understand how the replace function works\nI am totally sure that I understand how the replace function works\nI am totally sure, 100% sure in fact thanks to this (rather well put together) notebook, that I understand how the replace function works\n\nDemonstration of upper and lower functions\n\nRaNDom CAseS\nrandom cases\nRANDOM CASES",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#booleans",
    "href": "01/week_01_intro_to_data_types_beginner.html#booleans",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "A boolean in python is a variable that can be either True or False. For instance:\n\n# Create a boolean variable \nmy_boolean = True\nprint(my_boolean)\n\nTrue\n\n\nBooleans arise in all sorts of situations. For example, consider the below code:\n\nprint(128 &gt; 100)\n\nTrue\n\n\nYou should see it print True, which makes sense as 128 is indeed larger than 100. Try changing the numbers above; can you make this print False?\nIn this code, the expression 128 &gt; 100 is a boolean statement. We can make this clearer like so:\n\nmy_boolean = 128 &gt; 100\nprint(my_boolean)\n\nTrue\n\n\nThe above code is identical to the previous, but we have now saved the True/False value as my_boolean.\nSome common boolean operators include:\n\nnot: This negates the value of a variable (i.e. turns True to False and False to True).\nand: This is a logical and.\nor: This is a logical or.\nis: This checks whether two variables point to the same object in memory.\n==: This checks whether two variables are equal in value (Note: This shouldn’t be confused for the assigment operator; =).\n!=: This checks whether two variables are not equal in value.\n\nBoolean operators in Python are designed to be intuitive and as close to natural language as possible. The below code demonstrates how the boolean operations and, or, == and != and not are used. Try changing the values of a and b to ensure you understand how these operations work.\n\na = True\nb = False\n\nprint(\"not a: \", not a)\nprint(\"a and b: \", a and b)\nprint(\"a or b: \", a or b)\nprint(\"a==b: \", a==b)\nprint(\"a!=b: \", a!=b)\n\n# Note: both c and b are treated as False, but they are not equal, see below;\nc = {}\nprint(\"not c: \", not c)\nprint(\"not b: \", not b)\nprint(\"b==c: \", b==c)\n\nnot a:  False\na and b:  False\na or b:  True\na==b:  False\na!=b:  True\nnot c:  True\nnot b:  True\nb==c:  False\n\n\nOther common relational expressions which give True/False output include &lt;=, &gt;=, &lt; and &gt; for numeric datatypes (e.g. ints and floats) and in for collection datatypes (such as lists or tuples, which we shall look at next).\n\na = 1\nb = 1.1\n\nprint(\"a&gt;b:    \", a&gt;b)\nprint(\"a&lt;b:    \", a&lt;b)\nprint(\"a&gt;=b:   \", a&gt;=b)\nprint(\"a&lt;=b:   \", a&lt;=b)\n\nc = \"Some string\"\nd = \"om\"\nprint(\"c in d: \", c in d)\nprint(\"d in c: \", d in c)\n\ne = 1\nf = 0.1\ng = [1,2,3]\nprint(\"e in g: \", e in g)\nprint(\"f in g: \", f in g)\n\na&gt;b:     False\na&lt;b:     True\na&gt;=b:    False\na&lt;=b:    True\nc in d:  False\nd in c:  True\ne in g:  True\nf in g:  False",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#casting-between-data-types",
    "href": "01/week_01_intro_to_data_types_beginner.html#casting-between-data-types",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "In Python the data type of a variable is dynamic. This means that you do not need to specify the data type beforehand and that it can easily be changed. For example, try moving the type statement before and after the sum in the below block and see how the output is changed. Why does the output change?\n\na = 1\nb = 1.1\n\nprint(type(a))\n\na = a+b\n\n&lt;class 'int'&gt;\n\n\nSeveral inbuilt functions are available for converting between types. The most commonly used of these are the int, float and str functions. Try these out below. Caution: Note how converting z back to a float does not give the original value x. Why do you think this is?\n\nx = 1.1\ny = str(x)\nz = int(x)\n\nprint(x)\nprint(y)\nprint(z)\n\nprint(type(x))\nprint(type(y))\nprint(type(z))\n\nprint(x - float(z))\n\n1.1\n1.1\n1\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\n&lt;class 'int'&gt;\n0.10000000000000009\n\n\nThe act of converting one data type to another is often referred to as casting. For instance, in the above code, we cast x from a float to a string and then from a string to an integer.\n\nCheck your Understanding: What happens if you try int(\"10.5\")? Why might you convert a number to a string using str()? Use the below code box to answer these questions.\n\n\n# Write your answers here...",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#exercises",
    "href": "01/week_01_intro_to_data_types_beginner.html#exercises",
    "title": "Week 1: Introduction to Data Types",
    "section": "",
    "text": "Question 1: Below are three variables x, y and z. By using the operators introduced in the Booleans section of this notebook, construct a boolean variable, my_boolean which is true if and only if \\(y\\) lies strictly between \\(x^2\\) and \\(z^3\\). That is, my_boolean should be true if and only if either \\(x^2&lt;y&lt;z^3\\) or \\(z^3&lt;y&lt;x^2\\).\n\n# Variables x, y and z\nx = 1\ny = 2\nz = 1.26\n\nmy_boolean = # Write your code here...\n\n\n  Cell In[24], line 6\n    my_boolean = # Write your code here...\n                 ^\nSyntaxError: invalid syntax\n\n\n\n\nQuestion 2: In the below code, we have two boolean variables; is_raining and have_umbrella. We will assume that these represent the sentences “It is raining outside” and “I have my umbrella with me”, respectively.\n\n# Boolean variables\nis_raining = True\nhave_umbrella = False\n\nWe will assume that you are going to get wet if and only if it is raining outside and you do not have your umbrella. Using logical operators (e.g. and, or, not…), make a new boolean variable that tells you if you are going to get wet.\n\n# Boolean telling you if you are going to get rained on\ngot_soaked = # Write your code here...\n\nprint('Question: Will I get rained on?')\nprint('Answer: ' + str(got_soaked))\n\n\n  Cell In[26], line 2\n    got_soaked = # Write your code here...\n                 ^\nSyntaxError: invalid syntax\n\n\n\n\nQuestion 3: In this question, we are interested in three boolean variables A, B and C. By performing your own research online, write down (on paper) a “Truth Table” for the expression (A and B) or (not C). Your table should have the following columns:\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\nA and B\nnot C\n(A and B) or (not C)\n\n\n\n\nTrue\nTrue\nTrue\n\n\n\n\n\nTrue\nTrue\nFalse\n\n\n\n\n\nTrue\nFalse\nTrue\n\n\n\n\n\nTrue\nFalse\nFalse\n\n\n\n\n\nFalse\nTrue\nTrue\n\n\n\n\n\nFalse\nTrue\nFalse\n\n\n\n\n\nFalse\nFalse\nTrue\n\n\n\n\n\nFalse\nFalse\nFalse\n\n\n\n\n\n\nIn the following box, write some code which computes (A and B) or (not C). By changing the values of A, B and C check the correctness of your truth table.\n\n# Boolean variables\nA = True\nB = False\nC = True\n\n# Compute new boolean\nmy_boolean = # Write your code here...\n\n\n  Cell In[27], line 7\n    my_boolean = # Write your code here...\n                 ^\nSyntaxError: invalid syntax\n\n\n\n\nQuestion 4: Below are two variables representing the width and height of a rectangle. Write some code that computes the area, perimeter and length of the diagonal of the rectangle. Your code should print the results.\n\n# Height and width variables\nheight = 10\nwidth = 3\n\n# Write your code here...\n\nQuestion 5: An object dropped from a height satisfies the SUVAT equations. In particular, it satisfies the following equation:\n\\[v^2 = u^2 + 2as\\]\nwhere - \\(v\\) is the final velocity, - \\(u\\) is the initial velocity, - \\(a\\) is the acceleration, equal to gravity in this case, - \\(s\\) is the distance.\nGiven the object is at rest initially and it’s final velocity is \\(10\\) meters per second, write code to compute the distance it has fallen.\n\n# Known variables\nv = 10\nu = # You must choose an appropriate value for this variable...\na = # You must choose an appropriate value for this variable...\n\n# Compute s\ns = # Write your code here.\n\n\n  Cell In[29], line 3\n    u = # You must choose an appropriate value for this variable...\n        ^\nSyntaxError: invalid syntax\n\n\n\n\nQuestion 6: Building on your answer to Question 5, by researching the SUVAT equations and writing code below, compute the time in seconds that the object spends in freefall.\n\n# Compute time using variables from Question 5\nt = # Write your answer here...\n\n\n  Cell In[30], line 2\n    t = # Write your answer here...\n        ^\nSyntaxError: invalid syntax\n\n\n\n\nQuestion 7: Without running code, predict the result of these, then check your answers in Python:\n\n(True and False) or True\nnot (False or False)\nTrue or False and False\nFalse ^ True\n(True and not True) and (False or not False)\n\n\n# Write your code here...\n\nHint: You may wish to look up Truthy and Falsy values.\nQuestion 8: The below code takes two numbers, x and y and computes \\(z=\\frac{x+y}{y^2}\\). For instance, when we set \\(x=1\\) and \\(y=5\\) we get \\(z=0.24\\).\n\n# Set the values of x and y\nx = 1\ny = 5\n\n# Add x and y together\nz = float(x + y)/float(y)**2\n\n# Print the result\nprint(z)\n\n0.24\n\n\nSuppose you were change the inputs, x and y, to 2 and 5. Work out by hand what you would expect \\(z\\) to equal.\nThe below code is the same as the above but the values of x and y have been changed. This time, something has gone wrong! z does not give the expected value. Explain what has happened and how you would fix it.\n\n# Set the values of x and y\nx = '2'\ny = '5'\n\n# Add x and y together\nz = float(x + y)/float(y)**2\n\n# Print the result\nprint(z)\n\n1.0\n\n\nQuestion 9: Explain why the first code box below prints nothing but the second prints True.\n\nthree = 2 + 1\n\n\n3 == 2 + 1\n\nTrue\n\n\nHint: Consider the below variable z. What is it’s datatype?\n\n# Set the vairable z.\nz = (3 == 2 + 1)\n\n# Print it's type\n# write your code here...\n\nGiven your answer to the above, you may expect the below code to also print True.\n\n0.3 == 0.1 + 0.2\n\nFalse\n\n\nHowever, it doesn’t! Why do you think this is?\nHint: Try printing (0.1 + 0.2) and 0.3 seperately. What do you notice?\nQuestion 10: In the code block below, you are given 12 strings:\n\none start_string\n\nten “helper” strings (string1 to string10)\n\none end_string\n\nYour task is to transform the start_string into the end_string using only:\n\nthe start_string\n\nthe helper strings (string1 … string10)\n\nthe .replace() function\n\nA complete solution can be given in 5 replacement steps. We’ve given you the first step to get you started.\nHint: You might not need all ten helper strings.\n\n# The string we want to transform\nstart_string = 'Thas as te arang we want!'\nprint('Start:  ', start_string)\n\n# Helper strings you can use for replacements\nstring1 = 'a'\nstring2 = 'st'\nstring3 = 'he a'\nstring4 = ' ge'\nstring5 = 'stri'\nstring6 = 'sts'\nstring7 = 'is'\nstring8 = 'ara'\nstring9 = 'gen'\nstring10 = 'e a'\n\n# Step 1 (given as an example)\nstep1 = start_string.replace(string1,string2)\nprint('Step 1: ',step1)\n\n# Step 2 (fill in the correct strings)\nstep2 = step1.replace(string_ , string_) # Fill in the underscores\nprint('Step 2: ', step2)\n\n# Step 3–5 (repeat the process until you reach the final string)\n\nprint('...')\n\n\n# Target string you should reach in 5 steps\nend_string = 'This is the string we want!'\nprint('End:    ', end_string)\n\nStart:   Thas as te arang we want!\nStep 1:  Thsts sts te strstng we wstnt!\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[38], line 22\n     19 print('Step 1: ',step1)\n     21 # Step 2 (fill in the correct strings)\n---&gt; 22 step2 = step1.replace(string_ , string_) # Fill in the underscores\n     23 print('Step 2: ', step2)\n     25 # Step 3–5 (repeat the process until you reach the final string)\n\nNameError: name 'string_' is not defined",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_slides.html#todays-lecture",
    "href": "01/week_01_slides.html#todays-lecture",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Today’s Lecture",
    "text": "Today’s Lecture\n\nLecture 1: Introduction and Data Types\n\nCourse Structure\nSetting up Noteable\nIntroduction to Coding\nData Types\nPractical"
  },
  {
    "objectID": "01/week_01_slides.html#course-structure",
    "href": "01/week_01_slides.html#course-structure",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Course Structure",
    "text": "Course Structure\n\nThis course will run for 20 weeks\nWe will cover:\n\nData types, conditionals and loops\nBuilding functions\nNumpy arrays and linear algebra in python\nPandas dataframes\nPlotting and visualisation\n\nClasses:\n\n1 lecture per week (Thursday)\n1 small-group tutorial per two weeks (date should be on calendar)"
  },
  {
    "objectID": "01/week_01_slides.html#lectures",
    "href": "01/week_01_slides.html#lectures",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Lectures",
    "text": "Lectures\n\nThe weekly lecture will consist of\n\n≈ 30-40 minutes presentation time covering:\nKey concepts\nAdministrative points (e.g. homework submission etc)\nCode Demonstrations#\n\n≈ 1-1.5 hours practical\nDesigned to provide hands on experience\nOpportunity to ask for help from\n\nLecturer\nPhD helpers\nEach other!"
  },
  {
    "objectID": "01/week_01_slides.html#assignments",
    "href": "01/week_01_slides.html#assignments",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Assignments",
    "text": "Assignments\n\nFormative:\n\nWeekly (optional) assignments available on quarto\n\nSummative:\n\nThis module is 100% coursework\n4 pieces of coursework\nAssignment 1 (15%)\nAssignment 2 (30%)\nAssignment 3 (15%)\nAssignment 4 (40%)\n\nAssignments 1-3 will be exercises\nAssignment 4 will be different\n\nProject report analysing a dataset"
  },
  {
    "objectID": "01/week_01_slides.html#online-material",
    "href": "01/week_01_slides.html#online-material",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Online Material",
    "text": "Online Material\n\nThe course material is available online via:\n\nQuarto – online searchable version\nNoteable – interactive interface we shall work in during class"
  },
  {
    "objectID": "01/week_01_slides.html#accessing-noteable",
    "href": "01/week_01_slides.html#accessing-noteable",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Accessing Noteable",
    "text": "Accessing Noteable\n\nOpen Blackboard\nGo to Introduction to Coding and Data Analysis for Scientists 2025\nClick Unit Information and Resources\nOpen Noteable\n\nMake sure Jupyter Classic (Legacy) is selected.\nClick Start\n\nClick +GitRepo\nPaste into Git Repository URL: git@github.com:TomMaullin/SCIF10002-2025.git\nPress clone"
  },
  {
    "objectID": "01/week_01_slides.html#introduction-to-coding",
    "href": "01/week_01_slides.html#introduction-to-coding",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Introduction to Coding",
    "text": "Introduction to Coding\n\nIn this module, we shall be learning to code in Python\nPython is a programming language\n\n\n\nIn the same way humans communicate using different languages, there are many languages we can use to communicate with a computer\nPython is particularly useful for:\n\nAnalysing data\nMaking plots and visualisations\nRunning simulations\nMachine learning and AI\n\n\n\ndef greet(name):\n    \"\"\"Return a friendly greeting.\"\"\"\n    return f\"Hello, {name}!\"\n\ngreet(\"Bob\")\n\n'Hello, Bob!'"
  },
  {
    "objectID": "01/week_01_slides.html#learning-to-code",
    "href": "01/week_01_slides.html#learning-to-code",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Learning to Code",
    "text": "Learning to Code\n\nIn fact, learning to code is a lot like learning a language\nWhen learning French, you might:\n\nLearn many phrases\nPractice writing sentences\nSpeak to people who know the language\n\nYou can’t learn a language by listening to other people describe it…\nHands-on experience and regular practice are crucial!"
  },
  {
    "objectID": "01/week_01_slides.html#getting-started",
    "href": "01/week_01_slides.html#getting-started",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Getting Started",
    "text": "Getting Started\n\nSo… what actually is coding?\nYou can think of writing code as like writing a recipe…\n\nYou might start by specifying some ingredients…\nThen list some instructions…\nTo get a desired output\n\nCoding is pretty similar"
  },
  {
    "objectID": "01/week_01_slides.html#getting-started-1",
    "href": "01/week_01_slides.html#getting-started-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Getting Started",
    "text": "Getting Started\n\nYou might start by specifying some inputs…\nThen list some instructions…\nTo get a desired output\n\n\n# Start with two ingredients (inputs)\nx = 7\ny = 4\n\n# Step 1: Add them together\nstep1 = x + y\n\n# Step 2: Multiply the result by 2\nstep2 = step1 * 2\n\n# Step 3: Subtract y from that\nz = step2 - y\n\n# Final output\nprint(\"The final result is:\", z)\n\nThe final result is: 18\n\n\nHere we are producing some output that might be difficult to compute or evaluate by hand."
  },
  {
    "objectID": "01/week_01_slides.html#assigning-variables",
    "href": "01/week_01_slides.html#assigning-variables",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Assigning Variables",
    "text": "Assigning Variables\n\nx = 7\ny = 4\n\n\nIn this code, x and y are variables\nThese are named pieces of data which we can use for future computations\nThe = symbol is the assignment operator.\n\nUnlike in maths, this is an instruction\nE.g. x=7 means “Save the integer 7 under the variable name x”"
  },
  {
    "objectID": "01/week_01_slides.html#data-types",
    "href": "01/week_01_slides.html#data-types",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Data Types",
    "text": "Data Types\n\nx = 7        # an integer\ny = \"hello\"  # a string of text\nz = True     # a boolean (true/false)\n\n\nWhen writing the recipe, some foods were of the “same type”\n\nE.g. we had 2 eggs\n\nIn the same way, in coding we have different types of data\nToday, we shall look at some of these\nUnderstanding data types is important, as we want to use different data types for different tasks"
  },
  {
    "objectID": "01/week_01_slides.html#numeric-data-types",
    "href": "01/week_01_slides.html#numeric-data-types",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Numeric Data Types",
    "text": "Numeric Data Types\n\n# Start with an integer and a float\nx = 7 # integer\ny = 3.5 # float (decimal number)\n\n# Convert integer to float\nx_as_float = float(x)\n\n# Convert float to integer\ny_as_int = int(y)\n\n\nThe most ubiquitous data types are numeric\n\nIntegers: Whole numbers/Integers\nℤ = {…, -3, -2, -1, 0, 1, 2, 3,… }\n\nFloats: Decimal numbers\n\nℝ = Real numbers\nWe can convert between float’s and integers using the float and int functions.\n\nWhat do you think might happen if we convert y to an integer?\n\nWarning: A computer cannot actually describe arbitrarily small and large numbers – it approximates instead"
  },
  {
    "objectID": "01/week_01_slides.html#strings",
    "href": "01/week_01_slides.html#strings",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Strings",
    "text": "Strings\n\nA string is a sequence of characters. Strings can contain:\n\nLetters\nNumbers (treated as characters)\nPunctuation\nSpaces\nCombinations of the above\nNothing at all\n\n\n\n# Letters\nletters = \"Hello\"\n\n# Numbers (treated as characters)\nnumbers = \"12345\"\n\n# Punctuation\npunctuation = \"!?.,;;\"\n\n# Spaces\nspaces = \"   \" # three spaces\n\n# Combinations of the above\ncombo = \"Hi123?! \"\n\n# Nothing at all (an empty string)\nempty = \"\"\n\n\nIn practice, there are many things we may want to do with text in Python\n\nSplit it into sentences\nSearch through it\nReplace words\n\n\nAfter todays practical you will be able to perform some of these operations!"
  },
  {
    "objectID": "01/week_01_slides.html#booleans",
    "href": "01/week_01_slides.html#booleans",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Booleans",
    "text": "Booleans\n\nA Boolean is variable that can be either True or False\nBooleans represent logical statements.\nFor instance, we might think of:\n\ncat_is_black as representing the sentence “The cat is black”\ncat_has_four_legs as representing the sentence “The cat has four legs”\n\nWe can use logical operators to combine Boolean statements\n\ncat_is_black and cat_has_four_legs represents the sentence “The cat is black and has four legs”\n\n\n\ncat_is_black = True\ncat_has_four_legs = False\nprint(cat_is_black and cat_has_four_legs)\n\nFalse"
  },
  {
    "objectID": "01/week_01_slides.html#booleans-1",
    "href": "01/week_01_slides.html#booleans-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Booleans",
    "text": "Booleans"
  },
  {
    "objectID": "01/week_01_slides.html#collections",
    "href": "01/week_01_slides.html#collections",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Collections",
    "text": "Collections\n\nWe’ve now seen some simple examples of datatypes:\n\nNumeric, strings, and booleans.\n\nData types don’t always have to be this simple!\n\nSometimes we need data types that can hold more complex information.\n\nWe’ll see more examples throughout the course but for now we’ll provide just one\nA collection is any in-built data type that can group multiple objects together.\nThe most common collection is a list: an ordered group of items.\n\nLists let you store, organize, and work with many values at once.\n\n\n\n# A list of numbers\nscores = [10, 15, 20]\n\n# A List of strings\nshopping = [\"milk\", \"bread\", \"eggs\", \"cheese\"]\n\n# A mixed list (different data types together)\nmixed = [42, \"hello\"]"
  },
  {
    "objectID": "01/week_01_slides.html#practical",
    "href": "01/week_01_slides.html#practical",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe have students from a range of courses and backgrounds in this class\n\nChemistry\nPhysics\nData Science\n\nSome people in the room will have less experience than others\nFor the first few weeks, we shall try to account for the differences in ability where possible"
  },
  {
    "objectID": "01/week_01_slides.html#practical-1",
    "href": "01/week_01_slides.html#practical-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe now move over to Python\nPlease open week_01_home.ipynb\nFor the rest of today, you must work through a Python notebook\nYou have a choice of one of three options\n\nOption 1: Beginner - Basic Data Types\nOption 2: Intermediate - Collections\nOption 3: Advanced - Copying and References"
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html",
    "href": "01/week_01_solutions_demonstrator_version.html",
    "title": "Week 1: Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 1 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html#beginner-basic-data-types",
    "href": "01/week_01_solutions_demonstrator_version.html#beginner-basic-data-types",
    "title": "Week 1: Solutions",
    "section": "Beginner: Basic Data Types",
    "text": "Beginner: Basic Data Types\nQuestion 1: The solution to the question is given below:\n\n# Variables x, y and z\nx = 1\ny = 2\nz = 1.26\n\nmy_boolean = ((x**2 &lt; y) and (y &lt; z**3)) or ((z**3 &lt; y) and (y &lt; x**2))\n\n\nDemonstrator Notes: The purpose of this question is to prompt students to think about the use of the and and or boolean operators, as well as the syntax for &lt;. When advising students on this question, make sure to help them break the inequalities \\(x^2&lt;y&lt;z^3\\) and \\(z^3&lt;y&lt;x^2\\) down using the and statement.\n\nQuestion 2: The solution to the question is given below:\n\n# Boolean variables\nis_raining = True\nhave_umbrella = False\n\n# Boolean telling you if you are going to get rained on\ngot_soaked = is_raining and (not have_umbrella)\n\nprint('Question: Will I get rained on?')\nprint('Answer: ' + str(got_soaked))\n\nQuestion: Will I get rained on?\nAnswer: True\n\n\n\nDemonstrator Notes: Last year, many of the students struggled with Boolean logic. This question aims to get them thinking about how to combine logical connectives like and and not. If students are struggling with this, please try and prompt them to convert the natural language sentence it's raining and I don't have my umbrella to logical syntax by breaking it down into smaller sentences. Highlight that I don't have my umbrella is the logical opposite (negation) of I have my umbrella.\n\nQuestion 3: The completed truth table for this question is:\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\nA and B\nnot C\n(A and B) or (not C)\n\n\n\n\nTrue\nTrue\nTrue\nTrue\nFalse\nTrue\n\n\nTrue\nTrue\nFalse\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nTrue\nFalse\nFalse\nFalse\nTrue\nTrue\n\n\nFalse\nTrue\nTrue\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nFalse\nFalse\nFalse\nFalse\nTrue\nTrue\n\n\n\nAnd the code for this question is:\n\n# Boolean variables\nA = True\nB = False\nC = True\n\n# Compute new boolean\nmy_boolean = (A and B) or (not C)\nprint(my_boolean)\n\nFalse\n\n\n\nDemonstrator Notes: This question is again designed to get students thinking about Boolean logic. It is expected that, for many students, this will be their first encounter with truth tables and first-order logical operators.\nIf a student is struggling with the abstraction, try to relate A, B and C to the example given in the slides. In the slides, A represents the statement The cat is black and B represents the statement The cat has four legs. To extend the example, you could define C to be, for instance, The cat has blue eyes. Once this is understood, try building the truth table column by column, starting with the A and B column, then the not C column and then finally the (A and B) or (not C) column.\nWhen giving examples, try to avoid statements with vague/ambiguous truth values. For instance, The cat is tall has an ambiguous truth value as there is not a clear distinction between tall and not tall.\n\nQuestion 4: The solution to this question is given below:\n\n# Height and width variables\nheight = 10\nwidth = 3\n\n# Perimeter\nperimeter = 2*(height+width)\n\n# Area\narea = height*width\n\n# Diagonal\ndiag = (height**2 + width**2)**(1/2)\n\n# Print results\nprint(perimeter, area, diag)\n\n26 30 10.44030650891055\n\n\n\nDemonstrator Notes: At this stage, students will not know any numpy, so please make sure to use x**(1/2) instead of functions such as np.sqrt(x). These functions will be taught at a later stage. It is expected that many students here will mistakenly write ^ for exponentiation instead of **, so please look out for this mistake. Some students may also need reminding that Pythagoras’ theorem can be used to compute the length of the diagonal.\n\nQuestion 5: The solution to this question is given by:\n\n# Known variables\nv = 10\nu = 0\na = 9.81\n\n# Compute s\ns = (v**2-u**2)/(2*a)\nprint(s)\n\n5.09683995922528\n\n\n\nDemonstrator Notes: Whilst the SUVAT equations are part of the UK A-level Physics syllabus, please be aware that many students may not know them. For instance, data science or chemistry students may not have taken Physics A-level (or potentially even GCSE) and overseas students may have been taught the subject using different notations. For this reason, be aware students may be non-responsive to this question because they do not understand that, e.g., a should be set to 9.81. Try to assess whether the student is comfortable with the subject material before giving advice on how to solve the problem here.\n\nQuestion 6: The solution to this question is given by:\n\n# Compute time using variables from Question 5\nt = 2*s/(u+v)\nprint(t)\n\n1.019367991845056\n\n\n\nDemonstrator Notes: See comments on previous question. Also be aware that there are multiple solutions to this question, as any of the equations \\(v=u+at\\), \\(s=ut+\\frac{1}{2}at^2\\) or \\(s=\\frac{(u+v)t}{2}\\) can be used. Students who are unsure what to do should be encouraged to look at the linked document for question 5.\n\nQuestion 7: A code block containing the examples from the question is given below:\n\nprint((True and False) or True)\nprint(not (False or False))\nprint(True or False and False)\nprint(False ^ True)\nprint((True and not True) and (False or not False))\n\nTrue\nTrue\nTrue\nTrue\nFalse\n\n\nThe answers follow by standard boolean logic. The only difficult parts are determining the order of operations for the third example (python will interpret this as True or (False and False) rather than (True or False) and False) and the xor (^) on the fourth line.\n\nDemonstrator Notes: Some students may find this question confusing because we are using the Boolean values True and False directly, rather than naming them as variables (e.g. A and B). Emphasize that there is no difference between the below code:\nA = True\nB = False\nprint(A and B)\nand this code:\nprint(True and False)\nThe logic is identical - the only change is whether we use named variables or literal values. Point this out clearly so students see that the rules of Boolean logic still apply in exactly the same way.\n\nQuestion 8: The error in the code occurs when float(x + y) is run.\nWhen x and y are numeric, the + symbol is interpreted as addition and the result is cast to a float (e.g. if x=1 and y=5 as in the first example then x+y yeilds 6). However, if they are instead strings (as in the second example), then the + symbol is interpreted as concatenation rather than addition. Therefore, when x='2' and y='5', we get that 2+5 yeilds 25, not 7.\nThere are two approaches to resolving the issue. The first is to replace x='2' and y='5' with x=2 and y=5. The second, and preferred option, is to replace float(x + y) with float(x)+float(y) so there is no possibility that the + symbol is interpreted as concatenation here.\n\nDemonstrator Notes: If students are struggling with this question, suggest that they search the document for the + symbol and make sure they understand how it is being used. Hint that the symbol might not be interpreted in the way they first expect, but avoid giving away the full answer unless they are really stuck. The aim is to guide them toward discovering the behaviour themselves.\n\nQuestion 9: The first box is an assignment of the value 2 + 1 to a variable named three, so does not print anything. The second box prints true as the variable z = (1 + 2 == 3) is interpreted as a Boolean variable, and in Jupyter notebooks, if the last line of a box is simply a variable, with no assignment, then that variable is printed out. z is evaluated as True (as 1 + 2 does equal 3 in Python), so True is printed.\nFor the third box, False is printed as due to rounding errors 0.1 + 0.2 is evaluated to 0.30000000000000004 rather than 0.3. This is a cautionary note that floating point math is not perfect.\n\nDemonstrator Notes: First, it aims to get students to think about the difference between the assignment operator = and the equality operator ==. Second, it serves as a cautionary note about floating point arithmetic in Python.\nAfter seeing the result, many students may ask how to properly check whether 0.1 + 0.2 equals 0.3. For now, explain that we will cover this in more detail when we look at numpy. If they push further, encourage them to think about constructing a Boolean expression (similar to Question 1) that checks whether two numbers differ by only a very small amount. The aim here is to prepare them for the np.allclose function later on, while prompting them to reason about the problem themselves rather than being given the solution straight away.\n\nQuestion 10: The final solution is given below:\n\n# The string we want to transform\nstart_string = 'Thas as te arang we want!'\nprint('Start:  ', start_string)\n\n# Helper strings you can use for replacements\nstring1 = 'a'\nstring2 = 'st'\nstring3 = 'he a'\nstring4 = ' ge'\nstring5 = 'stri'\nstring6 = 'sts'\nstring7 = 'is'\nstring8 = 'ara'\nstring9 = 'gen'\nstring10 = 'e a'\n\n# Step 1\nstep1 = start_string.replace(string1,string2)\nprint('Step 1: ', step1)\n\n# Step 2\nstep2 = step1.replace(string6,string7)\nprint('Step 2: ', step2)\n\n# Step 3\nstep3 = step2.replace(string2, string1)\nprint('Step 3: ', step3)\n\n# Step 4\nstep4 = step3.replace(string10, string3)\nprint('Step 4: ', step4)\n\n# Step 5\nstep5 = step4.replace(string8, string5)\nprint('Step 5: ', step5)\n\nStart:   Thas as te arang we want!\nStep 1:  Thsts sts te strstng we wstnt!\nStep 2:  This is te strstng we wstnt!\nStep 3:  This is te arang we want!\nStep 4:  This is the arang we want!\nStep 5:  This is the string we want!\n\n\n\nDemonstrator Notes: This question is designed to give students practice with the string replace function. Encourage them to experiment and work through the task step by step, even if their first attempt doesn’t work. The key learning outcome is to get comfortable with testing, adjusting, and trying again - it aims to enforce good programming habits."
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html#intermediate-collections",
    "href": "01/week_01_solutions_demonstrator_version.html#intermediate-collections",
    "title": "Week 1: Solutions",
    "section": "Intermediate: Collections",
    "text": "Intermediate: Collections\n\nBroad Notes for Demonstrators: If you see a student attempting the intermediate questions who does not seem at the level of the material, please do encourage them to first try the beginner notebook.\n\nQuestion 1: The code for this question is given below:\n\n# Original list\nnums = [5, 2, 8, 2, 9]\nprint(\"Original list:\", nums)\n\n# 1. Retrieve the third element (index 2 because indexing starts at 0)\nthird_element = nums[2]\nprint(\"Third element:\", third_element)\n\n# 2. Slice the first three elements\nfirst_three = nums[:3]\nprint(\"First three elements:\", first_three)\n\n# 3. Replace the last element with 10\nnums[-1] = 10\nprint(\"After replacing last element with 10:\", nums)\n\n# 4. Append 7 to the end of the list\nnums.append(7)\nprint(\"After appending 7:\", nums)\n\n# 5. Remove the first occurrence of 2\nnums.remove(2)\nprint(\"After removing first occurrence of 2:\", nums)\n\nOriginal list: [5, 2, 8, 2, 9]\nThird element: 8\nFirst three elements: [5, 2, 8]\nAfter replacing last element with 10: [5, 2, 8, 2, 10]\nAfter appending 7: [5, 2, 8, 2, 10, 7]\nAfter removing first occurrence of 2: [5, 8, 2, 10, 7]\n\n\n\nDemonstrator Notes: This question aims to give students some initial practice with lists. Common errors to look out for include failing to account for the fact Python uses zero indexing, or that slicing syntax such as nums[:3] doesn’t include nums[3] in the output, only nums[0],nums[1] and nums[2].\n\nQuestion 2: The key to this question is that a list is ordered whilst a set is unordered. When the list is converted to a set, it’s ordering is lost, and when converted back to a list it is now given in increasing (numerical) order by default.\n\nDemonstrator Notes: Hopefully, this should not be a difficult question. Encourage students who are struggling to print out my_set and my_list and describe what is different between them.\n\nQuestion 3: The answer to this question is the letter k. To see this, the below code can be used:\n\n# Here are two strings\nstring1 = \"This is a long random sentence - I wonder which letters it contains and which letters it doesn't.\"\nstring2 = \"This task makes a clear and coherent string with words taken inside a small set\"\n\n# Make strings lowercase\nstring1 = string1.lower()\nstring2 = string2.lower()\n\n# Convert strings to sets\nstring1 = set(string1)\nstring2 = set(string2)\n\n# Compute the set difference\nprint(string2.difference(string1))\n\n{'k'}\n\n\n\nDemonstrator Notes: This question brings together concepts from both the Beginner and Intermediate notebooks, making it a good checkpoint to assess whether students are ready to move into the Intermediate material.\nIf students are struggling, suggest that they try the task on paper first. They will probably start by writing out the letters from each sentence and then comparing the two sets of letters. From there, you can show how Python supports the same process by turning a string into a list of characters and then using the set constructor to remove duplicates. This should hopefully help them connect the manual approach with the Python solution.\nOnce they have these concepts down, encourage students to think about why the lower() function (as suggested in the hint) is useful here. It ensures that comparisons between characters are case-insensitive.\n\nQuestion 4: The code for this question is provided below.\n\n# given tuple\nt = ('a', 'b', 'c', 'd', 'e')\n\n# 1. access the first and last elements of t\nfirst = t[0]\nlast = t[-1]\nprint(\"First element:\", first)\nprint(\"Last element:\", last)\n\n# 2. slice out ('b', 'c', 'd')\nslice_part = t[1:4]\nprint(\"Slice ('b', 'c', 'd'):\", slice_part)\n\n# 3. check whether 'c' is in t\nis_c_present = 'c' in t\nprint(\"'c' in t?\", is_c_present)\n\n# 4. find the index of 'd' in t\nindex_d = t.index('d')\nprint(\"Index of 'd':\", index_d)\n\n# 5. count how many times 'a' appears in t\ncount_a = t.count('a')\nprint(\"Count of 'a':\", count_a)\n\nFirst element: a\nLast element: e\nSlice ('b', 'c', 'd'): ('b', 'c', 'd')\n'c' in t? True\nIndex of 'd': 3\nCount of 'a': 1\n\n\n\nDemonstrator Notes: See notes on Question 1.\n\nQuestion 5: There are many ways to approach this question. Two examples are given below:\n\n# ----------------------------------------------------------------\n# Option 1:\n# ----------------------------------------------------------------\n# clinical trial dataset represented as a dictionary of lists\nclinical_data = {\n    \"Name\": [\"John\", \"Alice\", \"Maria\", \"David\", \"Sarah\"],\n    \"Weight (kg)\": [82, 68, 74, 90, 60],\n    \"Height (cm)\": [178, 165, 170, 185, 160]\n}\n\nprint(clinical_data)\n\n# ----------------------------------------------------------------\n# Option 2:\n# ----------------------------------------------------------------\n# clinical trial dataset represented as a dictionary of dictionaries\nclinical_data = {\n    \"John\": {\"Weight (kg)\": 82, \"Height (cm)\": 178},\n    \"Alice\": {\"Weight (kg)\": 68, \"Height (cm)\": 165},\n    \"Maria\": {\"Weight (kg)\": 74, \"Height (cm)\": 170},\n    \"David\": {\"Weight (kg)\": 90, \"Height (cm)\": 185},\n    \"Sarah\": {\"Weight (kg)\": 60, \"Height (cm)\": 160}\n}\n\n{'Name': ['John', 'Alice', 'Maria', 'David', 'Sarah'], 'Weight (kg)': [82, 68, 74, 90, 60], 'Height (cm)': [178, 165, 170, 185, 160]}\n\n\n\nDemonstrator Notes: The aim of this question is to help students recognise that there are multiple valid ways to represent the same dataset in Python. The important part is thinking about how the data will be used. For example, if we need to look up information by subject name, a dictionary of dictionaries might be best; if we want to work with all weights at once (e.g. to build a histogram), a dictionary of lists is more convenient. Emphasise that the choice of data structure depends on the task - there isn’t one ‘right’ answer."
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html#advanced-copying-and-references",
    "href": "01/week_01_solutions_demonstrator_version.html#advanced-copying-and-references",
    "title": "Week 1: Solutions",
    "section": "Advanced: Copying and References",
    "text": "Advanced: Copying and References\n\nBroad Notes for Demonstrators: If you see a student attempting the intermediate or advanced questions who does not seem at the level of the material, please do encourage them to first try the earlier notebooks.\n\nQuestion 1: The expected output is [1,2,3,4]. This is because list_a and list_b reference the same location in memory.\n\nlist_a = [1, 2, 3]\nlist_b = list_a\nlist_a.append(4)\nprint(list_b)\n\n[1, 2, 3, 4]\n\n\n\nDemonstrator Notes: The aim of this question is to get students to recognise that lists are mutable. As a list is mutable, both list_a and list_b refer to the same underlying object in memory. When we do list_b = list_a, we are not creating a copy of the list, but simply creating a new reference to the same list object. Therefore, when we perform list_a.append(4), the change is reflected in both list_a and list_b. Encourage students to think about how they could gain the desired behaviour using the .copy() function (e.g. list_b = list_a.copy()).\n\nQuestion 2: Code A will print [1,2,3] whilst Code B will print [4,5,6]. This is because, when we replace a with [4,5,6] we change the reference to point to a new location in memory, breaking the connection between a and b. However, when we change the elements in a individually, both a and b remain pointing to the same location in memory. Thus, when we print b, we get [4,5,6].\n\na = [1, 2, 3]\nb = a\na = [4, 5, 6]\nprint(b)\n\na = [1, 2, 3]\nb = a\na[0] = 4\na[1] = 5\na[2] = 6\nprint(b)\n\n[1, 2, 3]\n[4, 5, 6]\n\n\n\nDemonstrator Notes: See notes for Question 1.\n\nQuestion 3: The variable names xyz and xyzsquared are pointing to the same array. When we squared xyzsquared we also squared xyz. We could have avoided this by making xyzsquared a seperate copy of xyz using the list constructor like so:\n\nxyz = [1,2,3]\n\n# Make a list of x squared, y squared, z squared\nxyzsquared = list(xyz) # The change was implemented here!\nxyzsquared[0] = xyzsquared[0]**2\nxyzsquared[1] = xyzsquared[1]**2\nxyzsquared[2] = xyzsquared[2]**2\n\n# Get x, y and z from xyz list\nx = xyz[0]\ny = xyz[1]\nz = xyz[2]\n\n# Get x squared, y squared and z squared from\n# xyzsquared list\nxsquared = xyzsquared[0]\nysquared = xyzsquared[1]\nzsquared = xyzsquared[2]\n\nprint(x + y + z + xsquared + ysquared + zsquared)\n\n20\n\n\n\nDemonstrator Notes: This question is designed to give students practice debugging code. Try to guide them to the solution where possible, rather than providing the full solution straight away.\n\nQuestion 4: When you do backup = list(grid), Python only makes a new outer list. The smaller lists inside ([1, 2], [3, 4], [5, 6]) are still the exact same objects that grid is using. Because of that, if you change one of the inner lists, the same change shows up backup.\n\nDemonstrator Notes: The aim of this question is to understand why the unexpected behaviour occured. If students ask how to fix this, that’s a natural question, but at this stage they don’t yet have the tools to do so. For now, keep the focus on helping them understand why the behaviour occurs, instead of talking about fixes at this stage.\n\nQuestion 5: The reasoning for this question is similar to that of Question 4, but noting that the three inner lists are all pointing to the same place in memory.\n\nDemonstrator Notes: See the notes for Question 4."
  }
]