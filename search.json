[
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html",
    "href": "01/week_01_intro_to_data_types_advanced.html",
    "title": "Advanced: Copying and References",
    "section": "",
    "text": "Welcome to the Week 1 Advanced Python Notebook. This notebook is designed for students who already have substantial experience with Python and feel confident working with both the Beginner and Intermediate material.\nYour task today is to carefully read through the content and complete the exercises at the end. These exercises are more challenging and are intended to deepen your understanding of how Python handles data behind the scenes.\nIn this notebook, you will explore the critical differences between immutable and mutable data types in Python. Specifically, you will learn how Python handles copying and references, which can be critical knowledge when it comes to debugging complex code.\nWork through the examples carefully, and take your time with the exercises. They are designed to stretch your understanding and prepare you for advanced applications of Python.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#immutable-vs-mutable",
    "href": "01/week_01_intro_to_data_types_advanced.html#immutable-vs-mutable",
    "title": "Advanced: Copying and References",
    "section": "Immutable vs Mutable",
    "text": "Immutable vs Mutable\nIn Python, all data types can be described as either “immutable” or “mutable”.\nTo understand the difference between “immutable” and “mutable” types, it may be useful to introduce the notion of a reference. You can think of a reference as an address which tells us where some data lives physically on a machine. When we talk about variables, we really are talking about reference’s (which we have named) that point us to some data in memory.\nWhen you reassign the value of a variable in your code, there are actually two possible things that could be happening. The reference could be changed (i.e. the variable now represents a different place in memory), or the data itself could be changed (i.e. the variable is still “looking” at the same location in memory, but the data that is stored there has changed).\nWhat is important to know here is that when you change the value of a variable which has an “immutable” data type you are changing a reference whereas when you are changing “mutable” variables you are changing the data itself. Examples of mutable data types in Python include the list, dictionary and the set. On the other hand, examples of immutable data types are given by the int, float, decimal, bool and the tuple. In general, the more complicated data types discussed so far are “mutable”.\nThe distinction between a data type being “mutable” or “immutable” may seem dull and/or trivial but, in practice, can result in some very unexpected behaviour, especially when multiple variables are using the same reference (i.e. “looking” at the same place in memory)!\nFor example, in the below code we may expect a and b to have different values:\n\n\n\n\n\n\nAnd they do! However, if we change a from being 7 to a list containing 7, perhaps surprisingly, changing the value of a also changes the value b!\n\n\n\n\n\n\nIn both the examples above, we start by assigning a and b as references to the same location in memory.\nIn the first example, when we assign a=10, we are telling Python that a must change where it is “looking” in the computers memory. This does not have any effect on the value of b.\nIn the second example, however, when we assign a[0]=10, we are telling Python that the data stored in the location which a is “looking” at at must be changed. As b is also “looking” at this location in memory, this does have an effect on the value of b. It has changed!\nIt is worth noting though that if an operation is performed then a copy might be made:\n\n\n\n\n\n\nIn this case, to ensure we are working with a copy of a and not just a reference to the same variable, we can use the list constructor (see below).\n\nNote: In this case a is a list so we use the list constructor. For other datatypes similar constructors exist and would be used in this situation (e.g. set, dict, etc…).\n\n\n\n\n\n\n\n\nWarning: Errors of this type can often cause extremely anti-intuitive behaviour, including unexpected interactions between functions.\nFor example, in the below a function is called on a variable b, yet a seemingly unrelated variable a was affected by calling the function. This is because a and b were both references to the same object in memory, as oppose to being distinct copies of the object.\nIf you are not familiar with functions, do not worry; these will be covered in depth later in the course and, for now, move past this example.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#the-id-function",
    "href": "01/week_01_intro_to_data_types_advanced.html#the-id-function",
    "title": "Advanced: Copying and References",
    "section": "The id() Function",
    "text": "The id() Function\nNow that we understand the difference between mutable and immutable types, let’s take a look at the Python id() function, which can help us visualise what is happening with references and memory locations.\nThe id() function returns the unique identifier (memory address) of an object. This identifier tells us exactly where some data lives physically on a machine - essentially showing us the reference that a variable is pointing to.\n\n\n\n\n\n\nWith immutable data types, when you reassign a variable, you are changing the reference (the variable now points to a different location in memory). Let’s see this with our integer example:\n\n\n\n\n\n\nWith mutable data types, when you modify the data, you are changing the data itself (the reference stays the same - the variable is still “looking” at the same location in memory). Let’s reproduce our list example:",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#the-is-operator",
    "href": "01/week_01_intro_to_data_types_advanced.html#the-is-operator",
    "title": "Advanced: Copying and References",
    "section": "The is Operator",
    "text": "The is Operator\nThe is operator and == operator are often confused with one another but they are not same. The is checks if both the variables point to the same object in memory whereas the == sign checks if the values of the two variables are equal.\nIf the is operator returns True then the equality is definitely True, but the opposite may or may not be the case. For an example see the below.\n\nWarning: Avoid using the is operator for “immutable” types such as strings and numbers; the result is unpredictable and in most cases the == is more appropriate for purpose.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#exercises",
    "href": "01/week_01_intro_to_data_types_advanced.html#exercises",
    "title": "Advanced: Copying and References",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Predict the output of the following code. What will be printed and why?\nlist_a = [1, 2, 3]\nlist_b = list_a\nlist_a.append(4)\nprint(list_b)\nRun the code in the box below to verify your answer.\n\n\n\n\n\n\nQuestion 2: Consider these two similar-looking pieces of code. Predict what each will output and explain the difference:\nCode A:\na = [1, 2, 3]\nb = a\na = [4, 5, 6]\nprint(b)\nCode B:\na = [1, 2, 3]\nb = a\na[0] = 4\na[1] = 5\na[2] = 6\nprint(b)\nRun the code above to verify your answers.\n\n\n\n\n\n\nQuestion 3: In the below we have a list of 3 values, x=1, y=2 and z=3. We want to work out the value of:\n\n\\(x + y + z + x^2 + y^2 + z^2\\) \\(= 1 + 2 + 3 + 1 + 4 + 9\\) \\(= 20\\)\n\nThe below code should give us \\(20\\) as an answer… but it doesn’t - something has gone wrong! Can you see what is wrong in the below code? How would you fix it?\n\n\n\n\n\n\nQuestion 4: You have a list of lists representing a grid. You want to create a backup copy before making changes, but the following approach doesn’t work correctly. Explain what has gone wrong here.\n\n\n\n\n\n\nQuestion 5: The following code creates a 3x3 grid filled with zeros, but when you try to modify one cell, unexpected behavior occurs. Identify the problem and provide a solution:",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/exercises_intro.html",
    "href": "01/exercises_intro.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nIntro to Data Types - Exercises\nThe following exercises serve as self-assessment of your prior knowledge.\nExplore them to discover, recall or deepen your knowledge of basic Python structures and constructs.\n\nBeginner\nIntermediate\nAdvanced\n\nThere is no requirement to succeed at all of them. Come back to these over time to check the progression of your understanding."
  },
  {
    "objectID": "01/week_01_slides.html#todays-lecture",
    "href": "01/week_01_slides.html#todays-lecture",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Today’s Lecture",
    "text": "Today’s Lecture\n\nLecture 1: Introduction and Data Types\n\nCourse Structure\nSetting up Noteable\nIntroduction to Coding\nData Types\nPractical"
  },
  {
    "objectID": "01/week_01_slides.html#course-structure",
    "href": "01/week_01_slides.html#course-structure",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Course Structure",
    "text": "Course Structure\n\nThis course will run for 20 weeks\nWe will cover:\n\nData types, conditionals and loops\nBuilding functions\nNumpy arrays and linear algebra in python\nPandas dataframes\nPlotting and visualisation\n\nClasses:\n\n1 lecture per week (Thursday)\n1 small-group tutorial per two weeks (date should be on calendar)"
  },
  {
    "objectID": "01/week_01_slides.html#lectures",
    "href": "01/week_01_slides.html#lectures",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Lectures",
    "text": "Lectures\n\nThe weekly lecture will consist of\n\n≈ 30-40 minutes presentation time covering:\nKey concepts\nAdministrative points (e.g. homework submission etc)\nCode Demonstrations#\n\n≈ 1-1.5 hours practical\nDesigned to provide hands on experience\nOpportunity to ask for help from\n\nLecturer\nPhD helpers\nEach other!"
  },
  {
    "objectID": "01/week_01_slides.html#assignments",
    "href": "01/week_01_slides.html#assignments",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Assignments",
    "text": "Assignments\n\nFormative:\n\nWeekly (optional) assignments available on quarto\n\nSummative:\n\nThis module is 100% coursework\n4 pieces of coursework\nAssignment 1 (15%)\nAssignment 2 (30%)\nAssignment 3 (15%)\nAssignment 4 (40%)\n\nAssignments 1-3 will be exercises\nAssignment 4 will be different\n\nProject report analysing a dataset"
  },
  {
    "objectID": "01/week_01_slides.html#online-material",
    "href": "01/week_01_slides.html#online-material",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Online Material",
    "text": "Online Material\n\nThe course material is available online via:\n\nQuarto – online searchable version\nNoteable – interactive interface we shall work in during class"
  },
  {
    "objectID": "01/week_01_slides.html#accessing-noteable",
    "href": "01/week_01_slides.html#accessing-noteable",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Accessing Noteable",
    "text": "Accessing Noteable\n\nOpen Blackboard\nGo to Introduction to Coding and Data Analysis for Scientists 2025\nClick Unit Information and Resources\nOpen Noteable\n\nMake sure Jupyter Classic (Legacy) is selected.\nClick Start\n\nClick +GitRepo\nPaste into Git Repository URL: git@github.com:TomMaullin/SCIF10002-2025.git\nPress clone"
  },
  {
    "objectID": "01/week_01_slides.html#introduction-to-coding",
    "href": "01/week_01_slides.html#introduction-to-coding",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Introduction to Coding",
    "text": "Introduction to Coding\n\nIn this module, we shall be learning to code in Python\nPython is a programming language\n\n\n\nIn the same way humans communicate using different languages, there are many languages we can use to communicate with a computer\nPython is particularly useful for:\n\nAnalysing data\nMaking plots and visualisations\nRunning simulations\nMachine learning and AI"
  },
  {
    "objectID": "01/week_01_slides.html#learning-to-code",
    "href": "01/week_01_slides.html#learning-to-code",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Learning to Code",
    "text": "Learning to Code\n\nIn fact, learning to code is a lot like learning a language\nWhen learning French, you might:\n\nLearn many phrases\nPractice writing sentences\nSpeak to people who know the language\n\nYou can’t learn a language by listening to other people describe it…\nHands-on experience and regular practice are crucial!"
  },
  {
    "objectID": "01/week_01_slides.html#getting-started",
    "href": "01/week_01_slides.html#getting-started",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Getting Started",
    "text": "Getting Started\n\nSo… what actually is coding?\nYou can think of writing code as like writing a recipe…\n\nYou might start by specifying some ingredients…\nThen list some instructions…\nTo get a desired output\n\nCoding is pretty similar"
  },
  {
    "objectID": "01/week_01_slides.html#getting-started-1",
    "href": "01/week_01_slides.html#getting-started-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Getting Started",
    "text": "Getting Started\n\nYou might start by specifying some inputs…\nThen list some instructions…\nTo get a desired output\n\n\n\n\n\n\n\nHere we are producing some output that might be difficult to compute or evaluate by hand."
  },
  {
    "objectID": "01/week_01_slides.html#assigning-variables",
    "href": "01/week_01_slides.html#assigning-variables",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Assigning Variables",
    "text": "Assigning Variables\n\n\n\n\n\n\n\nIn this code, x and y are variables\nThese are named pieces of data which we can use for future computations\nThe = symbol is the assignment operator.\n\nUnlike in maths, this is an instruction\nE.g. x=7 means “Save the integer 7 under the variable name x”"
  },
  {
    "objectID": "01/week_01_slides.html#data-types",
    "href": "01/week_01_slides.html#data-types",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Data Types",
    "text": "Data Types\n\n\n\n\n\n\n\nWhen writing the recipe, some foods were of the “same type”\n\nE.g. we had 2 eggs\n\nIn the same way, in coding we have different types of data\nToday, we shall look at some of these\nUnderstanding data types is important, as we want to use different data types for different tasks"
  },
  {
    "objectID": "01/week_01_slides.html#numeric-data-types",
    "href": "01/week_01_slides.html#numeric-data-types",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Numeric Data Types",
    "text": "Numeric Data Types\n\n\n\n\n\n\n\nThe most ubiquitous data types are numeric\n\nIntegers: Whole numbers/Integers\nℤ = {…, -3, -2, -1, 0, 1, 2, 3,… }\n\nFloats: Decimal numbers\n\nℝ = Real numbers\nWe can convert between float’s and integers using the float and int functions.\n\nWhat do you think might happen if we convert y to an integer?\n\nWarning: A computer cannot actually describe arbitrarily small and large numbers – it approximates instead"
  },
  {
    "objectID": "01/week_01_slides.html#strings",
    "href": "01/week_01_slides.html#strings",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Strings",
    "text": "Strings\n\nA string is a sequence of characters. Strings can contain:\n\nLetters\nNumbers (treated as characters)\nPunctuation\nSpaces\nCombinations of the above\nNothing at all\n\n\n\n\n\n\n\n\n\nIn practice, there are many things we may want to do with text in Python\n\nSplit it into sentences\nSearch through it\nReplace words\n\n\nAfter todays practical you will be able to perform some of these operations!"
  },
  {
    "objectID": "01/week_01_slides.html#booleans",
    "href": "01/week_01_slides.html#booleans",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Booleans",
    "text": "Booleans\n\nA Boolean is variable that can be either True or False\nBooleans represent logical statements.\nFor instance, we might think of:\n\ncat_is_black as representing the sentence “The cat is black”\ncat_has_four_legs as representing the sentence “The cat has four legs”\n\nWe can use logical operators to combine Boolean statements\n\ncat_is_black and cat_has_four_legs represents the sentence “The cat is black and has four legs”"
  },
  {
    "objectID": "01/week_01_slides.html#booleans-1",
    "href": "01/week_01_slides.html#booleans-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Booleans",
    "text": "Booleans"
  },
  {
    "objectID": "01/week_01_slides.html#collections",
    "href": "01/week_01_slides.html#collections",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Collections",
    "text": "Collections\n\nWe’ve now seen some simple examples of datatypes:\n\nNumeric, strings, and booleans.\n\nData types don’t always have to be this simple!\n\nSometimes we need data types that can hold more complex information.\n\nWe’ll see more examples throughout the course but for now we’ll provide just one\nA collection is any in-built data type that can group multiple objects together.\nThe most common collection is a list: an ordered group of items.\n\nLists let you store, organize, and work with many values at once."
  },
  {
    "objectID": "01/week_01_slides.html#practical",
    "href": "01/week_01_slides.html#practical",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe have students from a range of courses and backgrounds in this class\n\nChemistry\nPhysics\nData Science\n\nSome people in the room will have less experience than others\nFor the first few weeks, we shall try to account for the differences in ability where possible"
  },
  {
    "objectID": "01/week_01_slides.html#practical-1",
    "href": "01/week_01_slides.html#practical-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe now move over to Python\nPlease open week_01_home.ipynb\nFor the rest of today, you must work through a Python notebook\nYou have a choice of one of three options\n\nOption 1: Beginner - Basic Data Types\nOption 2: Intermediate - Collections\nOption 3: Advanced - Copying and References"
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html",
    "href": "01/week_01_intro_to_data_types_beginner.html",
    "title": "Beginner: Basic Data Types",
    "section": "",
    "text": "Welcome to the Week 1 Beginner Python Notebook. This notebook is designed for students who are just starting out with the Python programming language.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are an important part of the learning process and will help you check your understanding.\nIn this notebook, you will be introduced to the numeric, boolean, and string Python data types. Gaining experience with these data types is essential, as they form the foundation for everything else you will learn in Python.\nBe sure to work through the examples and attempt all the exercises. They are designed to reinforce your learning and build your confidence.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#what-are-data-types",
    "href": "01/week_01_intro_to_data_types_beginner.html#what-are-data-types",
    "title": "Beginner: Basic Data Types",
    "section": "What are Data Types?",
    "text": "What are Data Types?\nWriting code is a lot like writing a recipe for cooking. When writing a recipe, you might first list some ingredients, then give a careful sequence of steps, with the end result being some tasty and (hopefully!) digestible baked goods. Coding works the same way; we start with some inputs (the ingredients), ask the computer to perform a series of steps and produce some easy-to-digest result (the outputs).\nIn the same way that ingredients can be referred to as objects in the real-world, we refer to the data we use in coding as objects too.\nFurthermore, when cooking we might refer to objects by types of food. For instance, we may want to use 2 apples and an orange in a recipe, as opposed to 3 generic “food-objects”. Similarly, when coding we refer to types of data, or data types.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#basic-data-types",
    "href": "01/week_01_intro_to_data_types_beginner.html#basic-data-types",
    "title": "Beginner: Basic Data Types",
    "section": "Basic Data Types",
    "text": "Basic Data Types\nIn Python there are many different data types with some of the most commonly used built-in data types being:\n\ninteger and floating point scalars\nboolean values\nstrings\ntuples\nlists\nsets\ndictionaries\n\n\nNote: This list is by no means comprehensive. Other data types are also supported through common packages (e.g., numpy, scipy, ...) and it is even possible to make your own custom datatypes! For now we will just focus on the built-in datatypes. However, packages such as numpy and pandas will be explored in later notebooks.\n\nThe “type” of a variable can be found using the type() function in python. Try changing and running the below code to see how this function is used.\n\n\n\n\n\n\nIn the above code, a, b, …, g are variables. A variable is a named reference to a piece of data, created using the = (assignment) operator. The type of a variable describes the kind of data it stores. For example, a stores an integer (a whole number), so its type is int.\n\nNote: Python allows for scientific notation for floats (decimal numbers). For example, in the above code 1.1e-6 means 1.1 times 10 to the minus 6.\n\nValues of variables can also be displayed with the print() function. If given many arguments, the print statement will print all of them. Try this below:\n\n\n\n\n\n\nBy default, a Jupyter notebook will treat the last line of a code box as a print statement if it can.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#integers-and-floats",
    "href": "01/week_01_intro_to_data_types_beginner.html#integers-and-floats",
    "title": "Beginner: Basic Data Types",
    "section": "Integers and floats",
    "text": "Integers and floats\nWhen first getting to grips with python, you can think of integers as “whole numbers” and floats as “numbers including decimals”. Integers are represented with the int datatype and floats are represented with the float datatype. Basic mathematical operations are available for int types and float types. Try a few below:\n\nWarning: A common mistake made by new users of Python is to use ^ for exponentiation (e.g. \\(2^5\\)). In fact, in Python ^ represents the logical XOR operator and the ** operator represents exponentiation. By performing your own research online, see if you can work out what the XOR function is doing here.\n\n\n\n\n\n\n\nYou can combine operations using round brackets, ( and ), much in the same way you would in everyday math. For example:\n\n\n\n\n\n\nOften, you may hear it mentioned that Python allows for arbitrary precision integers. This means that Python can accurately manipulate very large numbers stored as ints. For example;\n\n\n\n\n\n\n\nWarning: Although ints can store arbitrary precision whole numbers in Python, floats cannot!! Failure to realize this can result in all sorts of strange errors. For example, consider the below;\n\n\n\n\n\n\n\n\nCheck your understanding: What’s the difference between / and //? Why might 3 * 0.1 not equal 0.3 exactly in Python?",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#strings",
    "href": "01/week_01_intro_to_data_types_beginner.html#strings",
    "title": "Beginner: Basic Data Types",
    "section": "Strings",
    "text": "Strings\nIn this section we are going to look more at strings.\nA string is a finite sequence of characters (e.g., letters, numbers, symbols and punctuation marks). In python, strings can be specified with either double of single quotes like so:\n\n\n\n\n\n\nAn important characteristic of each string is its length, which is the number of characters in it. The length can be any natural number (i.e., zero or any positive integer). In python we can see the length of a string by using the len() function. In fact, this function can be used to assess the length of many different variable types such as lists, tuples, sets and so on (more on those later).\n\n\n\n\n\n\n\nBrief interlude: In Python, you can add comments to your code using the # symbol. Comments are lines of text that are ignored when the code runs, but they play an important role in explaining what your code is doing. Writing clear and meaningful comments as you code is considered best practice. It helps others (and your future self) understand your logic and what you are trying to do. Below is a simple example that shows how to use comments in Python. Make sure you are comfortable with this, as commenting is a crucial habit for anyone working with code.\n\n\n\n\n\n\n\n\nCheck your understanding: What is the difference between print(2 + 3) and print(\"2\" + \"3\")? What happens if you try x = \"hello\" + 5? Using the below box, write some code to answer these questions.\n\n\n\n\n\n\n\n\nString manipulation\nPython has many useful tools for manipulating strings. One such function is the format function, which allows you to insert variables of different types into strings. Note that x in the below example does not need to be a string.\n\n\n\n\n\n\nAnother useful tool is the concatenation operater; +. Concatenation in programming is another way for saying “join together”. See the below for an example of how this is done.\n\n\n\n\n\n\nIn fact, the previous example could be done using concatenation instead of the format funtion. Note though that we must be careful and convert x from an integer to a string, using str(), in this case.\n\n\n\n\n\n\nOther useful functions for string manipulation include\n\nstrip; which, by default, removes any white space from the beginning and end of a string. However, you can also specify which characters you wish to remove.\nsplit; splits a string by specified character (known as a seperator), and returns a list. By default, the separator is a space and this function splits a sentence into individual words.\nreplace; this returns a string with some specified value replaced with another specified value.\nupper; this makes a string all uppercase.\nlower; this makes a string all lowercase.\n\nSeveral examples are given below. Please make sure you understand what each of these functions does before moving on to the next section. There are many other functions available and a good resource for learning about each individual function and trying them for yourself is the w3 schools python reference site.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#booleans",
    "href": "01/week_01_intro_to_data_types_beginner.html#booleans",
    "title": "Beginner: Basic Data Types",
    "section": "Booleans",
    "text": "Booleans\nA boolean in python is a variable that can be either True or False. For instance:\n\n\n\n\n\n\nBooleans arise in all sorts of situations. For example, consider the below code:\n\n\n\n\n\n\nYou should see it print True, which makes sense as 128 is indeed larger than 100. Try changing the numbers above; can you make this print False?\nIn this code, the expression 128 &gt; 100 is a boolean statement. We can make this clearer like so:\n\n\n\n\n\n\nThe above code is identical to the previous, but we have now saved the True/False value as my_boolean.\nSome common boolean operators include:\n\nnot: This negates the value of a variable (i.e. turns True to False and False to True).\nand: This is a logical and.\nor: This is a logical or.\nis: This checks whether two variables point to the same object in memory.\n==: This checks whether two variables are equal in value (Note: This shouldn’t be confused for the assigment operator; =).\n!=: This checks whether two variables are not equal in value.\n\nBoolean operators in Python are designed to be intuitive and as close to natural language as possible. The below code demonstrates how the boolean operations and, or, == and != and not are used. Try changing the values of a and b to ensure you understand how these operations work.\n\n\n\n\n\n\nOther common relational expressions which give True/False output include &lt;=, &gt;=, &lt; and &gt; for numeric datatypes (e.g. ints and floats) and in for collection datatypes (such as lists or tuples, which we shall look at next).",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#casting-between-data-types",
    "href": "01/week_01_intro_to_data_types_beginner.html#casting-between-data-types",
    "title": "Beginner: Basic Data Types",
    "section": "Casting Between Data Types",
    "text": "Casting Between Data Types\nIn Python the data type of a variable is dynamic. This means that you do not need to specify the data type beforehand and that it can easily be changed. For example, try moving the type statement before and after the sum in the below block and see how the output is changed. Why does the output change?\n\n\n\n\n\n\nSeveral inbuilt functions are available for converting between types. The most commonly used of these are the int, float and str functions. Try these out below. Caution: Note how converting z back to a float does not give the original value x. Why do you think this is?\n\n\n\n\n\n\nThe act of converting one data type to another is often referred to as casting. For instance, in the above code, we cast x from a float to a string and then from a string to an integer.\n\nCheck your Understanding: What happens if you try int(\"10.5\")? Why might you convert a number to a string using str()? Use the below code box to answer these questions.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#exercises",
    "href": "01/week_01_intro_to_data_types_beginner.html#exercises",
    "title": "Beginner: Basic Data Types",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Below are three variables x, y and z. By using the operators introduced in the Booleans section of this notebook, construct a boolean variable, my_boolean which is true if and only if \\(y\\) lies strictly between \\(x^2\\) and \\(z^3\\). That is, my_boolean should be true if and only if either \\(x^2&lt;y&lt;z^3\\) or \\(z^3&lt;y&lt;x^2\\).\n\n\n\n\n\n\nQuestion 2: In the below code, we have two boolean variables; is_raining and have_umbrella. We will assume that these represent the sentences “It is raining outside” and “I have my umbrella with me”, respectively.\n\n\n\n\n\n\nWe will assume that you are going to get wet if and only if it is raining outside and you do not have your umbrella. Using logical operators (e.g. and, or, not…), make a new boolean variable that tells you if you are going to get wet.\n\n\n\n\n\n\nQuestion 3: In this question, we are interested in three boolean variables A, B and C. By performing your own research online, write down (on paper) a “Truth Table” for the expression (A and B) or (not C). Your table should have the following columns:\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\nA and B\nnot C\n(A and B) or (not C)\n\n\n\n\nTrue\nTrue\nTrue\n\n\n\n\n\nTrue\nTrue\nFalse\n\n\n\n\n\nTrue\nFalse\nTrue\n\n\n\n\n\nTrue\nFalse\nFalse\n\n\n\n\n\nFalse\nTrue\nTrue\n\n\n\n\n\nFalse\nTrue\nFalse\n\n\n\n\n\nFalse\nFalse\nTrue\n\n\n\n\n\nFalse\nFalse\nFalse\n\n\n\n\n\n\nIn the following box, write some code which computes (A and B) or (not C). By changing the values of A, B and C check the correctness of your truth table.\n\n\n\n\n\n\nQuestion 4: Below are two variables representing the width and height of a rectangle. Write some code that computes the area, perimeter and length of the diagonal of the rectangle. Your code should print the results.\n\n\n\n\n\n\nQuestion 5: An object dropped from a height satisfies the SUVAT equations. In particular, it satisfies the following equation:\n\\[v^2 = u^2 + 2as\\]\nwhere - \\(v\\) is the final velocity, - \\(u\\) is the initial velocity, - \\(a\\) is the acceleration, equal to gravity in this case, - \\(s\\) is the distance.\nGiven the object is at rest initially and it’s final velocity is \\(10\\) meters per second, write code to compute the distance it has fallen.\n\n\n\n\n\n\nQuestion 6: Building on your answer to Question 5, by researching the SUVAT equations and writing code below, compute the time in seconds that the object spends in freefall.\n\n\n\n\n\n\nQuestion 7: Without running code, predict the result of these, then check your answers in Python:\n\n(True and False) or True\nnot (False or False)\nTrue or False and False\nFalse ^ True\n(True and not True) and (False or not False)\n\n\n\n\n\n\n\nHint: You may wish to look up Truthy and Falsy values.\nQuestion 8: The below code takes two numbers, x and y and computes \\(z=\\frac{x+y}{y^2}\\). For instance, when we set \\(x=1\\) and \\(y=5\\) we get \\(z=0.24\\).\n\n\n\n\n\n\nSuppose you were change the inputs, x and y, to 2 and 5. Work out by hand what you would expect \\(z\\) to equal.\nThe below code is the same as the above but the values of x and y have been changed. This time, something has gone wrong! z does not give the expected value. Explain what has happened and how you would fix it.\n\n\n\n\n\n\nQuestion 9: Explain why the first code box below prints nothing but the second prints True.\n\n\n\n\n\n\n\n\n\n\n\n\nHint: Consider the below variable z. What is it’s datatype?\n\n\n\n\n\n\nGiven your answer to the above, you may expect the below code to also print True.\n\n\n\n\n\n\nHowever, it doesn’t! Why do you think this is?\nHint: Try printing (0.1 + 0.2) and 0.3 seperately. What do you notice?\nQuestion 10: In the code block below, you are given 12 strings:\n\none start_string\n\nten “helper” strings (string1 to string10)\n\none end_string\n\nYour task is to transform the start_string into the end_string using only:\n\nthe start_string\n\nthe helper strings (string1 … string10)\n\nthe .replace() function\n\nA complete solution can be given in 5 replacement steps. We’ve given you the first step to get you started.\nHint: You might not need all ten helper strings.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy_solutions.html",
    "href": "08/exercises_lecture_working_with_numpy_solutions.html",
    "title": "Exercises - Working with NumPy",
    "section": "",
    "text": "Create a 1D NumPy array arr of integers from 10 to 19. Access the element at index 3."
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy_solutions.html#exercise-9-problem-solving-with-numpy",
    "href": "08/exercises_lecture_working_with_numpy_solutions.html#exercise-9-problem-solving-with-numpy",
    "title": "Exercises - Working with NumPy",
    "section": "Exercise 9: Problem solving with NumPy",
    "text": "Exercise 9: Problem solving with NumPy\nConsider the following problem:\n\nA panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.\n\nThe problem is a two-dimensional problem. The passenger has coordinates \\(x(t), y(t)\\) and is performing uniform rotational motion, with angular velocity \\(\\omega\\) and radius \\(R\\).\nThe angle formed at which the passenger is located is \\(\\theta(t)\\) and simply evolves as\n\\[\\theta(t) = \\omega t +\\theta_0\\]\nwhere \\(\\theta_0\\) is the initial angle (\\(\\theta_0=0\\) in our case).\nHence, the trajectory is expressed by\n\\[\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n\\]\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\nThe first approach is via using vanilla Python\n\n\n\n\n\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on avoiding for loops and using NumPy’s array operations instead."
  },
  {
    "objectID": "09/exercises_plotting_data_from_file_solutions.html",
    "href": "09/exercises_plotting_data_from_file_solutions.html",
    "title": "Plotting data from file",
    "section": "",
    "text": "How can we use what we have learnt in the past few workshops to read data from a file? And how can we plot this?\nOne way to then plot this data would be to extract the index and/or multiple columns we are interested in plotting and use matplotlib as we have done before.\nAs an example, we’ll look at a new data file. This contains a simulation of the (fractional) concentration change for two species in a reaction, “A” and “B” where \\(A \\rightarrow B\\).\n\n\n\n\n\n\nIf we open this file more directly in Python when we looked at a text file) we can take quick look at the contents to see what this looks like:\n\n\n\n\n\n\nFrom printing out the first 200 characters, we can see this looks like a table of data with each column separated by spaces. This looks nicely formatted with a title row including the column names and no extra header rows.\nWe will see in the next year that there are dedicate packages to manipulate large tabulated files. However, for now we can exploit numpy as a quick and effective way to read such input.\n\n\n\n\n\n\nThis is a special kind of array called a structured array, because it has named fields. You can check this by querying the subproperties of the array:\n\n\n\n\n\n\nThese various names are the fields of the array, corresponding to the columns in the file. This syntax is reminiscent of what we have seen in the case of dictionaries, where keys are used to specific other objects stored in the dictionary.\n\n\n\n\n\n\nThis data also has a column for “Time” as the number of seconds elapsed.\n\n\n\n\n\n\nTo create a plot for time vs concentration of A, we can extract this data from our array\n\n\n\n\n\n\nWe could then use matplotlib to plot this:\n\n\n\n\n\n\nThis simulation shows a clean relationship as concentration decreases over time (in an exponential way).\nSuppose we want to filter our data and plot only concentrations less than 0.5. We can simply create a boolean array that masks the invalid data.\n\n\n\n\n\n\nHere we have filtered our data to include all fractional concentrations less than (or equal to) 0.5. Notice we have also matched our time values to plot to these concentrations by extracting the index from our new array concentration_A_low.\n\n\n\n\n\n\nYou can also see the slope is similiar (in fact it is the same) between our unfiltered and filtered data (this is due to the exponential relationship).\n\n\nExercise\n\nRe-plot the un-filtered graph created above and add another line to show concentration of B vs time from the data_kinetic_k0005 array on the same plot.\n\n\nCan you include a label for A and B?\n\n\n\n\n\n\n\n\nCalculate the the sum of the concentrations for these two columns (A and B).\n\n\n\n\n\n\n\n\nRe-plot the graph created in the previous question and add this sum as a third line.\n\n\nConsider: What does this sum tell us about “A” is decaying into “B”?\n\n\n\n\n\n\n\n\nWe add the sum of concentrations (A+B) as a third line to the plot. This sum remains very close to 1 throughout the reaction, indicating that as “A” decays, it is converted into “B” without significant loss or gain of total concentration. This demonstrates conservation of mass in the reaction: all of “A” is accounted for as it becomes “B”."
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html",
    "href": "09/fun_matplotlib_decoration.html",
    "title": "Add some decoration",
    "section": "",
    "text": "There are two options below of template plots to build upon: a tree and a snowman.\nAs a group, decorate an image (or multiple images) and when completed you can save this figure to file (uncomment the appropriate cell to do so). This can then be downloaded from Noteable and uploaded to the Padlet with your group name:\nhttps://uob.padlet.org/fturci/adding-decorations-zk4khqfwj17l2377"
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html#decorate-a-tree",
    "href": "09/fun_matplotlib_decoration.html#decorate-a-tree",
    "title": "Add some decoration",
    "section": "Decorate a tree",
    "text": "Decorate a tree\nThe code below creates the outline of a tree which you can add your decoration to:"
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html#decorate-a-snowman",
    "href": "09/fun_matplotlib_decoration.html#decorate-a-snowman",
    "title": "Add some decoration",
    "section": "Decorate a snowman",
    "text": "Decorate a snowman\nAs an alternative, the code below creates the outline of a snowman which you can add features to:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSome options in matplotlib\nHere are some examples of some matplotlib options and functionality that you could use:\n\n\n\n\n\n\n\n\nMore options\nColour options: - https://matplotlib.org/3.1.0/gallery/color/named_colors.html\nMarker and line style options: - https://matplotlib.org/stable/api/markers_api.html - https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html\nPatches (Rectangle, Circle, Polygon) - https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html - https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Polygon.html - https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Circle.html\nOr look in the matplotlib gallery to see if anything provides inspiration: - https://matplotlib.org/stable/gallery/index.html\n\nExtra Challenge: can you use random number generation to add detail to your picture?"
  },
  {
    "objectID": "07/lecture_intro_numpy.html",
    "href": "07/lecture_intro_numpy.html",
    "title": "The numpy module",
    "section": "",
    "text": "A collection of many functions is called a module. One of the most useful modules in Python is called numpy (numerical Python) – it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we’ve been focussing on so far but now comes as standard in most Python installations.\nThe numpy module builds on the core functionality but also adds additional features including:\n\nIt is performant which means it is well optimised\nIt offers additional numerical computing tools\nIt adds an additional object called an n-dimensional array\n\n\n\nOne thing we can use the numpy module for is to create a new object called a numpy array. This is another data structure, in addition to the in-built Python types we’ve been learning about, and is similiar to a list.\n\n\n\nNumpy arrays\n\nNumpy module (and arrays) are a Python extension (but often come as standard)  Ordered  Mutable  Less flexible - One data type per array  Allows implicit element-wise operations  Generally quicker (optimised) More memory efficient\n\nLists\n\nLists are part of Python in-built functionality  Ordered  Mutable  Very flexible - All types in any list  Needs explicit element-wise operations  Generally slower performance Less memory efficient\n\n\nWhen using these objects, list objects are highly flexible, in both content and shape whereas numpy.array objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n\n\nnumpy.array objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\nTo use the numpy module we first need to import it.\n\n\n\n\n\n\nThe as part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case np. This is the convention most often used for the numpy module. import statements themselves are the way we access additional Python modules such as numpy or matplotlib.\nOne way to create a numpy.array is from a list:\n\n\n\n\n\n\nwhere we need the np. at the start of the function to tell python to access the numpy module.\nWe can also index and slice numpy.arrays in a similar way to other iterable objects (i.e. objects with length like lists):\n\n\n\n\n\n\nAnd a numpy.array has an additional properties (attributes) called dtype which tells us what is contained within the array and shape which tells us the dimensions of the array.\n\n\n\n\n\n\n\n\n\nThe numpy module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we’ve shown before one way to act on every item in a list using a for loop:\n\n\n\n\n\n\nThere is actually a short hand for creating a new list using a for loop for very simple operations called a list comprehension.\n\n\n\n\n\n\nBut this is still more complex than using a numpy.array, where the same operation can be performed using an operator directly on the whole array:\n\n\n\n\n\n\n\n\n\nFor large numbers of elements the time difference between operations using lists and numpy.arrays can start to be measurable. We can quickly check this my importing the time module:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparing the two operations we can see that performing this operation with the list takes longer than within a numpy.array (this is highly variable though):\n\n\n\n\n\n\nYou may recall, when we first introduced list and dict objects, we also mentioned other Python objects which were similar but with some differences in functionality (tuple and set objects). In Python, as in many languages, there are often many tools which can be used to complete a task and it’s up to you to choose the correct tool for the job. Overall, list objects may be more appropriate when you need to store a set of strings or if you don’t know the number of elements in advance (appending to a list is faster than appending to an numpy.array due to the way the data is stored in memory). Whereas numpy.array objects would be more appropriate when performance is a factor or for simpler numerical operations."
  },
  {
    "objectID": "07/lecture_intro_numpy.html#what-is-the-numpy-module",
    "href": "07/lecture_intro_numpy.html#what-is-the-numpy-module",
    "title": "The numpy module",
    "section": "",
    "text": "A collection of many functions is called a module. One of the most useful modules in Python is called numpy (numerical Python) – it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we’ve been focussing on so far but now comes as standard in most Python installations.\nThe numpy module builds on the core functionality but also adds additional features including:\n\nIt is performant which means it is well optimised\nIt offers additional numerical computing tools\nIt adds an additional object called an n-dimensional array\n\n\n\nOne thing we can use the numpy module for is to create a new object called a numpy array. This is another data structure, in addition to the in-built Python types we’ve been learning about, and is similiar to a list.\n\n\n\nNumpy arrays\n\nNumpy module (and arrays) are a Python extension (but often come as standard)  Ordered  Mutable  Less flexible - One data type per array  Allows implicit element-wise operations  Generally quicker (optimised) More memory efficient\n\nLists\n\nLists are part of Python in-built functionality  Ordered  Mutable  Very flexible - All types in any list  Needs explicit element-wise operations  Generally slower performance Less memory efficient\n\n\nWhen using these objects, list objects are highly flexible, in both content and shape whereas numpy.array objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n\n\nnumpy.array objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\nTo use the numpy module we first need to import it.\n\n\n\n\n\n\nThe as part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case np. This is the convention most often used for the numpy module. import statements themselves are the way we access additional Python modules such as numpy or matplotlib.\nOne way to create a numpy.array is from a list:\n\n\n\n\n\n\nwhere we need the np. at the start of the function to tell python to access the numpy module.\nWe can also index and slice numpy.arrays in a similar way to other iterable objects (i.e. objects with length like lists):\n\n\n\n\n\n\nAnd a numpy.array has an additional properties (attributes) called dtype which tells us what is contained within the array and shape which tells us the dimensions of the array.\n\n\n\n\n\n\n\n\n\nThe numpy module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we’ve shown before one way to act on every item in a list using a for loop:\n\n\n\n\n\n\nThere is actually a short hand for creating a new list using a for loop for very simple operations called a list comprehension.\n\n\n\n\n\n\nBut this is still more complex than using a numpy.array, where the same operation can be performed using an operator directly on the whole array:\n\n\n\n\n\n\n\n\n\nFor large numbers of elements the time difference between operations using lists and numpy.arrays can start to be measurable. We can quickly check this my importing the time module:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparing the two operations we can see that performing this operation with the list takes longer than within a numpy.array (this is highly variable though):\n\n\n\n\n\n\nYou may recall, when we first introduced list and dict objects, we also mentioned other Python objects which were similar but with some differences in functionality (tuple and set objects). In Python, as in many languages, there are often many tools which can be used to complete a task and it’s up to you to choose the correct tool for the job. Overall, list objects may be more appropriate when you need to store a set of strings or if you don’t know the number of elements in advance (appending to a list is faster than appending to an numpy.array due to the way the data is stored in memory). Whereas numpy.array objects would be more appropriate when performance is a factor or for simpler numerical operations."
  },
  {
    "objectID": "07/lecture_intro_numpy.html#working-with-numpy",
    "href": "07/lecture_intro_numpy.html#working-with-numpy",
    "title": "The numpy module",
    "section": "Working with numpy",
    "text": "Working with numpy\nTo use the numpy module we always need to start by using an import statement. In this case we import the numpy module and use the shorthand np:\n\n\n\n\n\n\n\n\n\n\n\n\nWe’ve seen that we can apply operators directly to a numpy.array:\n\n\n\n\n\n\nSimilarly you can use additional functions provided by the numpy module to do something to each element in the array. For example you can apply a square root:\n\n\n\n\n\n\nOr perform a reductive operation such as calculating the mean of all the elements:\n\n\n\n\n\n\nWe can also apply mathematical operations over the whole array. For instance we can look at the np.cos function which produces applies the cosine function element-wise:\n\n\n\n\n\n\nThe help states that this wants an array-like object and wants the input in radians. We can write this as:\n\n\n\n\n\n\nIf we look at arr1 we can see that this has not been updated by the application of these operations - when using this functionality a copy of the array is returned which you can choose to re-assign to the original variable name or create a new variable:"
  },
  {
    "objectID": "07/lecture_intro_numpy.html#element-wise-operations-on-1d-arrays",
    "href": "07/lecture_intro_numpy.html#element-wise-operations-on-1d-arrays",
    "title": "The numpy module",
    "section": "Element-wise operations on 1D arrays",
    "text": "Element-wise operations on 1D arrays\nElement-wise operations in numpy allow you to perform arithmetic or mathematical functions on each corresponding element of arrays. For example, if you have two arrays of the same length, arr1 and arr2, you can add them directly: arr1 + arr2. This will produce a new array where each element is the sum of the elements at the same position in the original arrays. Similarly, you can use other operators (-, *, /) or numpy functions (np.sqrt(arr1), np.cos(arr1)) to apply operations to each element individually. The arrays must have compatible shapes for these operations.\n\n\n\n\n\n\n\n\n\n\n\n\nWhen 1D arrays have different lengths, you need to be careful about the operations you perform. Element-wise operations: Operations such as arr1 + arr3 or arr1 * arr3 require arrays to have the same length or compatible shapes. If the lengths differ, numpy will raise a ValueError due to shape mismatch."
  },
  {
    "objectID": "07/lecture_intro_numpy.html#basic-operations-on-1d-arrays",
    "href": "07/lecture_intro_numpy.html#basic-operations-on-1d-arrays",
    "title": "The numpy module",
    "section": "Basic operations on 1D arrays",
    "text": "Basic operations on 1D arrays\nSumming all elements in a 1D numpy array can be done with np.sum(arr1).\nFor cumulative summing, use np.cumsum(arr1), which returns an array where each element is the sum of all previous elements.\nSorting is performed with np.sort(arr1), which returns a sorted copy of the array.\nTo concatenate two arrays, use np.concatenate([arr1, arr2]). This joins the arrays end-to-end, creating a new array containing all elements from both arrays in order. Concatenation is useful for combining datasets or extending arrays.\nTo find unique elements, use np.unique(arr1), which returns an array of the distinct values in arr1. These operations are efficient and commonly used for data analysis."
  },
  {
    "objectID": "07/exercises_numpy.html",
    "href": "07/exercises_numpy.html",
    "title": "numpy Exercises",
    "section": "",
    "text": "These exercises test your understanding of the NumPy concepts covered in the introduction notebook."
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-1-import-and-basic-array-creation",
    "href": "07/exercises_numpy.html#exercise-1-import-and-basic-array-creation",
    "title": "numpy Exercises",
    "section": "Exercise 1: Import and Basic Array Creation",
    "text": "Exercise 1: Import and Basic Array Creation\nTask: Import NumPy with the standard import command and create a NumPy array from the list [2, 4, 6, 8, 10, 12]. Print the array, its data type, and its shape."
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-2-array-indexing-and-slicing",
    "href": "07/exercises_numpy.html#exercise-2-array-indexing-and-slicing",
    "title": "numpy Exercises",
    "section": "Exercise 2: Array Indexing and Slicing",
    "text": "Exercise 2: Array Indexing and Slicing\nTask: Using the array you created in Exercise 1:\n\nPrint the first element\nPrint the last element\nPrint elements from index 2 to 4 (inclusive of 2, exclusive of 5)\nPrint every second element"
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-3-element-wise-operations",
    "href": "07/exercises_numpy.html#exercise-3-element-wise-operations",
    "title": "numpy Exercises",
    "section": "Exercise 3: Element-wise Operations",
    "text": "Exercise 3: Element-wise Operations\nTask: Create a NumPy array arr = np.array([1, 4, 9, 16, 25]). Perform the following operations and print the results:\n\nMultiply each element by 3\nAdd 10 to each element\nCalculate the square root of each element\nApply the sine function to each element"
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-4-array-operations-with-two-arrays",
    "href": "07/exercises_numpy.html#exercise-4-array-operations-with-two-arrays",
    "title": "numpy Exercises",
    "section": "Exercise 4: Array Operations with Two Arrays",
    "text": "Exercise 4: Array Operations with Two Arrays\nTask: Create two NumPy arrays:\n\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([10, 20, 30, 40, 50])\n\nPerform element-wise operations and print the results:\n\nAdd the two arrays\nSubtract arr1 from arr2\nMultiply the two arrays\nDivide arr2 by arr1"
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-5-shape-mismatch-error",
    "href": "07/exercises_numpy.html#exercise-5-shape-mismatch-error",
    "title": "numpy Exercises",
    "section": "Exercise 5: Shape Mismatch Error",
    "text": "Exercise 5: Shape Mismatch Error\nTask: Create two arrays with different lengths:\n\narr_a = np.array([1, 2, 3, 4])\narr_b = np.array([10, 20])\n\nTry to add these arrays together. What happens? Write the code and explain the error in a comment."
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-6-reductive-operations",
    "href": "07/exercises_numpy.html#exercise-6-reductive-operations",
    "title": "numpy Exercises",
    "section": "Exercise 6: Reductive Operations",
    "text": "Exercise 6: Reductive Operations\nTask: Create a NumPy array data = np.array([12, 8, 15, 3, 7, 20, 11, 9]). Calculate and print:\n\nThe sum of all elements\nThe mean (average) of all elements\nThe maximum value\nThe minimum value\nThe standard deviation"
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-7-array-manipulation",
    "href": "07/exercises_numpy.html#exercise-7-array-manipulation",
    "title": "numpy Exercises",
    "section": "Exercise 7: Array Manipulation",
    "text": "Exercise 7: Array Manipulation\nTask: Create a NumPy array numbers = np.array([5, 2, 8, 1, 9, 3]). Perform the following operations:\n\nSort the array and print the result\nCalculate the cumulative sum and print the result\nCreate a new array with duplicates: with_duplicates = np.array([5, 2, 8, 1, 9, 3, 5, 2, 1]) and find the unique elements"
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-8-list-vs-numpy-comparison",
    "href": "07/exercises_numpy.html#exercise-8-list-vs-numpy-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 8: List vs NumPy Comparison",
    "text": "Exercise 8: List vs NumPy Comparison\nTask: Compare the flexibility of lists vs NumPy arrays:\n\nCreate a Python list containing mixed data types: mixed_list = [1, 'hello', 3.14, True]\nTry to create a NumPy array from this list. What happens to the data types?\nCreate a list of numbers: num_list = [1, 2, 3, 4, 5]\nTry to multiply the entire list by 2 using num_list * 2. What happens?\nCreate a NumPy array from the same numbers and multiply by 2. Compare the results."
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-9-performance-comparison",
    "href": "07/exercises_numpy.html#exercise-9-performance-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 9: Performance Comparison",
    "text": "Exercise 9: Performance Comparison\nTask: Compare the performance of list comprehension vs NumPy operations:\n\nImport the time module\nCreate a range of 50,000 numbers using numpy np.arange()\nTime how long it takes to square each number using a list comprehension, i.e. the syntax [x**2 for x in myarray]\nTime how long it takes to square each number using NumPy operations\nCalculate and print how many times faster the NumPy operation is"
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-10-complex-operations",
    "href": "07/exercises_numpy.html#exercise-10-complex-operations",
    "title": "numpy Exercises",
    "section": "Exercise 10: Complex Operations",
    "text": "Exercise 10: Complex Operations\nTask: Create a NumPy array representing angles in degrees: angles_deg = np.array([0, 30, 45, 60, 90, 120, 180]) 1. Convert these angles to radians (hint: multiply by π/180, use np.pi) 2. Calculate the sine and cosine of each angle 3. Verify that sin²(x) + cos²(x) = 1 for each angle (use np.sin() and np.cos()) 4. Print all results"
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-1-temperature-conversion",
    "href": "07/exercises_numpy.html#challenge-1-temperature-conversion",
    "title": "numpy Exercises",
    "section": "Challenge 1: Temperature Conversion",
    "text": "Challenge 1: Temperature Conversion\nTask: You have temperature readings in Celsius: celsius_temps = np.array([0, 10, 20, 25, 30, 35, 40])\n\nConvert all temperatures to Fahrenheit using the formula: F = (C × 9/5) + 32\nConvert all temperatures to Kelvin using the formula: K = C + 273.15\nCalculate the temperature range (max - min) for each scale"
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-2-kinetic-energy",
    "href": "07/exercises_numpy.html#challenge-2-kinetic-energy",
    "title": "numpy Exercises",
    "section": "Challenge 2: Kinetic energy",
    "text": "Challenge 2: Kinetic energy\nTask Given arrays of mass (kg) and velocity (m/s) for several objects:\n# copy and paste this code below\nmasses = np.array([2.0, 1.5, 3.0, 0.5])      # in kilograms\nvelocities = np.array([10.0, 20.0, 15.0, 5.0]) # in meters per second\n\nCalculate the kinetic energy \\(K\\) for each object using the formula:\n\n\\[K =  \\dfrac{1}{2}m v^2\\]\n\nCalculate the total kinetic energy of the system (sum of all objects)"
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-3-temperature-analysis",
    "href": "07/exercises_numpy.html#challenge-3-temperature-analysis",
    "title": "numpy Exercises",
    "section": "Challenge 3: Temperature Analysis",
    "text": "Challenge 3: Temperature Analysis\nTask: Given a NumPy array of daily temperatures for 30 days:\ntemperatures = np.array([23.5, 24.0, 21.2, 25.6, 22.8, 23.9, 26.1, 27.3, 21.7, 22.5,\n                         24.6, 25.8, 20.9, 22.3, 24.7, 26.0, 27.5, 21.0, 22.9, 24.8,\n                         25.9, 27.6, 20.8, 22.7, 24.5, 26.2, 27.7, 20.5, 22.6, 24.9])\nPerform the following tasks:\n\nFind the top 3 hottest days and their temperatures.\nCalculate the day-to-day percentage change in temperature."
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#introduction-to-matplotlib",
    "href": "slides/09_intro_matplotlib_slides.html#introduction-to-matplotlib",
    "title": "Plotting with matplotlib",
    "section": "Introduction to matplotlib",
    "text": "Introduction to matplotlib\nmatplotlib - Powerful Python library for creating visualizations\nimport matplotlib.pyplot as plt\nimport numpy as np\nKey concepts: - Figure: The canvas - Axes: The x-y plotting area - Object-oriented approach (recommended)\nfig, ax = plt.subplots()  # Create figure and axes"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#two-plotting-approaches",
    "href": "slides/09_intro_matplotlib_slides.html#two-plotting-approaches",
    "title": "Plotting with matplotlib",
    "section": "Two Plotting Approaches",
    "text": "Two Plotting Approaches\nPyplot (MATLAB-style):\nplt.plot(x, y)  # Direct plotting\nObject-oriented (Recommended):\nfig, ax = plt.subplots()\nax.plot(x, y)  # Plot using axes object\nWhy object-oriented? - More explicit control - Better for complex plots - Modern best practice"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#basic-plot-types",
    "href": "slides/09_intro_matplotlib_slides.html#basic-plot-types",
    "title": "Plotting with matplotlib",
    "section": "Basic Plot Types",
    "text": "Basic Plot Types\n# Sample data\nrng = np.random.default_rng(seed=124)\nx = np.arange(1, 20, 2)\ny1 = x**2\ny2 = x**2 + rng.normal(size=len(x))*50\n\nfig, ax = plt.subplots()\nax.plot(x, y1, label=\"Line plot\")        # Line plot\nax.scatter(x, y2, label=\"Scatter plot\")  # Scatter plot\nax.legend()"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#customizing-appearance",
    "href": "slides/09_intro_matplotlib_slides.html#customizing-appearance",
    "title": "Plotting with matplotlib",
    "section": "Customizing Appearance",
    "text": "Customizing Appearance\nfig, ax = plt.subplots(figsize=(8, 4))\n\n# Styling options\nax.plot(x, y1, color=\"slategrey\", linestyle=\"--\", linewidth=2)\nax.scatter(x, y2, color=\"indianred\", marker='+', s=60)\n\n# Labels and limits\nax.set_xlabel(\"X values\")\nax.set_ylabel(\"Y values\")\nax.set_xlim(0, 20)\nax.set_title(\"Customized Plot\")"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#common-style-options",
    "href": "slides/09_intro_matplotlib_slides.html#common-style-options",
    "title": "Plotting with matplotlib",
    "section": "Common Style Options",
    "text": "Common Style Options\nColors: Named colors, hex codes, RGB - color=\"red\", color=\"#FF0000\", color=(1,0,0)\nLine styles: - linestyle=\"-\" (solid), \"--\" (dashed), \":\" (dotted)\nMarkers: - marker=\"o\" (circle), \"+\" (plus), \"^\" (triangle)\nTransparency: - alpha=0.7 (70% opaque)"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#legends-and-annotations",
    "href": "slides/09_intro_matplotlib_slides.html#legends-and-annotations",
    "title": "Plotting with matplotlib",
    "section": "Legends and Annotations",
    "text": "Legends and Annotations\nfig, ax = plt.subplots()\n\nax.plot(x, y1, label=\"Fitted line\", color=\"blue\", linestyle=\"--\")\nax.scatter(x, y2, label=\"Measurements\", color=\"red\", marker='o')\n\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\") \nax.legend()  # Uses the label parameters\nax.set_title(\"Plot with Legend\")"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#histograms",
    "href": "slides/09_intro_matplotlib_slides.html#histograms",
    "title": "Plotting with matplotlib",
    "section": "Histograms",
    "text": "Histograms\n# Generate random data\nrng = np.random.default_rng(seed=68)\ndata1 = rng.normal(0, 1, 5000)\ndata2 = rng.normal(1, 1.5, 1000)\n\nfig, ax = plt.subplots()\nbins = np.arange(-4, 6, 0.3)\n\nax.hist(data1, bins=bins, alpha=0.7, color=\"skyblue\", \n        density=True, label=\"Dataset 1\")\nax.hist(data2, bins=bins, alpha=0.7, color=\"orange\", \n        density=True, label=\"Dataset 2\")\n\nax.set_xlabel(\"Value\")\nax.set_ylabel(\"Density\")\nax.legend()"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#histogram-options",
    "href": "slides/09_intro_matplotlib_slides.html#histogram-options",
    "title": "Plotting with matplotlib",
    "section": "Histogram Options",
    "text": "Histogram Options\nKey parameters: - bins: Number or explicit bin edges - alpha: Transparency (0-1) - density: Normalize to show probability density - histtype: ‘bar’, ‘step’, ‘stepfilled’\nfig, ax = plt.subplots()\nax.hist(data1, bins=30, alpha=0.6, histtype='step', \n        color='purple', linewidth=2)"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#multiple-plots-on-same-axes",
    "href": "slides/09_intro_matplotlib_slides.html#multiple-plots-on-same-axes",
    "title": "Plotting with matplotlib",
    "section": "Multiple Plots on Same Axes",
    "text": "Multiple Plots on Same Axes\nfig, ax = plt.subplots(figsize=(10, 5))\n\n# Multiple data series\nx_vals = np.linspace(0, 2*np.pi, 100)\ny1 = np.sin(x_vals)\ny2 = np.cos(x_vals)\ny3 = np.sin(2*x_vals)\n\nax.plot(x_vals, y1, label=\"sin(x)\")\nax.plot(x_vals, y2, label=\"cos(x)\", linestyle='--')\nax.scatter(x_vals[::10], y3[::10], label=\"sin(2x)\", marker='o')\n\nax.legend()\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#anatomy-of-a-figure",
    "href": "slides/09_intro_matplotlib_slides.html#anatomy-of-a-figure",
    "title": "Plotting with matplotlib",
    "section": "Anatomy of a Figure",
    "text": "Anatomy of a Figure\n\nMatplotlib anatomy shows the components: Figure, Axes, Labels, Legend, Ticks, etc.Key components: - Figure: Overall container - Axes: Plot area with data - Axis labels: x/y descriptions\n- Ticks: Scale markers - Legend: Data series identification"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#figure-size-and-layout",
    "href": "slides/09_intro_matplotlib_slides.html#figure-size-and-layout",
    "title": "Plotting with matplotlib",
    "section": "Figure Size and Layout",
    "text": "Figure Size and Layout\n# Control figure size\nfig, ax = plt.subplots(figsize=(12, 6))\n\n# Multiple subplots (brief example)\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\nax1.plot([1, 2, 3], [1, 4, 2])\nax2.scatter([1, 2, 3], [2, 1, 3])\nax1.set_title(\"Plot 1\")\nax2.set_title(\"Plot 2\")"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#best-practices",
    "href": "slides/09_intro_matplotlib_slides.html#best-practices",
    "title": "Plotting with matplotlib",
    "section": "Best Practices",
    "text": "Best Practices\n\nAlways label your axes\nUse legends for multiple data series\nChoose appropriate plot types for your data\nControl figure size for readability\nUse colors wisely - consider colorblind accessibility\nKeep it simple - don’t over-decorate\n\n# Good example\nfig, ax = plt.subplots(figsize=(8, 5))\nax.plot(x, y1, label=\"Data\")\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Amplitude (V)\")\nax.set_title(\"Signal vs Time\")\nax.legend()"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#key-takeaways",
    "href": "slides/09_intro_matplotlib_slides.html#key-takeaways",
    "title": "Plotting with matplotlib",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nmatplotlib is the standard Python plotting library\nObject-oriented approach with fig, ax is recommended\nCustomization options for colors, styles, markers\nMultiple plot types: line, scatter, histogram\nAlways annotate with labels, legends, titles\nPractice with different plot types and styling options"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#file-system-navigation",
    "href": "slides/11_beyond_notebook_slides.html#file-system-navigation",
    "title": "Beyond the Notebook",
    "section": "File System Navigation",
    "text": "File System Navigation\nNotebooks exist in directories - we can navigate using bash commands\nKey commands (use ! prefix in notebooks):\n# Current directory location\n! pwd\n\n# List files and directories\n! ls\n\n# Create new directory\n! mkdir new_folder\n\n# Change directory\n! cd new_folder\n! cd ..  # Go back to parent directory"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#working-with-files",
    "href": "slides/11_beyond_notebook_slides.html#working-with-files",
    "title": "Beyond the Notebook",
    "section": "Working with Files",
    "text": "Working with Files\nCreating and viewing files:\n# Create empty file\n! touch filename.txt\n\n# View file contents\n! cat filename.txt\n\n# View first/last lines\n! head filename.txt\n! tail filename.txt\nFile system navigation: - . = current directory - .. = parent directory - Paths can be absolute (/full/path) or relative (folder/file)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#python-scripts-vs-notebooks",
    "href": "slides/11_beyond_notebook_slides.html#python-scripts-vs-notebooks",
    "title": "Beyond the Notebook",
    "section": "Python Scripts vs Notebooks",
    "text": "Python Scripts vs Notebooks\nNotebooks (.ipynb): - Rich multimedia content - Markdown, images, metadata - Interactive development - Complex file format\nScripts (.py): - Pure Python code only - Comments with # - Simple text files - Portable and lightweight"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#running-scripts",
    "href": "slides/11_beyond_notebook_slides.html#running-scripts",
    "title": "Beyond the Notebook",
    "section": "Running Scripts",
    "text": "Running Scripts\nFrom notebook:\n# Using the 'run' magic command\nrun path/to/script.py\nFrom terminal:\n# Using python command\npython path/to/script.py\nExample script (hello.py):\nprint(\"Hello, World!\")\nx = 42\nprint(f\"The answer is {x}\")"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#the-terminal",
    "href": "slides/11_beyond_notebook_slides.html#the-terminal",
    "title": "Beyond the Notebook",
    "section": "The Terminal",
    "text": "The Terminal\nText-based interface to the operating system\nAccessing terminal: - In Noteable: New → Terminal - Pure command-line environment - No mouse interaction - Uses bash scripting language\nBasic terminal workflow: 1. Navigate to directory (cd) 2. Create/edit files (touch, text editor) 3. Run Python scripts (python script.py)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#creating-python-modules",
    "href": "slides/11_beyond_notebook_slides.html#creating-python-modules",
    "title": "Beyond the Notebook",
    "section": "Creating Python Modules",
    "text": "Creating Python Modules\nScripts can be imported as modules:\nStep 1: Create math_utils.py:\ndef add_numbers(a, b):\n    return a + b\n\ndef square(x):\n    return x ** 2\n\nPI = 3.14159\nStep 2: Import and use:\nimport math_utils as mu\n\nresult = mu.add_numbers(5, 3)\narea = mu.PI * mu.square(radius)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#practical-example-plotting-module",
    "href": "slides/11_beyond_notebook_slides.html#practical-example-plotting-module",
    "title": "Beyond the Notebook",
    "section": "Practical Example: Plotting Module",
    "text": "Practical Example: Plotting Module\nCreate plotting.py:\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plot_parabola(a, b, c, xlo=0, xhi=10, npoints=100):\n    x = np.linspace(xlo, xhi, npoints)\n    y = a * x**2 + b * x + c\n    \n    plt.figure()\n    plt.plot(x, y, 'b-', linewidth=2)\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.title(f'Parabola: y = {a}x² + {b}x + {c}')\n    plt.grid(True)\n    plt.show()"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#using-custom-modules",
    "href": "slides/11_beyond_notebook_slides.html#using-custom-modules",
    "title": "Beyond the Notebook",
    "section": "Using Custom Modules",
    "text": "Using Custom Modules\nImport your module:\nimport plotting as plt_mod\n\n# Use your custom function\nplt_mod.plot_parabola(a=1, b=-2, c=1)\nBenefits of modules: - Reusability: Use same code across projects - Organization: Separate concerns - Maintainability: Update code in one place - Collaboration: Share functionality"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#bash-command-options",
    "href": "slides/11_beyond_notebook_slides.html#bash-command-options",
    "title": "Beyond the Notebook",
    "section": "Bash Command Options",
    "text": "Bash Command Options\nCommands often have options using - syntax:\n# List files in long format\nls -l\n\n# List files in reverse time order\nls -lt\n\n# Get help for any command\ncommand_name --help\nCommon file operations:\n# Move/rename files\nmv old_name.py new_name.py\n\n# Copy files\ncp source.py destination.py\n\n# Remove files (careful!)\nrm filename.py"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#script-vs.-notebook-output",
    "href": "slides/11_beyond_notebook_slides.html#script-vs.-notebook-output",
    "title": "Beyond the Notebook",
    "section": "Script vs. Notebook Output",
    "text": "Script vs. Notebook Output\nNotebook execution: - Output appears inline - Variables remain in memory - Interactive environment\nScript execution: - Output goes to terminal/file - No persistent variables - One-time execution - For plots: use plt.savefig() instead of plt.show()"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#best-practices",
    "href": "slides/11_beyond_notebook_slides.html#best-practices",
    "title": "Beyond the Notebook",
    "section": "Best Practices",
    "text": "Best Practices\nWhen to use scripts: - Reusable functions - Production code - Automated tasks - Sharing with others\nWhen to use notebooks: - Exploratory analysis - Documentation with results - Teaching/presentations - Prototyping\nModule organization: - Group related functions - Clear, descriptive names - Add docstrings to functions"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#key-takeaways",
    "href": "slides/11_beyond_notebook_slides.html#key-takeaways",
    "title": "Beyond the Notebook",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nFile system navigation with bash commands\nScripts are portable, reusable Python code\nTerminal provides direct system access\nModules enable code organization and reuse\nChoose the right tool: notebooks for exploration, scripts for production\nPractice using both environments effectively\n\nNext steps: Start organizing your code into reusable modules!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Coding and Data Analysis",
    "section": "",
    "text": "This is the course material for Introduction to coding and data analysis, SCIF10002.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#welcome-to-the-course",
    "href": "index.html#welcome-to-the-course",
    "title": "Introduction to Coding and Data Analysis",
    "section": "",
    "text": "This is the course material for Introduction to coding and data analysis, SCIF10002.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Introduction to Coding and Data Analysis",
    "section": "How to use",
    "text": "How to use\n\nYou will find the more theoretical introduction under Lesson\nThe hands-on exercises will be under Exercises\nOver the course of the weeks the solutions will be released under Solutions\nRegularly, interactive formative tests will be released under Formative tests\n\nImportant. You can use the search button 🔎 to search across all the pages and skim through the course.\nNote. Many of the following pages also allow you to interact with the code by running Python snippets inside your browser. It is useful - As a fallback option if Noteable is unreachable. - For the regularly released formative tests.\nThe content in this website mirrors the interactive notebooks released on Noteable.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Getting Started",
    "text": "Getting Started\nNavigate through the course using the sidebar or the navigation menu above. Each Week builds upon the previous one, so it’s recommended to work through them in order.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Features",
    "text": "Features\n\nInteractive Jupyter notebooks\nStep-by-step exercises with solutions\nComprehensive coverage of NumPy and Matplotlib\nReal-world examples and applications",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "10/hint1_mask.html",
    "href": "10/hint1_mask.html",
    "title": "Hint 1 - creating a square mask",
    "section": "",
    "text": "Example: Creating a 100 x 100 grid containing a square where the centre of that square is at (80, 40) and the width is 30.\nTo check whether an (x, y) position is within the square we want to define, we want to evaluate if these two conditions are both satisfied: \\[|x - x_0| = w/2\\] and \\[|y - y_0| = w/2\\]\nwhere - \\(x\\), \\(y\\) are the x, y positions within the grid - \\(x_0\\), \\(y_0\\) are the centre of the square - \\(w\\) - is both the full width and height of the square - \\(| |\\) means the magnitude of the difference\nThis code will show one way to create a mask which contains a square. This will take the most direct approach and evaluate every index in the 2D array one at a time.\n\n\n\n\n\n\nStart by creating an array of zeros for our overall grid:\n\n\n\n\n\n\nNext we can define the parameters we need for the square:\n\n\n\n\n\n\nSo, to check whether a given position is within our mask (the square we are defining), we need to find a way to use our equations above and write them in code.\nWe’ve created a grid of size of 100 x 100 so, as an example, let’s use the position (50, 50) for our grid:\n\n\n\n\n\n\nNow we can build this up to look at every element in the 2D array we have created and check whether this is inside the square (we will leave the value as 0) or outside the square (we will set the value to 1). To do this we can loop through every column and every row and check the result of our conditions:\n\n\n\n\n\n\nWe don’t need an else block here because the array we have defined already contains zeros. This means if our conditin doesn’t match we don’t need to update the values within the array.\nWe could check where our mask has been set to 1 using the np.where function. For a two-dimensional array like square_mask, this will return two arrays containing the positions of the match - one for the first dimension and one for the second dimension.\nEach pair of values (one in the first array and one the second) represents a 2D position in our array:\n\n\n\n\n\n\nWe can look at this mask using matplotlib and a plotting option called imshow (documentation; example from image gallery):\n\n\n\n\n\n\nIn this plot, the white represents the values in the mask (values of 1) and the black represents the values outside the mask (values of 0).\n\n\nExtended: Leveraging numpy functionality\nAn alternative and more efficient way to do this would be to leverage the properties of numpy arrays and the available numpy functions and indexing.\nWe can start in the same way and create our array of zeros of the right shape\n\n\n\n\n\n\nWe can represent the pixel position for our x and y dimensions using numbers for 0 to 99 (for x) and 0 to 99 (for y) since our shape is 100 x 100.\nWe can then create a pair of 2D grids, X and Y, to match to the shape of our mask using a function called np.meshgrid(). This stretches our x and y coordinate values to create our 2D numpy arrays.\n\n\n\n\n\n\nWe can find the positions where our conditions are met within our grid using the np.where() function. From here we can filter our mask using integer array indexing and change these values from 0 to 1 within our mask."
  },
  {
    "objectID": "10/exercises_part1_solutions.html",
    "href": "10/exercises_part1_solutions.html",
    "title": "Answers",
    "section": "",
    "text": "Create a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n\n\n\n\n\n\n\n\n\n\n\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)"
  },
  {
    "objectID": "10/exercises_part1_solutions.html#pair-programming-part-1",
    "href": "10/exercises_part1_solutions.html#pair-programming-part-1",
    "title": "Answers",
    "section": "",
    "text": "Create a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n\n\n\n\n\n\n\n\n\n\n\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)"
  },
  {
    "objectID": "10/exercises_part1.html",
    "href": "10/exercises_part1.html",
    "title": "Creating a mask containing a circle",
    "section": "",
    "text": "As part of this activity you have been split into pairs/threes and are being asked to create code together using a technique called pair programming.\nFor this exercise, one of you will be writing the code (the driver) and the others will be directing and advising on what should be written (the navigator(s)) with lots of discussion in between. Decide between yourselves who would like each role to start with. For the second exercise you will swap some of your roles but carry on working together in the same pairs/threes."
  },
  {
    "objectID": "10/exercises_part1.html#pair-programming-part-1",
    "href": "10/exercises_part1.html#pair-programming-part-1",
    "title": "Creating a mask containing a circle",
    "section": "",
    "text": "As part of this activity you have been split into pairs/threes and are being asked to create code together using a technique called pair programming.\nFor this exercise, one of you will be writing the code (the driver) and the others will be directing and advising on what should be written (the navigator(s)) with lots of discussion in between. Decide between yourselves who would like each role to start with. For the second exercise you will swap some of your roles but carry on working together in the same pairs/threes."
  },
  {
    "objectID": "10/exercises_part1.html#how-a-mask-could-be-used",
    "href": "10/exercises_part1.html#how-a-mask-could-be-used",
    "title": "Creating a mask containing a circle",
    "section": "How a mask could be used",
    "text": "How a mask could be used\nIn this workbook, we want you to create a mask. By this we mean a square (or rectangular) grid of zeros (0s) and ones (1s) with values of 1 in the positions you want to keep and values of 0 in the positions you don’t. This mask could then be applied to another image for example:\n \nWithin the mask the edge would look something like this:\n\nwhere the thin green line represents the edge of where the real circle would be."
  },
  {
    "objectID": "10/exercises_part1.html#circle-within-a-square",
    "href": "10/exercises_part1.html#circle-within-a-square",
    "title": "Creating a mask containing a circle",
    "section": "Circle within a square",
    "text": "Circle within a square\nThe mask we want you to create should represent a circle (defined within the grid). The equation governing the edge of a circle is:\n\\[ (x-x_0)^2 + (y-y_0)^2 = r^2 \\]\nwhere\n\n\\(x\\), \\(y\\) are the x, y positions within the grid\n\\(x_0\\), \\(y_0\\) are the centre of the circle\n\\(r\\) is the radius\n\nFor example, for a circle with radius of 2 with a centre point of (4, 3), if we looked at position (5, 4), then this would be inside that circle since:\n\\[\\sqrt{((5 - 4)^2 + (4 - 3)^2)}\\] \\[ = \\sqrt{1^2 + 1^2} = \\sqrt{1 + 1} = \\sqrt{2} = 1.41\\]\nwhich is less than the radius of 2.\n\n\nExercise A\nCreate a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n\n\n\n\n\n\n\n\n\n\n\nTake time to discuss this but if you are really stuck, there is a hint notebook available which shows how you would create a mask for a square rather than a circle as an example of how you could approach this.\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)\n\nMore complex:\n\nWhat are some other ways a mask could created using the features of numpy?\n\n\nLook other numpy (np) functions e.g.\n\nmeshgrid() - link (or ogrid() - link)\nwhere() - link functions.\n\nLook at the more complex ways that numpy.array objects can be indexed - indexing multi-dimensional arrays\nConsider how values can be assigned to whole sections of an array directly."
  },
  {
    "objectID": "10/exercises_multid.html",
    "href": "10/exercises_multid.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "10/exercises_multid.html#working-with-multidimensional-arrays---exercises",
    "href": "10/exercises_multid.html#working-with-multidimensional-arrays---exercises",
    "title": "",
    "section": "Working with Multidimensional Arrays - Exercises",
    "text": "Working with Multidimensional Arrays - Exercises\nThese are pair programming exercises. Work with a partner to solve the following problems using multidimensional arrays in your chosen programming language.\n\nPart 1\nPart 2\n\nDiscuss your solutions and reasoning with your partner before moving on to the next exercise."
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html",
    "href": "11/lecture_beyond_the_notebook.html",
    "title": "Beyond the notebook",
    "section": "",
    "text": "Our notebooks in jupyter do not exist in the void. They are stored in a directory on an online account on the Noteable server. These directories have a structure, the file system, and we can navigate this structure using dedicated commands.\nThese are not python commands, but are in fact specific to the file system itself, and follow different logic and conventions. For this reason, we prepend them with the ! character. At the moment, we will use one command per cell."
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#our-file-system",
    "href": "11/lecture_beyond_the_notebook.html#our-file-system",
    "title": "Beyond the notebook",
    "section": "",
    "text": "Our notebooks in jupyter do not exist in the void. They are stored in a directory on an online account on the Noteable server. These directories have a structure, the file system, and we can navigate this structure using dedicated commands.\nThese are not python commands, but are in fact specific to the file system itself, and follow different logic and conventions. For this reason, we prepend them with the ! character. At the moment, we will use one command per cell."
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#pathway-to-the-current-directory",
    "href": "11/lecture_beyond_the_notebook.html#pathway-to-the-current-directory",
    "title": "Beyond the notebook",
    "section": "Pathway to the current directory",
    "text": "Pathway to the current directory\nFirst, let’s check where we are right now in the file system. To do so, we query the pathway to the working directory with the pwd command.\n\n\n\n\n\n\nThis shows where we currently are, and each of you should have a different path, with a different username."
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#listing-the-content-of-the-current-directory",
    "href": "11/lecture_beyond_the_notebook.html#listing-the-content-of-the-current-directory",
    "title": "Beyond the notebook",
    "section": "Listing the content of the current directory",
    "text": "Listing the content of the current directory\nThe ls command lists the files and directories in the current directory. The current directory is represented by a . (dot)."
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#creating-a-new-directory",
    "href": "11/lecture_beyond_the_notebook.html#creating-a-new-directory",
    "title": "Beyond the notebook",
    "section": "Creating a new directory",
    "text": "Creating a new directory\nThe mkdir command creates a new directory in the specified path. For example, to create a new directory in the current directory we can write\n\n\n\n\n\n\nWe can check its existence with ls.\n\n\n\n\n\n\nEqually, we can go back to the jupyter interface and see the new directory in the graphical user interface."
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#changing-directory",
    "href": "11/lecture_beyond_the_notebook.html#changing-directory",
    "title": "Beyond the notebook",
    "section": "Changing directory",
    "text": "Changing directory\nIt is easy to change the current directory with the cd command. For example, to go to the new_directory with\n\n\n\n\n\n\nAnd we we can go back to the previous directory with the cd command again using .."
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#creating-an-empty-file",
    "href": "11/lecture_beyond_the_notebook.html#creating-an-empty-file",
    "title": "Beyond the notebook",
    "section": "Creating an empty file",
    "text": "Creating an empty file\nThe touch command creates a new file in the specified path. For example, to create a new file in the current directory we can write\n\n\n\n\n\n\nWe can check its existence with ls.\n\n\n\n\n\n\nWe can open this file in the graphical user interface and edit the contents\n[follows demonstration in Noteable with dummy text in the file new_file.txt]"
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#viewing-file-content",
    "href": "11/lecture_beyond_the_notebook.html#viewing-file-content",
    "title": "Beyond the notebook",
    "section": "Viewing file content",
    "text": "Viewing file content\nThe cat command prints the content of a file. For example, to view the content of new_file.txt we can write\n\n\n\n\n\n\nSeveral other commands exist to display parts of files, such as head, tail etc. Try them if you like!"
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise",
    "href": "11/lecture_beyond_the_notebook.html#exercise",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\n\nCreate a new jupyter notebook using the graphical user interface.\nFrom the notebook, use the commands above to create:\n\na new directory called src\na new file inside the directory called naive_script.py\nopen it with double click for the files tab in jupyter and write a minimal code\n\nprint(\"Hello, World!\")\n\nsave the file\nuse the cat command from the notebook to view the content of naive_script.py"
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#running-scripts-from-the-notebook",
    "href": "11/lecture_beyond_the_notebook.html#running-scripts-from-the-notebook",
    "title": "Beyond the notebook",
    "section": "Running scripts: from the notebook",
    "text": "Running scripts: from the notebook\nFor the entire duration of this course, you have been running python codes by typing them inside the notebook cells and executing the code cells.\nThe notebooks are complex files, that contain a lot of information beyond your code: the markdown, images, and a lot of extra data (called metadata).\nA much more essential way to store python code is to use scripts. These are files with the .py extension, like your naive_script.py file. Inside a script you can only have\n\npython code\npython comments to the code (i.e. lines prepended by the #)\n\nThis means that the scripts are simple, portable pure text files containing instructions in the python language.\nCan we execute such instructions? Yes, we run a script in various way. A simple way is to do it directly from a code cell in the notebook. For this we use a special jupyter command called run followed by the path to the script.\n[check that you are in the correct path and the script exist]\n\n\n\n\n\n\nAs you can see, we have executed the instructions of the script and its textual output has been printed in the notebook. No variables are created during the process."
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#the-terminal",
    "title": "Beyond the notebook",
    "section": "The Terminal",
    "text": "The Terminal\nAll the commands that we have seen above can be used in a pure-text environment called the terminal. The terminal is a text-based interface to an operating system (local or remote).\nYou do not use the mouse to perform actions. Instead, you write commands. These commands belong to the scripting language called bash (see here for more information). It is different from python, they can interact together in the notebook.\nYou can launch a terminal directly from Noteable by clicking on the New button, then selecting Terminal.\n\n\n\nimage.png"
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-1",
    "href": "11/lecture_beyond_the_notebook.html#exercise-1",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\n\nWe try to navigate folders from the terminal and create a file\nOpen the terminal and\n\nchange the directory to src (using cd)\ncreate a new file inside the directory called parabola.py (use touch)\ngo back to the Noteable file tab, refresh the web-page and open the parabola.py file\nopen it and write a minimal code to plot a parabola. For example:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\na = 1.\nb =1.\nc = 2\nxlo = 0\nxhi = 10\nnpoints = 100\nx = np.linspace(xlo, xhi, npoints)\ny = a*x**2 + b*x + c\nplt.plot(x,y)\nplt.savefig(\"parabola.png\")\n\n\nsave the file and go back to the Terminal tab\nuse the cat command to check the content"
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-running-scripts-from-the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#exercise-running-scripts-from-the-terminal",
    "title": "Beyond the notebook",
    "section": "Exercise: Running scripts from the Terminal",
    "text": "Exercise: Running scripts from the Terminal\nWe have seen that we can run the scripts from the notebook using the run command. In a very similar way, we can run scripts from the terminal, just by using the python command followed by the path to the script.\nDo the following:\n\nfirst run the parabola script from the notebook using run: you should see the plot appear in the notebook.\nthen go back to the Terminal and run the parabola.py script using the python command followed by the path to the script: e.g. python src/parabola.py. Where is the output?"
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#reusing-code",
    "href": "11/lecture_beyond_the_notebook.html#reusing-code",
    "title": "Beyond the notebook",
    "section": "Reusing code",
    "text": "Reusing code\nThe most useful feature of the scripts is that they can store code for future usage in an organized manner. We do not need to have all of our code in a single notebook: we can split the relvant bits, put them into scripts and use them again and again in different projects.\nWhat allows us to do this is the special python keywork import, that we have already used many times.\nLet’s move our working directory to src and try importing our parabola.py script\n\n\n\n\n\n\nIn python we can only import .py files, so we drop the .py extension when importing.\n\n\n\n\n\n\nNow the variables defined in parabola.py are available in our current notebook.\n\n\n\n\n\n\nCongratulations! You have written your first python module!"
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-2",
    "href": "11/lecture_beyond_the_notebook.html#exercise-2",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\nThe module above is not very useful. A better way to reuse code is to encapsulate it in a **custom .\n\nModify your parabola.py script to create a function plot_parabola that takes a, b, c, xlo, xhi as parameters.\nThen, import your parabola module in the present notebook using the following line:\nimport parabola as pb\nCan you find a way to access your function plot_parabola from pb ?\nImprove your function to customize the appearence of the plot (adding custom labels, colors, linestyles) and use the function with such changes. Important you will need to restart the notebook for these to take effect, because a module is loaded only once."
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#more-exercises-on-the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#more-exercises-on-the-terminal",
    "title": "Beyond the notebook",
    "section": "More exercises on the terminal",
    "text": "More exercises on the terminal\n\nMost commands in bash allow you to acces their documentation with &lt;name_of_the_command&gt; --help. Can you find out what the command mv does?\n\n\n\n\n\n\n\n\nFind a way to rename your parabola.py script to geometry.py\n\n\n\n\n\n\n\nMost commands in bash support options, using the dash - sytax. For example, ls -l will list the files in a long format. Can you use ls --help to find out what the -l option does\n\n\n\n\n\n\n\nCan you find an additional option for ls -l to fils files in reverse time order?"
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#riddles",
    "href": "11/lecture_beyond_the_notebook.html#riddles",
    "title": "Beyond the notebook",
    "section": "Riddles",
    "text": "Riddles\nTo revise the material from the previous lectures, we can try to solve some riddles.\nYou can find the exercises here below\n\nPython Riddles\nNumpy Riddles"
  },
  {
    "objectID": "11/exercises_numpy_riddles.html",
    "href": "11/exercises_numpy_riddles.html",
    "title": "Consolidation - numpy riddles",
    "section": "",
    "text": "Solve the following numpy riddles using numpy and its documentation.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\n\n\n\n\n\n\nDiagonal Sum: - Riddle: Write a function that takes a square 2D NumPy array as input and returns the sum of the elements along the main diagonal. - Example: diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -&gt; 15\n\n\n\n\n\n\nUnique Elements Count: - Riddle: Write a function that takes a 1D NumPy array as input and returns the count of unique elements in the array. - Example: unique_count([1, 2, 3, 2, 4, 1, 5]) -&gt; 5\n\n\n\n\n\n\nRandom sample ands cumulative sum: - Riddle: A fair coin is tossed 20 times, and we win 1£ for every head and lose 1£ for every tail. Assuming that we start with no money at the beginning, and that the seed of teh default random number generator is seed=1234, how much money do we have at every succesive step?\n\n\n\n\n\n\nRolling Window: - Riddle: Write a function that takes a 1D NumPy array and a window size as input, and returns a 2D array where each row is a sliding window of the input array of a given size. - For example, a 1d array with a rolling window of size 3: rolling_window([1, 2, 3, 4, 5], 3) -&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nHint: you can use list comprehension and convert the final list to an array.\n\n\n\n\n\n\nProduct of elements: - Riddle: The geometric mean of a number of observations \\(x_1, x_2,\\dots, x_n\\) is defined as \\(M = \\sqrt{x_1\\times x_2\\times \\dots x_n }\\). Define a custom function to calculate the geometric mean. - Example: geometric_mean([1, 2, 3, 4, 5]) -&gt; 10.954451150103322\n\n\n\n\n\n\nVectorised calculations and visualisation: - Riddle: Draw 100 thousand points uniformly distributed inside a circle of radius 1 centered at (0,0). Plot them using scatter() from matplotlib according to their radial coordinate: - use the hexadecimal colour \"#76d6ff\" for points at a distance below 0.5 from the origin$. - use the hexadecimal colour \"ffe701\" for points furtehr away.\nHint1: disk point picking is not trivial: https://mathworld.wolfram.com/DiskPointPicking.html\nHint2: For matplotlib’s plot, use the pixel style ',', and remmber to set the axis to be in the same units (\"equal\")"
  },
  {
    "objectID": "11/exercises_riddles.html",
    "href": "11/exercises_riddles.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nRiddles\nWe have two sets of riddles to test your knowledge of Python and NumPy.\n\nPython Riddles: exercises_python_riddles.qmd\nNumPy Riddles: exercises_numpy_riddles.qmd"
  },
  {
    "objectID": "formative/basic_structures.html",
    "href": "formative/basic_structures.html",
    "title": "Variables, lists, dictionaries and branches",
    "section": "",
    "text": "This is a formative test. It is an occasion to practice the course material. It does not contribute to your final grade.\nUsing the topics covered within the workshops (or otherwise), complete the questions below.\nMake sure to use any described variable names exactly and do not change the name of this file. This ensures the nbgrader tool can grade your work correctly.\n\n\n\n\nQuestion 1\n1A) Using the pi variable defined below (representing \\(\\pi\\) to 6 decimal places), calculate the circumference of a circle with radius of 5 and assign to a variable called circum_circle.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nRemember to define the radius and use the formula: circum_circle = 2 * pi * radius.\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nradius = 5\ncircum_circle = 2 * pi * radius\n\n\n\n\n\n1B) Calculate the area of a circle with radius 2.5 and assign to area_circle.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse Area = pi * radius**2.\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\narea_circle = pi * radius**2\n\n\n\n\n\n\n\nQuestion 2\n\n\n2A) Access the second name in the names list and assign to chemist.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nSecond element has index 1.\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nchemist = names[1]\n\n\n\n\n\n2B) Add \"Albert Einstein\" to the names list.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse names.append(\"Albert Einstein\").\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nnames.append(\"Albert Einstein\")\n\n\n\n\n\n\n\nQuestion 3\n\n\n3A) Access the value for quantity = \"temperature\" in quantity_units and assign to units.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nAccess dictionary values with dictionary[key].\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nunits = quantity_units[quantity]\n\n\n\n\n\n3B) For the variable second_quantity defined below, check whether this key is present in the quantity_units dictionary. If this is in the dictionary create a variable called quantity_present and assign this to a value of True, otherwise assign this to a value of False.\nNotes:\n\nYou can use the print function to check the value within your quantity_present variable (boolean). If this produces a NameError, you may need to check that quantity_present has been successfully created.\nCheck your Week 3 notes for examples of how to check membership (i.e. whether a value is contained within a collection like a list or a dictionary).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nUse key in dictionary to check membership.\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nif second_quantity in quantity_units:\n    quantity_present = True\nelse:\n    quantity_present = False\n# OR\nquantity_present = second_quantity in quantity_units\n\n\n\n\n\n\n\nQuestion 4\n4A) Two values of heights in units of feet are provided below in a list called height_feet. Convert these values to metres and calculate the difference in metres. Store this difference in a variable called height_difference_m.\nConversion from feet to metres can be done using the equation:\nThe conversion equation is: \\[ \\mathrm{height_{feet}} = \\mathrm{height_{m}} \\times 3.28084\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nConvert each height to metres and subtract: (h2 * conversion - h1 * conversion).\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\nheight_metre = [height_feet[0]/feet_per_metre, height_feet[1]/feet_per_metre]\n# or if you have learnt about loops and list comprehension\nheight_metre = [h/feet_per_metre for h in height_feet]\n\nheight_difference_m = height_metre[1]-height_metre[0]\n\n\n\n\n\n4B) Check whether height_difference_m is:\n\nIf height_difference_m is greater than 0.5 metres (50cm), create a variable called check and set this to 1\nIf height_difference_m is between 0.3 and 0.5 metres (30 to 50cm), create a variable called check and set this to 2\nIf height_difference_m is something else, create a variable called check and set this to 3\n\ndo this by constructing and if–else block.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHint\n\n\n\n\n\nYou need an if, elif else construct.\n\n\n\n\n\n\n\n\n\n\n\nFully worked solution\n\n\n\n\n\ncheck = 0\nif height_difference_m &gt; 0.5:\n    print(f\"{height_difference_m:.3f} is greater than 0.5m\")\n    check=1\nelif height_difference_m &gt; 0.3 and height_difference_m &lt;= 0.5:\n    print(f\"{height_difference_m:.3f} is greater than 0.3m but less than or equal to 0.5m\")\n    check=2\nelse:\n    print(height_difference_m)\n    check=3"
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html",
    "href": "02/week_02_booleans_and_conditionals_beginner.html",
    "title": "Beginner: If Statements",
    "section": "",
    "text": "Welcome to the Week 2 Beginner Python Notebook. This notebook is designed for students who are just starting out with the Python programming language.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are an important part of the learning process and will help you check your understanding.\nIn this notebook, you will be introduced to the if statement; a powerful feature of Python that lets you control when certain pieces of code are executed.\nBe sure to work through the examples and attempt all the exercises. They are designed to reinforce your learning and build your confidence.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#recap-booleans",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#recap-booleans",
    "title": "Beginner: If Statements",
    "section": "Recap: Booleans",
    "text": "Recap: Booleans\nLast week, we met Boolean variables. These were variables which can take the values True or False.\n\n\n\n\n\n\nWe often create booleans by comparing other variables to one another:\n\n\n\n\n\n\nWe can save the value of a boolean comparison like so:\n\n\n\n\n\n\nPython has several operators to combine or modify booleans:\n\n\n\n\n\n\nTo summarize: - Booleans are always either True or False. - Comparisons (&gt;, &lt;, ==, !=, in) produce Boolean values. - Boolean operators (not, and, or) let us combine or flip conditions.\nToday, we shall look at using Booleans to perform conditional operations. That is, we shall write code which executes only when certain circumstances hold. To do so, we shall introduce the if statement.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#the-if-statement",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#the-if-statement",
    "title": "Beginner: If Statements",
    "section": "The if Statement",
    "text": "The if Statement\nAn if statement allows you to run a block of code if and only if a boolean expression is True. Take the example in the following block, for instance. In this example, “Positive” is printed if the variable my_number is greater than \\(100\\).\n\n\n\n\n\n\n\nTest your understanding: Try changing the value of my_number in the above code to be negative. Before moving on, think about what might be happening here; How do you think the if statement decides which statements to print?\n\nLet’s break down exactly what is going on in this if statement.\nAn if always follows the same layout. First, it must include the if keyword and a colon :, like so:\n ↓                ↓\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\nIn between the if and the :, we must place a boolean variable. The idea here is that we want our code to execute (run) if and only if this boolean is true. In our example the boolean is my_number &gt; 100.\n          ↓\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\nWe next need to add a body. The body is the lines of code that will be run if the condition has been met:\nif my_number &gt; 100:\n    print(my_number, \"is large\")  ← body of the if statement\n\nPython will only recognise code as being in the body of the if statement if it is indented. This means that all code in the body must be indented relative to the word if by four spaces. A trick to help remember this is that every time you see a colon in Python you should start a new line and indent:\n                colon\n                  ↓\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n  ↑\nindentation\n\nCode that is not indented will be treated as being outside the if statement and run in the usual manner.\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\nprint(\"This is always printed\")  ← this code will always run as it is outside the if statement\n\nHere are some more examples of if statements.\n\n\n\n\n\n\nNote that, in the above examples, we have always defined our boolean variable directly between the if and colon :. We didn’t have to do this; we could have instead defined the variable first like so:\n\n\n\n\n\n\nIn practice, it’s often simpler not to define a separate boolean variable explicitly like we did above. Deciding whether to store something like x_is_positive depends partly on whether you’ll need to reuse it later and partly on personal preference.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#else",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#else",
    "title": "Beginner: If Statements",
    "section": "else",
    "text": "else\nWe’ve just seen that the body of an if statement will only run if the boolean is True. But what if we want to do one thing if it’s true, but another if it’s false? We can do this by attaching an else statement to the if statement, like so:\n\n\n\n\n\n\n\nWarning: The else statement must be at the same level of indentation as the if keyword. If not the code will throw an error, like so:",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#elif",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#elif",
    "title": "Beginner: If Statements",
    "section": "elif",
    "text": "elif\nSometimes an if-else statement isn’t enough, because you want to check more than two possibilities. For such situations, we can use the elif keyword.\nelif stands for ‘’else if’’. It lets you add extra conditions to your decision-making. For instance:\n\n\n\n\n\n\nThere are a few rules to keep in mind here:\n\nThe order matters: we start with if, then add as many elif statements as you need, and finish with an optional else.\nYou can only have one if and one else, but you can include any number of elif statements in between.\nIf one of the statements evaluates as True, the remaining code will not be executed, regardless of the truth of the remaining conditions.\n\nHere are some more examples of this concept in action.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning: Indentation is crucial for if statements in python. You must indent blocks of code within if statements as this is how the blocks of code are delineated in python.\n\n\nWarning: Make sure to remember the colon on the end of the if, elif and else statements! Without this Python, will throw an error. This error often causes many a headache for new Python users!",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#worked-example-determining-a-leap-year",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#worked-example-determining-a-leap-year",
    "title": "Beginner: If Statements",
    "section": "Worked Example: Determining a Leap Year",
    "text": "Worked Example: Determining a Leap Year\nSay we wanted to determine whether a year is a leap year (a year with 366 days rather than the usual 365).\nThe first thing we know is that a leap year generally happens every 4 years. So to start off we could impose the following condition:\n\n\n\n\n\n\n\nRecall: Last week, we saw that the % operator represents modular arithmetic. This means that a % b gives the remainder when a is divided by b. For example, 10 % 3 gives 1. The above code works as if year % 4 equals 0, then the year must be divisible by 4.\n\nThe rules for determining leap years in the Gregorian calendar are a bit more nuanced than simply being divisible by \\(4\\). In fact, if the year is also divisible by \\(100\\), then it is not a leap year (e.g., \\(1800\\), \\(1900\\), \\(2100\\)).\nWe need to add this new condition to our if statement. This can be done by combining year % 4 == 0 and year % 100 == 0 using an and clause:\n\n\n\n\n\n\nLet’s try adding a new block to account for the situation where even if the year is divisible by \\(4\\), if it is also divisible by \\(100\\) it is not a leap year.\n\n\n\n\n\n\nBut this isn’t right - we saw above that \\(1900\\) is not a leap year so this should say\nIs 1900 a leap year? No\nLet’s go through this line by line. Python checks the first criteria in the if block year % 4 == 0:\n\n\n\n\n\n\nAs this boolean is true, the if statement stops when it is evaluated and exits without checking the other clauses.\nSo how do we make sure Python checks the correct set of conditions first? To do this we have to think about the ordering of the clauses:\n\n\n\n\n\n\nNow Python checks the more strict clause first and then exits when the condition year % 100 == 0 and year % 4 == 0 is true:\n\n\n\n\n\n\nThis updated if statement now gives us the behaviour we desired.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#exercises",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#exercises",
    "title": "Beginner: If Statements",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Create a string containing your last (or first) name. Write an if statement to check if the length of this string is greater than 8. If true, print “The name is long”.\nHint: Recall the len() function can be used to check the length of strings.\n\n\n\n\n\n\nQuestion 2: The pH value of a liquid can be used to determine whether it is acidic, alkaline, or neutral. Write some code which uses the variable ph_level to assign the correct liquid_type (\"acid\", \"alkali\", or \"neutral\").\n\n\n\n\n\n\nNow, modify your code to set liquid_type=\"unknown\" if ph_level does not lie on the pH scale.\nQuestion 3: The following code is intended to classify the state of water based on its temperature in °C:\n\n\n\n\n\n\nHowever, when you run the code with temperature = 120, the output is:\nState of water: liquid\nBut at 120 °C, water should be a gas, not a liquid! Explain why this program gives the wrong result and modify the code to give the correct result.\nQuestion 4: In the code box below, the variable day_number represents the day of the year. For example, if day_number = 8, the date is January 8th, and if day_number = 32, the date is February 1st. Write an if statement that determines the current month based on the value of day_number. You may assume the year is not a leap year and that day_number is an integer strictly greater than 0 and strictly less than 366.\n\n\n\n\n\n\nQuestion 5: Now suppose you want to adapt your code from Question 4 so that day_number can fall outside the usual range of 1 to 365. For example, day_number = 366 should “wrap around” to January 1st, while day_number = 0 should correspond to December 31st. How would you modify your if statement to handle this? Write your code below. For simplicity, you may continue to ignore leap years.\n\n\n\n\n\n\nHint: The % operator might be useful here!\nQuestion 6: The code below has a distance given in kilometres. Assuming 1 mile ≈ 1.60934 km, convert the distance in km to a distance given in miles. Write code which does the following:\n\nIf the distance is greater than 2 miles, print “Distance is more than 2 miles”.\nPrint “Distance is short” if this condition is not met.\nAdd an additional check if distance_in_miles is &gt; 1 mile and print “Distance is more than 1 mile” if true.\n\n\n\n\n\n\n\nQuestion 7: The leap year example given in the worked example section is incomplete. The full definition of a leap year is as follows;\n\nA year is a leap year if it is divisible by \\(4\\) but not by \\(100\\).\n\nUnless…\n\nIf the year is divisible by \\(400\\), then it is a leap year after all (e.g., \\(2000\\), \\(2400\\)).\n\nModify the example of the worked example section to incorporate this final bullet point.\n\n\n\n\n\n\nQuestion 8: By performing your own research online, explain what the keyword pass does in the code below and why you might use it.\n\n\n\n\n\n\nWhat do you think would happen if you removed the line with pass from the code above?\nQuestion 9: FizzBuzz is a children’s counting game played with the following rules:\n\nPlayers take turns counting up from 1.\nIf a number is divisible by 3, say \"Fizz\".\nIf a number is divisible by 5, say \"Buzz\".\nIf a number is divisible by both 3 and 5, say \"FizzBuzz\".\nOtherwise, say the number itself (as a string).\n\nIt’s now your turn. You are given the previous player’s answer, prev_answer, along with the number they just counted, prev_num. Using an if–elif–else statement, print the correct response for your turn.\n\n\n\n\n\n\nModify your code so that if the previous player’s answer was incorrect, your program prints a message pointing out the mistake before giving your own response.\nQuestion 10: The code below contains a horrendous nested if statement. By combining cases using the and and or operators, reduce the long nested if statement to a single if–elif statement.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_advanced.html",
    "href": "02/week_02_booleans_and_conditionals_advanced.html",
    "title": "Advanced: Conditional Expressions and Lazy Evaluation",
    "section": "",
    "text": "Welcome to the Week 2 Advanced Python Notebook. This notebook is designed for students who already have substantial experience with Python and feel confident working with both the Beginner and Intermediate material.\nYour task today is to carefully read through the content and complete the exercises at the end. These exercises are more challenging and are intended to deepen your understanding of how Python handles data behind the scenes.\nIn this notebook, you will explore one-line if statements, conditional expressions and lazy evaluation. This will deepen your understanding of conditional logic and boolean operators in Python.\nWork through the examples carefully, and take your time with the exercises. They are designed to stretch your understanding and prepare you for advanced applications of Python.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Advanced: Conditional Expressions and Lazy Evaluation"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_advanced.html#writing-if-statements-on-one-line",
    "href": "02/week_02_booleans_and_conditionals_advanced.html#writing-if-statements-on-one-line",
    "title": "Advanced: Conditional Expressions and Lazy Evaluation",
    "section": "Writing if Statements on One Line",
    "text": "Writing if Statements on One Line\nIn Python, the syntax of an if statement appears as follows:\n\n\n\n\n\n\nPython actually allows the if statement above to be condensed to a single line, like so:\n\n\n\n\n\n\nIf the if statement contains multiple lines of code, we can combine them onto a single line using semicolons ;. For instance, the below code:\n\n\n\n\n\n\nis equivalent to:\n\n\n\n\n\n\nWe can also place elif and else statements on a single line in a similar way. For instance, the below code:\n\n\n\n\n\n\ncan be converted to:\n\n\n\n\n\n\nIn general, this sort of syntax is frowned upon, as it isn’t very easy to read. Still, it’s worth pointing out here, since it’s often mistaken for the more readable conditional expression syntax covered in the next section.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Advanced: Conditional Expressions and Lazy Evaluation"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_advanced.html#conditional-expressions",
    "href": "02/week_02_booleans_and_conditionals_advanced.html#conditional-expressions",
    "title": "Advanced: Conditional Expressions and Lazy Evaluation",
    "section": "Conditional Expressions",
    "text": "Conditional Expressions\nWhen you’re writing code, you’ll often want a variable to take on one value in some situations and a different value in others. A straightforward way to do this is with an if–else statement, like this:\n\n\n\n\n\n\nHowever, the above code is quite verbose for quite a simple operation. Sometimes, it is more convenient to represent conditional definitions of this form using a conditional expression.\n\n\n\n\n\n\nHere the conditional expression consists of everything following the equals symbol. The general syntax for a conditional expression is:\n\n&lt;expr1&gt; if &lt;conditional_expr&gt; else &lt;expr2&gt;\n\nWhen you run this, the &lt;conditional_expr&gt; expression in the center is evaluated first. If &lt;conditional_expr&gt; is evaluated as True then &lt;expr1&gt; is evaluated. Otherwise, &lt;expr2&gt; is evaluated.\nNote that this means it is possible that one of &lt;expr1&gt; or &lt;expr2&gt; are never evaluated. For instance, in the below code the first expression should give a division by zero, but because it is never evaluated, no error is thrown.\n\n\n\n\n\n\n\nTest your understanding: How could you modify the above code to throw a division by zero error?\n\nWe can incorporate conditional expressions into larger expressions using round brackets (). For instance, the below code computes \\(x+|x|\\) for an input x.\n\n\n\n\n\n\n\nTest your understanding: Can you think of a way to compute result in the above using a single conditional expression, without adding x?",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Advanced: Conditional Expressions and Lazy Evaluation"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_advanced.html#lazy-evaluation",
    "href": "02/week_02_booleans_and_conditionals_advanced.html#lazy-evaluation",
    "title": "Advanced: Conditional Expressions and Lazy Evaluation",
    "section": "Lazy Evaluation",
    "text": "Lazy Evaluation\nA conditional expression is a good example of lazy evaluation. In general, an evaluation is called lazy if only the values that are actually needed are computed. For instance, in the example from the previous section, the expression 1/0 was never evaluated - it was skipped entirely as it wasn’t needed - which is what makes the evaluation lazy.\nThe and and or operations we met last week are actually examples of lazy operations. We’ve already seen them used with Booleans, but in Python they can be applied to many other data types as well. Let’s start with a few quick examples:\n\n\n\n\n\n\nIn the first line, both operands are Booleans, so the result is False. But in the later examples, the result is not a Boolean - it’s one of the operands themselves. For instance, 5 and 10 returns 10, while 0 and 99 returns 0. To explain what’s going on here, lets consider what happens when x and y are Booleans and we compute x and y.\n\n\n\n\n\n\nIf we were computing x and y by hand, we would naturally start by looking at x. If x is False, then the whole expression must also be False - because in an and both sides need to be true. There’s no reason to even check y; we can just return the value of x (that is, False).\nIf, on the other hand, x is True, then the overall result depends entirely on y. In that case, x and y is true if and only if y is true.\nSo a simple way to describe the evaluation of x and y is:\n\nIf x is False, return x.\nIf x is True, return y.\n\nThe same evaluation rules apply even when the operands are numbers, strings, or other kinds of objects. To make this work, Python treats every value as either truthy or falsy when it’s used in a logical expression:\n\nFalsy values behave like False. These include False itself, numeric zero (0, 0.0, etc.), the empty string \"\", empty containers like [] or {}, and None.\nTruthy values behave like True. Almost everything else falls into this category: non-zero numbers, non-empty strings, non-empty lists, and so on.\n\nYou can check whether a variable is Truthy or Falsy by casting it too a Boolean. For example:",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Advanced: Conditional Expressions and Lazy Evaluation"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_advanced.html#exercises",
    "href": "02/week_02_booleans_and_conditionals_advanced.html#exercises",
    "title": "Advanced: Conditional Expressions and Lazy Evaluation",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Below are two variables x and y. Use a conditional expression to compute the maximum of x and y.\n\n\n\n\n\n\nQuestion 2: Without running code, describe what you think would happen if you ran each of the following lines of code:\n\nmy_variable = True and 1/0\nmy_variable = False and 1/0\nmy_variable = str(False and 1/0)\nmy_variable = str(False) and 1/0\n\nExplain your answers.\nQuestion 3: The below code prints the statement “This code is printed if my boolean is True.” if my_boolean is True, but doesn’t print anything otherwise. Explain why.\n\n\n\n\n\n\nQuestion 4: Based on your answer to Question 2, use the and and or operators to write code which prints \"A\" if my_boolean is True and \"B\" otherwise. Do not use if statements for this question.\n\n\n\n\n\n\nQuestion 5: In the section on Lazy Evaluation, we explained how the and operator evaluates Truthy and Falsy values by examining one variable at a time. Specifically, we saw that the expression x and y follows this rule:\n\nIf x is Falsy, return x.\nIf x is Truthy, return y.\n\nUsing the same line of reasoning, derive the corresponding rule for the or operator. Write code in the box below to test your result.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Advanced: Conditional Expressions and Lazy Evaluation"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_intermediate.html",
    "href": "02/week_02_booleans_and_conditionals_intermediate.html",
    "title": "Intermediate: Match Statements",
    "section": "",
    "text": "Welcome to the Week 2 Intermediate Python Notebook. This notebook is designed for students who already have some experience with Python and are ready to build on the basics.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are designed to deepen your understanding and give you practical experience with new concepts.\nIn this notebook, you will explore a recent addition to Python: the match statement; a powerful tool for handling multiple conditions, particularly useful when your programs need to deal with many different cases.\nBe sure to work through the examples and attempt all the exercises. They are designed to help you practice, reinforce your learning, and prepare you for the more advanced topics ahead.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Intermediate: Match Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_intermediate.html#what-is-a-match-statement",
    "href": "02/week_02_booleans_and_conditionals_intermediate.html#what-is-a-match-statement",
    "title": "Intermediate: Match Statements",
    "section": "What is a match Statement?",
    "text": "What is a match Statement?\nThe match statement is a relatively new addition to Python, having been added in Python 3.10 in 2021. This statement can be used to compare the value of a variable to different many different patterns. When it finds a match, the code inside the corresponding case block runs.\nThis is similar to using lots of if/elif checks, but can be cleaner and easier to read.\nHere’s a simple example:\n\n\n\n\n\n\nThe above code tells us what to do if we see a specific color at a traffic light. In the code, we provide the color we have seen as a string (which has been set to \"red\" in the above) and the match statement will consider a number of cases one at a time, checking whether the color variable matches the value for that case. When it finds a match, it runs the code inside that case block.\nNote that in the final case we have an underscore, _. This simply means “match anything that hasn’t already matched.” You can think of it like the else at the end of an if/elif statement. It serves as a “catch-all” to deal with any unexpected or unhandled values.\n\nTest your understanding: How might you modify the above code to allow case-sensitive examples such as color=\"ReD\" or color=\"GreEn\"? Hint: recall the lower() function from the beginner notebook in Week 1.\n\n\n\n\n\n\n\nSometimes, you may want several different inputs to trigger the same response. In such cases, instead of writing out separate case blocks for each value, we can group them together inside a single case using the pipe symbol, |. This lets us list several alternatives side by side, and if the variable matches any one of them, that case is chosen.\nFor example, in the below code we group “Saturday” and “Sunday” together, since both are weekend days:",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Intermediate: Match Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_intermediate.html#converting-long-elif-statements-to-match",
    "href": "02/week_02_booleans_and_conditionals_intermediate.html#converting-long-elif-statements-to-match",
    "title": "Intermediate: Match Statements",
    "section": "Converting Long elif Statements to match",
    "text": "Converting Long elif Statements to match\nOne of the biggest advantages of the match statement is how cleanly it handles data with complex structures.\nSuppose we want to represent different 3D solids using dictionaries. For example:\n\n\n\n\n\n\n\nNote: If you are not yet comfortable with dictionaries, please review the week 1 intermediate notebook on collections. There you will find introductory material on the dict data type.\n\nHere, solid_data describes a cylinder with a given radius and height. We might also store information for other solids:\n\n\n\n\n\n\nEach solid requires different keys: a sphere has only a radius, a rectangular prism has width, height, and depth, while a cylinder needs both radius and height.\nNow imagine we want to compute the volume automatically, regardless of which solid is described. A natural first attempt is a long chain of if-elif-else statements:\n\n\n\n\n\n\nWhile this works, it quickly becomes unwieldy. Each branch requires lots of repetition (.get(), nested ifs), and adding new shapes means adding even more clutter.\nThe match statement for this task is much simpler. This is in part due to some useful syntax; we can unpack the values inside the dictionary immediately, without using the .get() function as shown below:\n\n\n\n\n\n\nThis is much cleaner:\n\nNo need for repeated .get() calls\nNo nested if checks\nSimple, readable case syntax\n\nAnd adding a new solid is now as simple as writing one more two-line case.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Intermediate: Match Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_intermediate.html#combining-match-and-if",
    "href": "02/week_02_booleans_and_conditionals_intermediate.html#combining-match-and-if",
    "title": "Intermediate: Match Statements",
    "section": "Combining match and if",
    "text": "Combining match and if\nAnother helpful feature of the match statement is that it can be modified to include conditionals, using an if guard. This works a lot like an if statement and allows you greater control over when cases are executed. The general syntax is:\nmatch variable:\n    case pattern if condition:\n        # code to run\nHere the code will be run if and only if the variable matches the pattern and the condition is satisfied.\nFor example, suppose we’re working with points in 2D space, which we write as a tuple and wish to describe whether they lie on the cartesian axes. Then we could do the following:",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Intermediate: Match Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_intermediate.html#exercises",
    "href": "02/week_02_booleans_and_conditionals_intermediate.html#exercises",
    "title": "Intermediate: Match Statements",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Extend the match statement in the Combining match and if section so that it not only handles points on the axes, but also describes points in each of the four quadrants (upper right, lower right, lower left, upper left).\nHint: A 2D point lies in a quadrant when both \\(x\\) and \\(y\\) are nonzero. Use if guards to distinguish whether each coordinate is positive or negative.\n\n\n\n\n\n\nQuestion 2: Convert the below if-elif-else statement to a match statement:\n\n\n\n\n\n\nQuestion 3: You are given two numeric variables, a and b, along with an operator stored as a string (\"+\", \"-\", \"*\", \"/\"). Use a match statement to apply the correct operation and display the result.\nFor example, if operator = \"*\", the program should calculate and store my_result = a * b. If the operator is not one of the four listed above, your code should print \"Invalid operator\".\n\n\n\n\n\n\nQuestion 4: The variable account stores a tuple (balance, currency), where balance is the amount of money a user has and currency is the unit of that balance. The unit will be one of \"USD\", \"EUR\", \"GBP\", or \"JPY\". Your job is to convert this balance into another currency, stored in the variable target_currency (again, one of the four listed above).\nWrite a Python program using match statements to:\n\nConvert account into the requested target_currency using the exchange rates provided below.\n\nPrint the resulting balance, formatted with the correct symbol:\n\n\"USD\" → \"$\"\n\n\"EUR\" → \"€\"\n\n\"GBP\" → \"£\"\n\n\"JPY\" → \"¥\"\n\n\nIf either currency (from account) or target_currency is not one of the four supported codes, print \"Unsupported currency\".\nNote: You will have to look up the current exchange rates online (you need only use three significant figures for the conversion).\nHint: You may wish to use two match statements for this task; one converting to a single currency, say GBP, and another converting from GBP to the desired output currency.\nIf you are unsure what a Tuple is, please revisit the week 01 intermediate notebook on collections.\n\n\n\n\n\n\nQuestion 5: In digital images, colors are represented using RGB values. An RGB value is a 3-tuple (r, g, b) that gives the intensity of the red, green, and blue components of a color, each ranging from \\(0\\) to \\(255\\). For example, \\((255, 0, 0)\\) is bright red, \\((0, 255, 0)\\) is bright green, and \\((0, 0, 0)\\) is black.\nWrite a program that takes an (r, g, b) tuple as input and uses a match statement to classify the tuple into one of the following color names:\n\nRed if r is greater than 200 and both g and b are less than 50.\nGreen if g is greater than 200 and both r and b are less than 50.\nBlue if b is greater than 200 and both r and g are less than 50.\nUnknown for any other combination.\n\nThe color name should be saved as a string variable named color_name. Write your solution in the box below.\n\n\n\n\n\n\nHint: You may wish to use if guards for this question.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Intermediate: Match Statements"
    ]
  },
  {
    "objectID": "02/exercises_bool.html",
    "href": "02/exercises_bool.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nBooleans and conditionals - Exercises\nThe following exercises allow to progress at your pace discovering boolean variables and conditional statements\n\nBeginner\nIntermediate\nAdvanced\n\nThere is no requirement to succeed at all of them. Come back to these over time to check the progression of your understanding."
  },
  {
    "objectID": "02/week_02_solutions_demonstrator_version.html",
    "href": "02/week_02_solutions_demonstrator_version.html",
    "title": "Week 2: Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 2 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "02/week_02_solutions_demonstrator_version.html#beginner-if-statements",
    "href": "02/week_02_solutions_demonstrator_version.html#beginner-if-statements",
    "title": "Week 2: Solutions",
    "section": "Beginner: If Statements",
    "text": "Beginner: If Statements\nQuestion 1: The answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question aims to give students their first practice with if statements. If a student is struggling, check in with them regularly and recap strings and the len() function as needed.\n\nQuestion 2: The code for this question is below.\n\n\n\n\n\n\n\nDemonstrator Notes: Please be mindful that some students may not be familiar with the pH scale, either because they have not studied Chemistry recently or because they learned it using different terms or acronyms. Before explaining the code, check that they understand the context - they might not say anything if they are confused.\n\nQuestion 3: The problem with this code is that the boolean for the if evaluates as True when the temperature exceeds 100, so the elif is never executed. A simple solution would be to switch the order of the clauses like so:\n\n\n\n\n\n\n\nDemonstrator Notes: The students have been given a similar example, where the solution is to reorder the clauses, in the Worked Example: Determining a Leap Year section. If students are struggling with this question, please suggest they re-read this section before providing them with the answer.\n\nQuestion 4: The code for this question is below:\n\n\n\n\n\n\n\nDemonstrator Notes: Many students will not immediately think to add up the days in each month in the manner the above code has. Because of the unfamiliar logic, be ready to guide them step by step and ‘’hold their hands’’ a bit more than usual for this question.\n\nQuestion 5: One potential solution to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: Many students may struggle here because they have forgotten, or never fully grasped, the % operator. Make sure they understand this operator before giving the answer, explaining it in terms of modular/“clock” arithmetic if necessary.\n\nQuestion 6: An answer to this question is given below.\n\n\n\n\n\n\n\nDemonstrator Notes: Last year, many students really struggled with unit conversions. Check they are doing distance_km / 1.60934 instead of distance_km*1.60934.\n\nQuestion 7: A solution to this question is given below:\n\n\n\n\n\n\n\nQuestion 7: This question may feel daunting to students at first. In reality, the solution only requires adding the first clause (year % 400 == 0). One way to help is to have students test a few example years on paper before coding so the logic becomes clearer. Only encourage them to start coding once you feel they have a strong conceptual grasp of the problem.\n\nQuestion 8: The pass statement is a placeholder which effectively does nothing. If it were not there, we would have a SyntaxError as the if statement must contain code.\n\nDemonstrator Notes: This question has two purposes. First, it introduces students to the pass statement, which they will need later in the course. Second, and more importantly, it encourages them to practice using documentation and independent research. Prompt students to look up the answer online rather than giving it to them directly.\n\nQuestion 9: An answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This is a classic introduction to coding task. If student’s are struggling encourage them to search for FizzBuzz exercise python online. They will find lots of good advice which does not instantly give them the answer.\n\nQuestion 10: The desired answer is below:\n\n\n\n\n\n\nAn alternative is given by:\n\n\n\n\n\n\n\nDemonstrator Notes: Below is a step-by-step solution to reducing this problem. First, note that we can combine the x &lt; 4, x &lt; 15 and x &gt; 30 cases to get:\n\n\n\n\n\n\n\n\nNext, note that the final elif should never be evaluated as if z &lt; -1 then z &lt; 0, so the if is executed instead.\n\n\n\n\n\n\n\n\nWe can now combine the innermost if and else as follows:\n\n\n\n\n\n\n\n\nNow, note that the z &gt; 20 can’t ever be evaluated True, as if we are inside the outer if then z &lt; 0.\n\n\n\n\n\n\n\n\nWe can now combine the inner if and elif:\n\n\n\n\n\n\n\n\nBy combining the outer if and inner statements, we now get the result."
  },
  {
    "objectID": "02/week_02_solutions_demonstrator_version.html#intermediate-match-statements",
    "href": "02/week_02_solutions_demonstrator_version.html#intermediate-match-statements",
    "title": "Week 2: Solutions",
    "section": "Intermediate: Match Statements",
    "text": "Intermediate: Match Statements\nQuestion 1: The answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question aims to give the students pratice with the match statement. Before offering help, it might be worth checking that they understand the context for this question. Before offering help, check that they understand the context: less mathematical students, or non-native speakers, may not feel confident with terms like “Cartesian plane” or “quadrant.”\n\nQuestion 2: The solution to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: Because this example looks very similar when written with if statements, students may wonder what the point of match is. Point them to the section Converting Long elif Statements to match, which provides a more compelling example and highlights the advantages of match in certain situations.\n\nQuestion 3: A model answer is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: A common mistake here is confusing operators with their string forms - for example, writing \"*\" instead of *, or the reverse.\n\nQuestion 4: An example solution is provided below:\n\n\n\n\n\n\n\nDemonstrator Notes: See the notes on Beginner Question 6 about unit conversion. In this question, some students may try to code every possible pair of conversions separately (e.g. GBP -&gt; USD, GBP -&gt; EUR, … , EUR -&gt; JPY). Discourage this, as it leads to unnecessary repetition (especially if we wanted to add more currency units!). Instead, hint at the approach shown above: convert everything via a common unit, requiring only two conversions.\n\nQuestion 10: Below is a solution to this exercise:\n\n\n\n\n\n\n\nDemonstrator Notes: Some students may skip the note directing them to review tuples in the intermediate Week 1 material. Before offering help, check that they understand what a tuple is. If they do not, redirect them back to that material."
  },
  {
    "objectID": "02/week_02_solutions_demonstrator_version.html#advanced-conditional-expressions-and-lazy-evaluation",
    "href": "02/week_02_solutions_demonstrator_version.html#advanced-conditional-expressions-and-lazy-evaluation",
    "title": "Week 2: Solutions",
    "section": "Advanced: Conditional Expressions and Lazy Evaluation",
    "text": "Advanced: Conditional Expressions and Lazy Evaluation\nQuestion 1: An answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: The logic in this question is very similar to the absolute value example in the Conditional Expressions section. If students are unsure what to do here, begin by referring them back to this example.\n\nQuestion 2: The answers to this question, alongside commented code are given below:\n\n\n\n\n\n\n\nDemonstrator Notes: Explanations of the behaviour are given below:\n\nThe first statement gives a division by zero error because the left-hand side is True, so Python must also evaluate the right-hand side to determine the result of the and.\nThe second statement does not throw an error: since the left-hand side is False, Python stops there and assigns False directly to my_variable without checking the right-hand side.\nThe third statement avoids the error for the same reason as the second. Wrapping the code in str() means my_variable is assigned the string value \"False\" instead of the boolean value False.\nThe fourth case again causes a division by zero error. This is because str(False) is the string \"False\", which is a truthy value in Python (the only Falsy string is the empty string \"\"). Since it is not False, Python must evaluate the second argument 1/0, which triggers the error.\n\n\nQuestion 3: When Python evaluates an and expression, it checks the left-hand side first.\n\nIf my_boolean is True, the right-hand side (print(...)) must also be evaluated, so the message is printed.\nIf my_boolean is False, Python stops immediately, as it knows the and must be False, and the right-hand side is never run - so nothing is printed.\n\n\nDemonstrator Notes: If students are struggling with this question, first refer them to the text in the Lazy Evaluation section. This section offers a similar explanation to the above text.\n\nQuestion 4: An answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question may be challenging for students who are still new to Boolean logic. Encourage them to first rewrite the statements in plain English before attempting to code, drawing clear links between the and, or, and not operators and their plain-English meanings.\n\nQuestion 5: The rule for evaluating x or y is:\n\nIf x is Truthy, return x.\nIf x is Falsy, return y.\n\nThis is the mirror image of how and works. Some example code is given by:\n\n\n\n\n\n\n\nDemonstrator Notes: The reasoning behind the answer is as follows. Suppose x and y are Boolean values and we want to evaluate x or y. We would do the following\n\nFirst check x. If x is True, then the whole or expression is True and there is no need to check y. In this case, we return x.\nIf x is False, then we must check y. If y is True, the whole expression is True; otherwise, it is False. In either case, the result is the truth value of y, so we return y.\n\nGeneralising from Booleans, we replace True with Truthy and False with Falsy, giving the final rule:\n\nIf x is Truthy, return x.\n\nIf x is Falsy, return y."
  },
  {
    "objectID": "02/week_02_slides.html#todays-lecture",
    "href": "02/week_02_slides.html#todays-lecture",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Today’s Lecture",
    "text": "Today’s Lecture\n\nLecture 2: Booleans and Conditionals\n\nRecap: Accessing Noteable\nRecap: Booleans\nIf statements\nPractical"
  },
  {
    "objectID": "02/week_02_slides.html#why-learn-to-code",
    "href": "02/week_02_slides.html#why-learn-to-code",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Why learn to code?",
    "text": "Why learn to code?\nWhichever course you are taking you will likely need to write code at some point - Chemistry - Analyse experimental data - Automate repetitive calculations - Model chemical reactions/simulations"
  },
  {
    "objectID": "02/week_02_slides.html#why-learn-to-code-1",
    "href": "02/week_02_slides.html#why-learn-to-code-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Why learn to code?",
    "text": "Why learn to code?\nWhichever course you are taking you will likely need to write code at some point - Physics - Simulate physical systems - Process experimental measurements - Visualise complex phenomena"
  },
  {
    "objectID": "02/week_02_slides.html#why-learn-to-code-2",
    "href": "02/week_02_slides.html#why-learn-to-code-2",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Why learn to code?",
    "text": "Why learn to code?\nWhichever course you are taking you will likely need to write code at some point - Data Science - Clean and organise datasets - Apply statistical methods and machine learning - Communicate insights with visualisations"
  },
  {
    "objectID": "02/week_02_slides.html#recap-accessing-noteable",
    "href": "02/week_02_slides.html#recap-accessing-noteable",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Accessing Noteable",
    "text": "Recap: Accessing Noteable\n\nOpen Blackboard\nGo to Introduction to Coding and Data Analysis for Scientists 2025\nClick Unit Information and Resources\nOpen Noteable\n\nMake sure Jupyter Classic (Legacy) is selected.\nClick Start\n\nClick +GitRepo\nPaste into Git Repository URL: git@github.com:TomMaullin/SCIF10002-2025.git\nPress clone"
  },
  {
    "objectID": "02/week_02_slides.html#recap-last-time",
    "href": "02/week_02_slides.html#recap-last-time",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Last Time",
    "text": "Recap: Last Time\n\nLast week, we started looking at the Python language\nWe saw that variables can be assigned values using =\nTo display the values of variables we can use print\n\n\nx = 5\nprint(x)\n\n5"
  },
  {
    "objectID": "02/week_02_slides.html#recap-last-time-1",
    "href": "02/week_02_slides.html#recap-last-time-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Last Time",
    "text": "Recap: Last Time\n\nVariables have their own Data Types\n\nStrings are sequences of characters\nFloats are decimals, Ints are integers\nBooleans are True/False values\nLists are ordered groups of items\n\nWe spent some time looking at various things we could do with some of these data types\n\n\n# Int\nx = 5\n\n# String\nletters = \"hello\"\n\n# Booleans \ncat_is_black = True\n\n# A list of strings\nshopping = [\"milk\", \"bread\", \"eggs\", \"cheese\"]"
  },
  {
    "objectID": "02/week_02_slides.html#recap-booleans",
    "href": "02/week_02_slides.html#recap-booleans",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Booleans",
    "text": "Recap: Booleans\n\nA Boolean is variable that can be either True or False\nBooleans represent logical statements.\nFor instance, we saw an example where:\n\ncat_is_black represented the sentence “The cat is black”\ncat_has_four_legs represented the sentence “The cat has four legs”\n\nWe can use logical operators to combine Boolean statements\n\ncat_is_black and cat_has_four_legs represented the sentence “The cat is black and has four legs”\n\n\n\ncat_is_black = True\ncat_has_four_legs = False\nprint(cat_is_black and cat_has_four_legs)\n\nFalse"
  },
  {
    "objectID": "02/week_02_slides.html#recap-booleans-1",
    "href": "02/week_02_slides.html#recap-booleans-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Booleans",
    "text": "Recap: Booleans"
  },
  {
    "objectID": "02/week_02_slides.html#if-statements",
    "href": "02/week_02_slides.html#if-statements",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "If Statements",
    "text": "If Statements\n\nWe should be starting to feel comfortable with giving a computer instructions via code\nBut sometimes, we don’t want every line to run automatically\nInstead, we may want Python to act only when a specific condition is true\nThis is where the if statement comes in…\n\n\nprint(\"Hello World\")\n\nHello World"
  },
  {
    "objectID": "02/week_02_slides.html#if-statements-1",
    "href": "02/week_02_slides.html#if-statements-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "If Statements",
    "text": "If Statements\n\nAn if statement lets you run code when a Boolean statement is True\n\n\n# Integer value\nnumber = 5\n\n# Boolean value (true if number posiitve)\nmy_boolean = number &gt; 0\n\n# If the number is positive, print \"Positive number\"\nif my_boolean:\n    print(\"Positive number\")\n\nPositive number\n\n\n\nIndentation is important!\n\nPython tells what is in the body by looking at which code is indented!\n\nOften we don’t bother naming the boolean, and instead write it directly inside the if statement\n\n\n# Integer value\nnumber = 5\n\n# If the number is positive, print \"Positive number\"\nif number &gt; 0:\n    print(\"Positive number\")\n\nPositive number"
  },
  {
    "objectID": "02/week_02_slides.html#if-statements-2",
    "href": "02/week_02_slides.html#if-statements-2",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "If Statements",
    "text": "If Statements\n\nWe can also tell the if statement what to do when the Boolean is False by using else!\n\n\n# Integer value\nnumber = 5\n\n# If the number is positive, print \"Positive number\"\nif number &gt; 0:\n    print(\"Positive number\")\n    \n# Otherwise, print \"Non-positive number\"\nelse: \n    print(\"Non-positive number\")\n\nPositive number"
  },
  {
    "objectID": "02/week_02_slides.html#if-statements-3",
    "href": "02/week_02_slides.html#if-statements-3",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "If Statements",
    "text": "If Statements\n\nAn elif (short for else if) can be added to check more extra conditions.\n\n\n# Integer value\nnumber = 5\n\n# If the number is positive, print \"Positive number\"\nif number &gt; 0:\n    print(\"Positive number\")\n    \n# Otherwise, if the number is zero, print \"Zero\"\nelif number == 0:\n    print(\"Zero\")\n    \n# Otherwise, print \"Negative number\"\nelse: \n    print(\"Negative number\")\n\nPositive number\n\n\n\nMultiple elif can be added."
  },
  {
    "objectID": "02/week_02_slides.html#practical",
    "href": "02/week_02_slides.html#practical",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe now move over to Python\nPlease open week_02_home.ipynb\nFor the rest of today, you must work through a Python notebook\nYou have a choice of one of three options\n\nOption 1: Beginner - If Statements\nOption 2: Intermediate - Match Statements\nOption 3: Advanced - Conditional Expressions and Lazy Evaluation"
  },
  {
    "objectID": "02/week_02_home.html",
    "href": "02/week_02_home.html",
    "title": "Booleans and Conditionals",
    "section": "",
    "text": "Welcome to the second week of the 2025 SCIF10002 Introduction to Coding and Data Analysis for Scientists course! This week we shall be looking at Booleans and conditional statements.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Booleans and Conditionals"
    ]
  },
  {
    "objectID": "02/week_02_home.html#todays-material",
    "href": "02/week_02_home.html#todays-material",
    "title": "Booleans and Conditionals",
    "section": "Today’s Material",
    "text": "Today’s Material\nIn today’s class, we shall focus on the if statement. As in week 1, this week you have a choice of working through one of three notebooks.\n\nImportant: For today, please choose just one of the options below. You’ll have many opportunities to revisit the other concepts later in the course, so focus on building confidence with the Beginner material before tackling more advanced work.\n\n\nOption 1: Beginner\nIf you have not spent much time coding in Python prior to taking this course, today you should work through the If Statements notebook linked below:\n\nBeginner: If Statements\n\nThis notebook will talk you through the basics of the if statement. Please read through the text carefully and attempt all exercises!\n\n\nOption 2: Intermediate\nThis weeks intermediate notebook should only be taken by those who are very comfortable with the material in the beginner notebook. Please ensure that you are able to complete the exercises in the beginner notebook before attempting this option. The intermediate material for this week is given below:\n\nIntermediate: Match Statements\n\nThis notebook will guide you through the recently introduced Match statement, which can serve as a convenient alternative to an if-elif statement in many settings. Ensure you read through the text and attempt all exercises.\n\n\nOption 3: Advanced",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Booleans and Conditionals"
    ]
  },
  {
    "objectID": "02/week_02_home.html#getting-help",
    "href": "02/week_02_home.html#getting-help",
    "title": "Booleans and Conditionals",
    "section": "Getting Help",
    "text": "Getting Help\nThere is a lot to remember when first learning Python. To get more help see the Python API. Another useful link is the W3 schools series on Python which is very good, especially for new users. Another way to get help if you are ever unsure what a function is doing is to use thehelp function in the Python terminal like so:\n\nhelp(print)\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n    \n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\nIn class, you can ask for help from the lecturer, demonstrators and your peers around you. We advise you do not ask AI for help unless you are really stuck.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Booleans and Conditionals"
    ]
  },
  {
    "objectID": "11/exercises_numpy_riddles_solutions.html",
    "href": "11/exercises_numpy_riddles_solutions.html",
    "title": "Consolidation - numpy riddles",
    "section": "",
    "text": "Solve the following numpy riddles using numpy and its documentation.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\n\nimport numpy as np\n\nDiagonal Sum: - Riddle: Write a function that takes a square 2D NumPy array as input and returns the sum of the elements along the main diagonal. - Example: diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -&gt; 15\n\n## YOUR CODE HERE\n\ndef diagonal_sum(seq):\n    arr = np.asarray(seq)\n    return np.diagonal(arr).sum()\n\ndiagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n15\n\n\nUnique Elements Count: - Riddle: Write a function that takes a 1D NumPy array as input and returns the count of unique elements in the array. - Example: unique_count([1, 2, 3, 2, 4, 1, 5]) -&gt; 5\n\n## YOUR CODE HERE\ndef unique_count(sequence):\n    return np.unique(sequence).size\n\nunique_count([1, 2, 3, 2, 4, 1, 5]) \n\n5\n\n\nRandom sample ands cumulative sum: - Riddle: A fair coin is tossed 20 times, and we win 1£ for every head and lose 1£ for every tail. Assuming that we start with no money at the beginning, and that the seed of teh default random number generator is seed=1234, how much money do we have at every succesive step?\n\n## YOUR CODE HERE\n\nn_trials = 20\nrng = np.random.default_rng(1234)\nprint(\"The amount we have after every coin tossing is\", rng.choice([-1,1],n_trials).cumsum())\n\nThe amount we have after every coin tossing is [ 1  2  3  2  1  2  1  0 -1 -2 -1 -2 -1 -2 -1 -2 -1  0  1  0]\n\n\nRolling Window: - Riddle: Write a function that takes a 1D NumPy array and a window size as input, and returns a 2D array where each row is a sliding window of the input array of a given size. - For example, a 1d array with a rolling window of size 3: rolling_window([1, 2, 3, 4, 5], 3) -&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nHint: you can use list comprehension and convert the final list to an array.\n\n## YOUR CODE HERE\n\ndef rolling_window(seq,window):\n    arr = np.asarray(seq)\n    num_rows  = len(seq)- window + 1\n    return np.array([arr[i:i+window] for i in range(num_rows)])\n    \n\nrolling_window([1, 2, 3, 4, 5], 3)\n\narray([[1, 2, 3],\n       [2, 3, 4],\n       [3, 4, 5]])\n\n\nProduct of elements: - Riddle: The geometric mean of a number of observations \\(x_1, x_2,\\dots, x_n\\) is defined as \\(M = \\sqrt{x_1\\times x_2\\times \\dots x_n }\\). Define a custom function to calculate the geometric mean. - Example: geometric_mean([1, 2, 3, 4, 5]) -&gt; 10.954451150103322\n\n## YOUR CODE HERE\n\n\ndef geometric_mean(seq):\n    return np.sqrt(np.prod(seq))\n\n\ngeometric_mean([1, 2, 3, 4, 5])\n\n10.954451150103322\n\n\nVectorised calculations and visualisation: - Riddle: Draw 100 thousand points uniformly distributed inside a circle of radius 1 centered at (0,0). Plot them using scatplotter() from matplotlibacoording to their radial coordinate: - use the hexadecimal colour \"#76d6ff\" for points at a distance below 0.5 from the origin$. - use the hexadecimal colour \"ffe701\" for points furtehr away.\nHint1: disk point picking is not trivial: https://mathworld.wolfram.com/DiskPointPicking.html\nHint2: For matplotlib’s plot, use the pixel style ',', and remmber to set the axis to be in the same units (\"equal\")\n\n## YOUR CODE HERE\nnpoints = 100_000\ntheta = np.random.uniform(0, 2*np.pi, npoints)\nr = np.sqrt(np.random.uniform(0, 1, npoints))\nx = r * np.cos(theta)\ny = r * np.sin(theta)\n\ninside = r&lt;0.5\n\nimport matplotlib.pyplot as plt\n\nplt.plot(x[inside],y[inside],',',color=\"#76d6ff\")\nplt.plot(x[~inside],y[~inside],',',color=\"#ffe701\")\nplt.axis(\"equal\")\n\n(-1.0996463517906905,\n 1.0992516399542742,\n -1.0994327729527829,\n 1.098998268565109)"
  },
  {
    "objectID": "11/exercises_python_riddles_solutions.html",
    "href": "11/exercises_python_riddles_solutions.html",
    "title": "Consolidation - Python riddles",
    "section": "",
    "text": "Solve the following using standard Python features and built-in functions.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\nSum of Digits - Riddle: Write a function sum_digits(n) that takes an integer n and returns the sum of its digits. - Test it with the following test cases: sum_digits(145)--&gt;10 and sum_digits(102)--&gt;3\nHint: remember that you can convert an integer to a string with str(n) and a character c to integer with int(c).\n\n\n\n\n\n\nPalyndrome checker\n\nRiddle: A word is a palyndrome if it reads the same forwards and backwards. Write a function is_palindrome(s) that takes an object s, checks that it is a string and returns True if s is a palindrome and False otherwise.\nTest it with the following test cases: is_palindrome(\"racecar\")--&gt;True , is_palindrome(\"hello\")--&gt;False and is_palindrome(3)--&gt;error\n\nHint: an object is a string if typ(s) returns str."
  },
  {
    "objectID": "11/example.html",
    "href": "11/example.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "11/exercises_python_riddles.html",
    "href": "11/exercises_python_riddles.html",
    "title": "Consolidation - Python riddles",
    "section": "",
    "text": "Solve the following using standard Python features and built-in functions.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\nSum of Digits - Riddle: Write a function sum_digits(n) that takes an integer n and returns the sum of its digits. - Test it with the following test cases: sum_digits(145)--&gt;10 and sum_digits(102)--&gt;3\nHint: remember that you can convert an integer to a string with str(n) and a character c to integer with int(c).\n\n\n\n\n\n\nPalyndrome checker\n\nRiddle: A word is a palyndrome if it reads the same forwards and backwards. Write a function is_palindrome(s) that takes an object s, checks that it is a string and returns True if s is a palindrome and False otherwise.\nTest it with the following test cases: is_palindrome(\"racecar\")--&gt;True , is_palindrome(\"hello\")--&gt;False and is_palindrome(3)--&gt;error\n\nHint: an object is a string if typ(s) returns str."
  },
  {
    "objectID": "10/hint2_apply_mask.html",
    "href": "10/hint2_apply_mask.html",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "",
    "text": "Example: Applying a mask containing a rectangle to an image\nI have downloaded an online image of a house for this example (from Vector Stock). This image contains four different rooms and I want to use a rectangular mask so that only the office room is displayed. As described previously, we can open this image using a the Image sub-module of a module called pillow (imported as PIL) which understands how to read image files. We can then convert this input into a numpy array object.\nim is a three dimensional numpy array object - includes height, width and colour channel (R, G, B).\nThe imshow function knows how to interpret this 3D shape to show a colour image."
  },
  {
    "objectID": "10/hint2_apply_mask.html#create-a-rectanglar-mask-using-a-function",
    "href": "10/hint2_apply_mask.html#create-a-rectanglar-mask-using-a-function",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "Create a rectanglar mask using a function",
    "text": "Create a rectanglar mask using a function\nI can define an function called inside_rectangle() to tell me whether a given (x, y) position is within a rectangle for a set of parameters. This will return True if the position is inside the rectangle and False otherwise.\nThe rectangle can be evaluated using the conditions:\n\\[|x - x_0| = w/2\\] and \\[|y - y_0| = h/2\\]\nwhere - \\(x\\), \\(y\\) are the x, y positions within the grid - \\(x_0\\), \\(y_0\\) are the centre of the rectangle - \\(w\\), \\(h\\) - are the full width and height of the rectangle - \\(| |\\) means the magnitude of the difference\n\n\n\n\n\n\nFor this mask, I want to define the parameters as follows:\n\n\n\n\n\n\nThe inside_rectangle function allows you to pass the parameters for your position and your rectangle and can tell you whether the position is within your rectangle (returns a True value) or not (returns a False value). For example if we had a position of (50, 50) we could use the function as follows:\n\n\n\n\n\n\nHere we used the output of inside_rectangle as our condition directly (Python sees this if True or if False and follows the logic accordingly).\nWe can use the inside_rectangle() function to define our mask - looping over every element and checking the x, y position with the inside_rectangle() function with the appropriate parameters:\n\n\n\n\n\n\nAs before, we don’t need an else block here because the array we have defined already contains zeros.\nExtended: See alternative numpy method mask in Hint 1 notebook for a more efficient way to create a square mask. Could you extend this method to reproduce a rectangular mask (without the need for the inside_rectangle function)?"
  },
  {
    "objectID": "10/hint2_apply_mask.html#apply-mask-to-the-image",
    "href": "10/hint2_apply_mask.html#apply-mask-to-the-image",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "Apply mask to the image",
    "text": "Apply mask to the image\nNow we have created rect_mask, we need to apply this to my image. We can do this by multiplying im by rect_mask and this will combine element-wise. This means that each pixel in the image will be multiplied by the corresponding value within the mask. Multipying by 0 will result in the output pixel also being 0 but multiplying by 1 will retain the original value in that pixel.\nFor creating the im_masked output there a few ways you could do this - the upshot is that you want to create an array of the right shape: - Create an empty array of the right shape - Create a new variable called im_masked which is a copy of the im using the copy() function (method)\nBecause im is a three dimensional array (height x weight x colour channel), one way to apply the mask is to do this for each of the three colours (R, G, B channels) separately."
  },
  {
    "objectID": "10/exercises_part2.html",
    "href": "10/exercises_part2.html",
    "title": "Using a mask",
    "section": "",
    "text": "For the second part of this activity you will remain in the same pairs/threes as the first part and you should continue writing code in the same way using pair programming. However, you should swap your roles, so one of the people directing (the navigator) should now be writing the code (the driver) and vice versa."
  },
  {
    "objectID": "10/exercises_part2.html#pair-programming-part-2",
    "href": "10/exercises_part2.html#pair-programming-part-2",
    "title": "Using a mask",
    "section": "",
    "text": "For the second part of this activity you will remain in the same pairs/threes as the first part and you should continue writing code in the same way using pair programming. However, you should swap your roles, so one of the people directing (the navigator) should now be writing the code (the driver) and vice versa."
  },
  {
    "objectID": "10/exercises_part2.html#masking-a-galaxy",
    "href": "10/exercises_part2.html#masking-a-galaxy",
    "title": "Using a mask",
    "section": "Masking a galaxy",
    "text": "Masking a galaxy\nOne application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\n\n\n\n\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\n\n\n\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed."
  },
  {
    "objectID": "10/exercises_part2.html#creating-an-elliptical-mask",
    "href": "10/exercises_part2.html#creating-an-elliptical-mask",
    "title": "Using a mask",
    "section": "Creating an elliptical mask",
    "text": "Creating an elliptical mask\nThe inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\n\n\n\n\n\n\nEquations for an ellipse\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\n\n\n\n\n\n\n\n\nExercise B\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTake time to discuss this but if you are both really stuck, there is a hint notebook available which shows how you would apply a mask which includes a rectangle to an image."
  },
  {
    "objectID": "10/exercises_part2.html#calculating-the-magnitude",
    "href": "10/exercises_part2.html#calculating-the-magnitude",
    "title": "Using a mask",
    "section": "Calculating the magnitude",
    "text": "Calculating the magnitude\nNow that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\nExercise C\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html"
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html",
    "href": "10/lecture_multidimensionalArrays.html",
    "title": "Multi-dimensional arrays",
    "section": "",
    "text": "A numpy.ndarray is the more complete term for a numpy array object. Up until this point we have mainly been dealing with and using one dimensional arrays. Numpy arrays (unlike lists) have the concept of shape whicih means they can be multi-dimensional. This means they can represent a grid (2D), a cuboid (3D) and so forth.\nThe code below generates a numpy.array object containing random numbers. This is a 2D array with a 3 x 3 shape:\nWe can select one element from this array using the following syntax. We still use square brackets and pass an index value but now we can pass values for each dimension seperated by a comma (,). This index is selecting the third column within the second row:\nUsing slicing (Start:Stop) syntax you can select an entire dimension at once by omitting both the Start and Stop values and just using :. You can see how this works if you try the slice with just the Start or just the Stop e.g.\nNot including a Start index includes values from the beginning of the array/list etc. up to (but not including) the Stop.\nNot including a Stop index reads from the Start to the end of the array/list etc.\nSo just using : with no Start or Stop selects all elements for that dimension.\nThis following syntax returns first row (first row, every column):\nAnd this would return the first column (every row, first column):\nnumpy array objects store data in row-major order. Essentially this means for a 2D index this would be the equivalent of [y, x] rather than [x, y]."
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#basic-properties-of-multi-dimensional-arrays",
    "href": "10/lecture_multidimensionalArrays.html#basic-properties-of-multi-dimensional-arrays",
    "title": "Multi-dimensional arrays",
    "section": "Basic properties of multi-dimensional arrays",
    "text": "Basic properties of multi-dimensional arrays\n\nShape\nThe shape of a multi-dimensional array is a tuple that describes the size of each dimension. For example, a 2D array with 3 rows and 4 columns has a shape of (3, 4). You can access the shape of an array using the .shape attribute.\nWe can use many of the array initialisation functions we haver seen for 1d arrays also to create multi-dimensional arrays. For example, we can use np.zeros to create a 2D array of zeros, or np.ones to create a 2D array of ones. We can also use np.random.rand to create a 2D array of random numbers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAxis and Rank\nA multi-dimensional array has multiple dimensions, each of which can be thought of as an axis. The number of dimensions is called the rank of the array. For example, a 2D array has a rank of 2, while a 3D array has a rank of 3. It is accessible via the .ndim attribute.\nWe typically call a rank 2 array a matrix. A rank 3 array (or higher) is often called a tensor.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can perform operations along specific axes of a multi-dimensional array. For example, we can sum all the elements along a specific axis using the np.sum function with the axis parameter.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne can do the same also with useful statistical descriptors such as np.mean, np.std, etc.\n\n\n\n\n\n\n\n\nSlicing\nSlicing works similarly to 1D arrays, but you can slice along multiple axes. For example, you can slice a 2D array to get a submatrix or a specific row or column.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReshaping and flattening\nThe last example show an inetresting case: we extracted a single column from the matrix, but it is still a 2D array with shape (3, 1).\n\n\n\n\n\n\nWhat if we wanted a truly 1d array (rank 1)? We need to reshape the array.\nWe can use the np.reshape function to change the shape of an array without changing its data. For example, we can reshape a 2D array into a 1D array or vice versa.\nReshape takes a tuple of the new shape as an argument. If you want to flatten an array (convert it to a 1D array), you can use -1 as one of the dimensions, which tells NumPy to infer the size of that dimension based on the total number of elements.\n\n\n\n\n\n\n\n\n\n\n\n\nAnother way to cast a multi-dimensional array to a 1D array is to use the np.ravel() function, which returns a flattened view of the array (not a copy).\n\n\n\n\n\n\nIf we modify the view, we modify the original array as well.\n\n\n\n\n\n\nTo obtain a completely independent flattened copy of the array, you can use the np.flatten() method, which returns a copy of the array in a 1D format.\n\n\n\n\n\n\nWe can also do the opposite and increase the rank of an array by reshaping it. For example, we can reshape a 1D array into a 2D array with one column or one row.\n\n\n\n\n\n\n\n\nBroadcasting\nCombining arrays of different shapes is possible in NumPy using a feature called broadcasting. Broadcasting allows NumPy to perform operations on arrays of different shapes by automatically expanding the smaller array to match the shape of the larger one.\n\n\n\n\n\n\nYou can reshape a 1D array to a column or row vector and use broadcasting to expand it into a large table. For example, to create a table where each row is the original 1D array, or each column is the original array:"
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#two-dimensional-arrays-as-matrices-some-linear-algebra",
    "href": "10/lecture_multidimensionalArrays.html#two-dimensional-arrays-as-matrices-some-linear-algebra",
    "title": "Multi-dimensional arrays",
    "section": "Two-dimensional arrays as matrices: some linear algebra",
    "text": "Two-dimensional arrays as matrices: some linear algebra\nTwo-dimensional arrays are often used to represent matrices or images. In a matrix, each element can be accessed using two indices: - one for the row - one for the column.\nA matrix is a rectangular array of numbers, symbols, or expressions arranged in rows and columns and is an essential concept in linear algebra.\nFor examplle, let’s consider the simple system of simultaneous equations:\n\\[ \\begin{align*}\n2x + 3y +z &= 5 \\\\\n4x - y &= 1 \\\\\n2y +z &= 3\n\\end{align*} \\]\nThis can be represented in matrix form as: \\[ \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n=\n\\begin{bmatrix}5 \\\\\n1\\\\\n3\n\\end{bmatrix} \\]\nAnd if we call \\(A\\) the matrix of coefficients, \\(\\mathbf{x}\\) the vector of variables, and \\(b\\) the vector of constants, we can write this as: \\[ A \\mathbf{x} = \\mathbf{b} \\]\nwhere \\[A = \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}, \\quad\n\\mathbf{x} = \\begin{bmatrix}\nx \\\\\ny\\\\\nz\n\\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix}\n5 \\\\\n1\\\\\n3\n\\end{bmatrix} \\]\nA key result of linear algebra is that if \\(A\\) is invertible, we can solve for \\(\\mathbf{x}\\) by multiplying both sides of the equation by the inverse of \\(A\\): \\[ \\mathbf{x} = A^{-1} \\mathbf{b} \\]\nwhere \\(A^{-1}\\) is the inverse of matrix \\(A\\).\nNumPy has a dedicated linear algebra submodule called numpy.linalg that provides functions for performing various linear algebra operations, including matrix inversion, solving systems of equations, and computing eigenvalues and eigenvectors.\n\n\n\n\n\n\nThe linear algebra submodule has a function called solve which can be used to solve the above equation efficiently:\n\n\n\n\n\n\nBut we can use numpy to verify that this is correct. We can use the symbol @ to perform matrix multiplication in numpy.\n\n\n\n\n\n\nWe can also directly calculate the inverse of a matrix using the inv function from the numpy.linalg and use it to solve the equation\n\n\n\n\n\n\nAll the most common linear algebra operations are available in the numpy.linalg submodule:\n\ntranpose\n\n\n\n\n\n\n\n\nscalar (dot) product (which takes two vectors and returns a scalar)\n\n\n\n\n\n\n\n\ncross product\n\n\n\n\n\n\n\nLinear algebra applications are beyond the scope of this course (so, there will be no assessment of these), but they are widely used in various fields such as physics, computer science, and engineering. For example, they are essential in computer graphics for transformations, in machine learning for optimization, and in physics for solving systems of equations. So it is important for you to know that all these can be implemented efficiently using numpy."
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#matrices-as-images",
    "href": "10/lecture_multidimensionalArrays.html#matrices-as-images",
    "title": "Multi-dimensional arrays",
    "section": "Matrices as images",
    "text": "Matrices as images\nA two-dimensional table of numbers can also be used to represent an image. Each number in the table corresponds to a pixel in the image, and the value of the number represents the color or intensity of that pixel.\nmatplotlib provides a convenient way to visualize 2D arrays as images. The matshow function can be used to display a 2D matrix as an image, where the values in the array are mapped to colors.\n\n\n\n\n\n\nNotice that the indices of the y-axis increase as we go down. These are the indices of the rows in the matrix.\nFor a matrix of a given shape we can get the indices using the np.indices function, which returns a grid of indices for each dimension. This can be useful for creating masks or selecting specific regions of the matrix.\n\n\n\n\n\n\nAn alternative function is imshow, which is more general and can be used for both 2D arrays and images.\nHere we can set the origin of the axis:\n\n\n\n\n\n\n\n\n\n\n\n\nThe main difference between matshow and imshow is that matshow is specifically designed for displaying matrices, while imshow is more general and can be used for both 2D arrays and images. matshow automatically adjusts the aspect ratio to make the matrix square, while imshow does not. Also the interpolation method used by matshow is different from that used by imshow, which can affect the appearance of the image.\nImages are represneted as 3d arays: every entry is a the intensity of a pixel (if the image is grayscale) or the intensity of a colour (e.g. red, green or blue) if the image is in colour.\n\n\n\n\n\n\nLet’s take a colour image\n\n\n\n\n\n\nThis is no longer just a 2d array, it has a third dimension for the colour channels (red, green, blue). We can access the individual colour channels by slicing the array along the third dimension.\n\n\n\n\n\n\nWe can slice the array to get the various channels (notice that we specify the colormap cmap argument to display the channels in the appropriate colour):\n\n\n\n\n\n\nIf we want to subsample regions of an image, we can simply slice the array further in its rows and columns.\n\n\n\n\n\n\nWe can also use boolean indexing to filter the image based on conditions.\nFor example, we can binarise it by applying a threshold\n\n\n\n\n\n\nWe can even perform logical operations using numpy\n\nAND with &\nOR with |\nNOT with ~ or np.logical_not"
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#pair-programming",
    "href": "10/lecture_multidimensionalArrays.html#pair-programming",
    "title": "Multi-dimensional arrays",
    "section": "Pair programming",
    "text": "Pair programming\nThe following exercise will allow you explore multi-dimensional arrays by working in pairs. One person will write the code, while the other will explain what the code does. You can switch roles after each exercise.\nThere are two parts so, you can switch roles after each part.\n\nPart1\nPart2"
  },
  {
    "objectID": "10/exercises_part2_solutions.html",
    "href": "10/exercises_part2_solutions.html",
    "title": "Answers",
    "section": "",
    "text": "One application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\n\n\n\n\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\n\n\n\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed.\n\n\n\nThe inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\n\n\n\n\n\n\n\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\n\n\n\n\n\n\n\n\n\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\n\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html"
  },
  {
    "objectID": "10/exercises_part2_solutions.html#masking-a-galaxy",
    "href": "10/exercises_part2_solutions.html#masking-a-galaxy",
    "title": "Answers",
    "section": "",
    "text": "One application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\n\n\n\n\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\n\n\n\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed."
  },
  {
    "objectID": "10/exercises_part2_solutions.html#creating-an-elliptical-mask",
    "href": "10/exercises_part2_solutions.html#creating-an-elliptical-mask",
    "title": "Answers",
    "section": "",
    "text": "The inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\n\n\n\n\n\n\n\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\n\n\n\n\n\n\n\n\n\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel)."
  },
  {
    "objectID": "10/exercises_part2_solutions.html#calculating-the-magnitude",
    "href": "10/exercises_part2_solutions.html#calculating-the-magnitude",
    "title": "Answers",
    "section": "",
    "text": "Now that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\n\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#array-indexing-slicing",
    "href": "slides/08_working_numpy_slides.html#array-indexing-slicing",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Array Indexing & Slicing",
    "text": "Array Indexing & Slicing\nimport numpy as np\narr = np.array([10, 20, 30, 40, 50])\n\n# Integer indexing\nprint(\"Element at index 1:\", arr[1])\n\n# Basic slicing\nprint(\"Slice [1:4]:\", arr[1:4])\nAdvanced slicing:\nprint(\"Every other element:\", arr[::2])\nprint(\"Last three elements:\", arr[-3:])\nprint(\"Reversed array:\", arr[::-1])"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#views-vs-copies",
    "href": "slides/08_working_numpy_slides.html#views-vs-copies",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Views vs Copies",
    "text": "Views vs Copies\nSlicing creates views (shared data):\nslice_view = arr[2:5]\nslice_view[0] = 99\nprint(\"Original after view modification:\", arr)\nCreating independent copies:\narr = np.array([10, 20, 30, 40, 50])  # Reset\narr_copy = arr[2:5].copy()\narr_copy[0] = 100\nprint(\"Copy:\", arr_copy)\nprint(\"Original unchanged:\", arr)"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#boolean-indexing",
    "href": "slides/08_working_numpy_slides.html#boolean-indexing",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Boolean Indexing",
    "text": "Boolean Indexing\nFilter data with conditions:\narr = np.array([1, 2, 3, 4, 5, 6])\nthreshold = 3\n\nbool_mask = arr &gt; threshold\nprint(\"Boolean mask:\", bool_mask)\nprint(\"Filtered values:\", arr[bool_mask])\nUsing np.where:\n# Get indices where condition is True\nindices = np.where(arr &gt; threshold)[0]\nprint(\"Indices:\", indices)\n\n# Conditional selection\nresult = np.where(arr &gt; 3, arr, 0)\nprint(\"Conditional result:\", result)"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#generating-sequences",
    "href": "slides/08_working_numpy_slides.html#generating-sequences",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Generating Sequences",
    "text": "Generating Sequences\nnp.arange - step-based:\nprint(\"Integers:\", np.arange(0, 10, 2))\nprint(\"Floats:\", np.arange(0.0, 1.0, 0.2))\nnp.linspace - count-based:\nprint(\"5 points from 0 to 1:\", np.linspace(0, 1, 5))\n\narange: Use when you know the step size\nlinspace: Use when you know the number of points"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#filled-arrays",
    "href": "slides/08_working_numpy_slides.html#filled-arrays",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Filled Arrays",
    "text": "Filled Arrays\n# Create arrays with specific values\nzeros_arr = np.zeros(5)\nones_arr = np.ones(4)\nfull_arr = np.full(3, 7)\n\nprint(\"Zeros:\", zeros_arr)\nprint(\"Ones:\", ones_arr)\nprint(\"Full:\", full_arr)\nSame shape as existing array:\ntemplate = np.array([1, 2, 3])\nprint(\"Zeros like:\", np.zeros_like(template))\nprint(\"Ones like:\", np.ones_like(template))\nprint(\"Full like:\", np.full_like(template, 9))"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#random-number-generation",
    "href": "slides/08_working_numpy_slides.html#random-number-generation",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Random Number Generation",
    "text": "Random Number Generation\nInitialize generator (for reproducibility):\nrng = np.random.default_rng(seed=123)\nDifferent distributions:\n# Random integers\nprint(\"Random integers:\", rng.integers(0, 100, size=5))\n\n# Uniform floats [0, 1)\nprint(\"Uniform [0,1):\", rng.random(5))\n\n# Normal distribution\nnormal_samples = rng.normal(loc=0, scale=1, size=5)\nprint(\"Normal samples:\", normal_samples)"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#pseudo-random-numbers",
    "href": "slides/08_working_numpy_slides.html#pseudo-random-numbers",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Pseudo-Random Numbers",
    "text": "Pseudo-Random Numbers\nComputers are deterministic - they use algorithms to generate “pseudo-random” sequences\nLinear Congruential Generator example: \\[x_{n+1} = (a \\times x_n + c) \\bmod m\\]\nKey concept: Seeds enable reproducibility\n# Same seed = same sequence\nrng1 = np.random.default_rng(seed=42)\nrng2 = np.random.default_rng(seed=42)\n\nprint(\"RNG1:\", rng1.integers(0, 10, size=3))\nprint(\"RNG2:\", rng2.integers(0, 10, size=3))  # Same output!"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#performance-tips",
    "href": "slides/08_working_numpy_slides.html#performance-tips",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Performance Tips",
    "text": "Performance Tips\nPreallocate for efficiency:\n# Less efficient: generate one at a time\n# for _ in range(1000):\n#     val = rng.integers(0, 100)\n\n# More efficient: preallocate\nprealloc = rng.integers(0, 100, size=1000)\n# Then use values from prealloc array\nMemory vs Speed tradeoff: - Small tasks: 100-1,000 elements - Medium tasks: 10,000-100,000 elements\n- Large tasks: 1,000,000+ elements"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#key-takeaways",
    "href": "slides/08_working_numpy_slides.html#key-takeaways",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nViews share data, copies are independent\nBoolean indexing enables powerful data filtering\narange vs linspace serve different use cases\nRandom generators need seeds for reproducibility\nPreallocating arrays improves performance\nChoose array generation method based on your needs"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#numpy-arrays-beyond-1d",
    "href": "slides/10_multidimensional_arrays_slides.html#numpy-arrays-beyond-1d",
    "title": "Multi-dimensional Arrays",
    "section": "NumPy Arrays Beyond 1D",
    "text": "NumPy Arrays Beyond 1D\nMulti-dimensional arrays enable representation of: - 2D: Grid/Matrix (rows × columns) - 3D: Cuboid/Tensor (depth × rows × columns) - nD: Higher dimensions\nimport numpy as np\nfrom numpy import random\nrng = random.default_rng(seed=24)\n\n# 2D array (3×3 matrix)\narray_2d = rng.random((3, 3))\nprint(f\"Shape: {array_2d.shape}\")\nprint(array_2d)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#indexing-multi-dimensional-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#indexing-multi-dimensional-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Indexing Multi-dimensional Arrays",
    "text": "Indexing Multi-dimensional Arrays\nRow-major order: [row, column] (like [y, x])\n# Access single element\nprint(\"Element at [1,2]:\", array_2d[1, 2])\n\n# Access entire row\nprint(\"First row:\", array_2d[0, :])\n\n# Access entire column  \nprint(\"First column:\", array_2d[:, 0])\nSlicing works with multiple dimensions:\nprint(\"First 2 rows:\\n\", array_2d[:2])"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#array-properties",
    "href": "slides/10_multidimensional_arrays_slides.html#array-properties",
    "title": "Multi-dimensional Arrays",
    "section": "Array Properties",
    "text": "Array Properties\n# Creating arrays with different shapes\nzeros_2d = np.zeros((2, 3))  # 2 rows, 3 columns\nrandom_3d = rng.integers(0, 3, size=(2, 3, 4))  # 2×3×4 tensor\n\nprint(\"2D shape:\", zeros_2d.shape)\nprint(\"3D shape:\", random_3d.shape)\nprint(\"3D rank/dimensions:\", random_3d.ndim)\nTerminology: - Rank/ndim: Number of dimensions - Matrix: Rank 2 array - Tensor: Rank 3+ array"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#operations-along-axes",
    "href": "slides/10_multidimensional_arrays_slides.html#operations-along-axes",
    "title": "Multi-dimensional Arrays",
    "section": "Operations Along Axes",
    "text": "Operations Along Axes\nAxis-specific operations:\nmatrix = rng.integers(0, 5, size=(3, 4))\nprint(\"Original matrix:\\n\", matrix)\n\nprint(\"Sum along axis 0 (columns):\", matrix.sum(axis=0))\nprint(\"Sum along axis 1 (rows):\", matrix.sum(axis=1))\nprint(\"Mean along axis 0:\", np.mean(matrix, axis=0))\nAxis 0: Operations across rows (result has column shape)\nAxis 1: Operations across columns (result has row shape)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#reshaping-and-flattening",
    "href": "slides/10_multidimensional_arrays_slides.html#reshaping-and-flattening",
    "title": "Multi-dimensional Arrays",
    "section": "Reshaping and Flattening",
    "text": "Reshaping and Flattening\nReshape without changing data:\narr_1d = np.arange(12)\narr_2d = arr_1d.reshape((3, 4))\narr_3d = arr_1d.reshape((2, 2, 3))\n\nprint(\"1D:\", arr_1d)\nprint(\"2D (3×4):\\n\", arr_2d)\nprint(\"3D shape:\", arr_3d.shape)\nUsing -1 for automatic dimension:\n# -1 means \"figure out this dimension\"\nauto_reshape = arr_1d.reshape(-1, 4)  # ? rows, 4 columns\nprint(\"Auto-reshaped:\\n\", auto_reshape)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#flattening-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#flattening-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Flattening Arrays",
    "text": "Flattening Arrays\nravel() - returns view (shares data):\nmatrix = rng.integers(0, 10, (2, 3))\nprint(\"Original:\\n\", matrix)\n\nview = matrix.ravel()\nview[0] = 99  # Changes original!\nprint(\"After modifying view:\\n\", matrix)\nflatten() - returns copy:\nmatrix = rng.integers(0, 10, (2, 3))\ncopy = matrix.flatten()\ncopy[0] = 99  # Original unchanged\nprint(\"Original unchanged:\\n\", matrix)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#broadcasting",
    "href": "slides/10_multidimensional_arrays_slides.html#broadcasting",
    "title": "Multi-dimensional Arrays",
    "section": "Broadcasting",
    "text": "Broadcasting\nCombine arrays of different shapes automatically:\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6]])\nvector = np.array([10, 20, 30])\n\n# Vector is broadcast to each row\nresult = matrix + vector\nprint(\"Matrix + Vector:\\n\", result)\nCreate grids with broadcasting:\nrow_vec = np.arange(3).reshape(1, -1)    # Shape: (1, 3)\ncol_vec = np.arange(3).reshape(-1, 1)    # Shape: (3, 1)\ngrid = row_vec + col_vec                 # Shape: (3, 3)\nprint(\"Broadcast grid:\\n\", grid)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#linear-algebra-with-numpy",
    "href": "slides/10_multidimensional_arrays_slides.html#linear-algebra-with-numpy",
    "title": "Multi-dimensional Arrays",
    "section": "Linear Algebra with NumPy",
    "text": "Linear Algebra with NumPy\nMatrix operations for solving systems: \\[A\\mathbf{x} = \\mathbf{b}\\]\n# System: 2x + 3y + z = 5, 4x - y = 1, 2y + z = 3\nA = np.array([[2, 3, 1], \n              [4, -1, 0], \n              [0, 2, 1]])\nb = np.array([[5], [1], [3]])\n\n# Solve the system\nx = np.linalg.solve(A, b)\nprint(\"Solution:\", x.flatten())\n\n# Verify: A @ x should equal b\nprint(\"Verification:\\n\", A @ x)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#linear-algebra-operations",
    "href": "slides/10_multidimensional_arrays_slides.html#linear-algebra-operations",
    "title": "Multi-dimensional Arrays",
    "section": "Linear Algebra Operations",
    "text": "Linear Algebra Operations\n# Matrix multiplication with @\nresult = A @ x\n\n# Transpose with .T\nprint(\"b transpose:\", b.T)\n\n# Dot product\ndot_product = np.dot(b.T, b)\nprint(\"Dot product:\", dot_product)\n\n# Matrix inverse\nA_inv = np.linalg.inv(A)\nx_alt = A_inv @ b  # Alternative solution method\nNumPy.linalg provides: inverse, solve, eigenvalues, SVD, etc."
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#arrays-as-images",
    "href": "slides/10_multidimensional_arrays_slides.html#arrays-as-images",
    "title": "Multi-dimensional Arrays",
    "section": "Arrays as Images",
    "text": "Arrays as Images\nVisualize 2D arrays as images:\nimport matplotlib.pyplot as plt\n\n# Simple matrix visualization\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\n\nax1.matshow(matrix)\nax1.set_title('matshow')\n\nax2.imshow(matrix, origin='lower')\nax2.set_title('imshow (origin=lower)')"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#working-with-real-images",
    "href": "slides/10_multidimensional_arrays_slides.html#working-with-real-images",
    "title": "Multi-dimensional Arrays",
    "section": "Working with Real Images",
    "text": "Working with Real Images\nfrom skimage import data\n\n# Grayscale image\ngray_image = data.camera()\nprint(\"Image shape:\", gray_image.shape)\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(gray_image, cmap='gray')\nax.set_title('Grayscale Image')\nImages are arrays: Each pixel is a number (intensity)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#color-images-3d-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#color-images-3d-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Color Images (3D Arrays)",
    "text": "Color Images (3D Arrays)\n# Color image has 3 channels: RGB\ncolor_image = data.chelsea()\nprint(\"Color image shape:\", color_image.shape)\n\nfig, axes = plt.subplots(1, 4, figsize=(15, 4))\n\naxes[0].imshow(color_image)\naxes[0].set_title('Full Color')\n\n# Individual color channels\nchannels = ['Reds', 'Greens', 'Blues']\ntitles = ['Red Channel', 'Green Channel', 'Blue Channel']\n\nfor i, (cmap, title) in enumerate(zip(channels, titles)):\n    axes[i+1].imshow(color_image[:, :, i], cmap=cmap)\n    axes[i+1].set_title(title)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#boolean-operations-on-images",
    "href": "slides/10_multidimensional_arrays_slides.html#boolean-operations-on-images",
    "title": "Multi-dimensional Arrays",
    "section": "Boolean Operations on Images",
    "text": "Boolean Operations on Images\n# Extract green channel\ngreen = color_image[:, :, 1]\n\n# Create binary mask\nthreshold_mask = green &gt; 120\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n\nax1.imshow(green, cmap='Greens')\nax1.set_title('Green Channel')\n\nax2.imshow(threshold_mask, cmap='gray')\nax2.set_title('Thresholded (&gt;120)')\nLogical operations: & (AND), | (OR), ~ (NOT)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#key-takeaways",
    "href": "slides/10_multidimensional_arrays_slides.html#key-takeaways",
    "title": "Multi-dimensional Arrays",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nMulti-dimensional arrays represent grids, images, tensors\nIndexing: [row, col] for 2D arrays\nAxis operations reduce along specific dimensions\nReshaping changes shape without changing data\nBroadcasting enables operations on different shapes\nLinear algebra operations available in np.linalg\nImages are just arrays of pixel values\nBoolean indexing works on multi-dimensional arrays"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#aims",
    "href": "slides/07_intro_numpy_slides.html#aims",
    "title": "The numpy module",
    "section": "Aims",
    "text": "Aims\nBy the end of this lecture, you will be able to:\n\nExplain what the NumPy module is and why it is used\nCreate and manipulate NumPy arrays\nPerform element-wise operations and mathematical functions on arrays\nCompare NumPy arrays with Python lists in terms of performance and functionality\nUse basic aggregation and array manipulation functions in NumPy"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#what-is-numpy",
    "href": "slides/07_intro_numpy_slides.html#what-is-numpy",
    "title": "The numpy module",
    "section": "What is numpy?",
    "text": "What is numpy?\nNumPy is a Python library that makes working with numbers and large collections of data fast and easy.\n\nComplete description at https://numpy.orgIt provides special array objects and tools for doing math efficiently, which is useful for data analysis and scientific computing.\n\nIt is imported in your session using the following command\nimport numpy\n\n\nWe will follow a common practice and use a shorthand with the as syntax\nimport numpy as np\n\n\nSo np will always mean numpy for us."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#arrays-vs-lists",
    "href": "slides/07_intro_numpy_slides.html#arrays-vs-lists",
    "title": "The numpy module",
    "section": "Arrays vs lists",
    "text": "Arrays vs lists\n\n\nPython Lists\n\nOrdered, Mutable\n\nMixed data types\nExplicit operations needed\nSlower performance\n\n\nNumPy Arrays\n\nOrdered, Mutable\nOne data type per array\nElement-wise operations\nFast & memory efficient\n\n\n\n\n\nlist_ex = [1, 2, 3, 4]\nprint(list_ex)\n\nimport numpy as np\n#notice that we explicitly call the np.array()\narr_ex = np.array([1, 2, 3, 4]) \nprint(arr_ex)\n\nWe are going to see these differences in detail."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#arrays-from-lists",
    "href": "slides/07_intro_numpy_slides.html#arrays-from-lists",
    "title": "The numpy module",
    "section": "Arrays from lists",
    "text": "Arrays from lists\nA purely numerical list can readily be converted to an array.\nimport numpy as np\n# Create array from list\nlist1 = [1.,1.,2.,3.,5.,8.]\narr1 = np.array(list1)\nprint(arr1)\n\nThe type of the elements yields the data type of the array\nprint(arr1.dtype)\n\nTry and change the list1 object to contain only integers and see the change!"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#array-properties",
    "href": "slides/07_intro_numpy_slides.html#array-properties",
    "title": "The numpy module",
    "section": "Array properties",
    "text": "Array properties\nArrays possess plenty of properties.\nThese are accessed with the . notation1.\nprint(f\"Data type: {arr1.dtype}\")\nprint(f\"Shape: {arr1.shape}\")\nprint(f\"Shape: {arr1.size}\")\nFor now, we consider only 1d arrays, i.e. sequences. Their length is is their size and corresponds to the first element of the property shape.\nuse . and then TAB to see all of the properties"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#accessing-array-elements",
    "href": "slides/07_intro_numpy_slides.html#accessing-array-elements",
    "title": "The numpy module",
    "section": "Accessing array elements",
    "text": "Accessing array elements\nSimilarly to lists, we access an element in an array via zero-based indexing\nprint(arr1[0])    # First element\nprint(arr1[-1])   # Last element\nAgain, similarly to lists, we can access regions of the array via slicing\nprint(arr1[3:6])  # Elements from index 3 to 6"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#element-wise-operations",
    "href": "slides/07_intro_numpy_slides.html#element-wise-operations",
    "title": "The numpy module",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe main motivation to use arrays is that lists are cumbersome when performing maths.\nSuppose we have a list and want to double all of its elements:\nlist1 = [1,2,3,4]\nWe need to loop over all of them and create a new list\nlist2 = []\nfor item in list1:\n    list2.append(2*item)\nprint(list2)\nIn fact, we can do this in a slightly more compact way using list comprehension\nlist2 = [item*2 for item in list1]\nStill, an explicit loop is needed. Loops in Python are slow."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#element-wise-operations-1",
    "href": "slides/07_intro_numpy_slides.html#element-wise-operations-1",
    "title": "The numpy module",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe numpy syntax avoids the explicit Python loop.\narr1 = np.array(list1)\narr2 = 2*arr1\nprint(arr2)\nThis is not just a cosmetic change: under the hood numpy uses an efficient architecture that performs operations in compiled code, making it much faster than Python loops."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#performance-advantage",
    "href": "slides/07_intro_numpy_slides.html#performance-advantage",
    "title": "The numpy module",
    "section": "Performance advantage",
    "text": "Performance advantage\nThis performance difference can be tracked explicitly.\nWe create a large list and a large array with identical content\n# Create a large list and array\nlarge_list = list(range(1_000_000))\nlarge_array = np.array(large_list)\nAnd then track the time for the two operations\nimport time\n#  Track the time taken for the list multiplication\nstart = time.time()\nlist_result = [x * 2 for x in large_list]\nend = time.time()\nprint(f\"List comprehension time: {end - start:.5f} seconds\")\n\n# Time array multiplication\nstart = time.time()\narray_result = large_array * 2\nend = time.time()\nprint(f\"NumPy array time: {end - start:.5f} seconds\")"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#general-mathematical-functions",
    "href": "slides/07_intro_numpy_slides.html#general-mathematical-functions",
    "title": "The numpy module",
    "section": "General mathematical functions",
    "text": "General mathematical functions\nThe multiplication we performed earlier is done element-wise: every element is update according to teh same rule.\nWe can apply plenty of element-wise operations to the arrays.\nMany of these are available as numpy functions directly accessed from the np. module\n# Element-wise functions\nprint(f\"Square root: {np.sqrt(arr1)}\")\nprint(f\"Mean: {np.mean(arr1)}\")\nprint(f\"Cosine: {np.cos(arr1)}\")\n\nThe operations do not modify the original array, but produce new copies\narr2 = arr1*3/2 + 5\nprint(f\"Original: {arr1}\")\nprint(f\"Modified: {arr2}\")"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#sums",
    "href": "slides/07_intro_numpy_slides.html#sums",
    "title": "The numpy module",
    "section": "Sums",
    "text": "Sums\nOther convenent numpy functions allow you to accumulate values without loops.\nAssume we have an array \\(x\\)\nx = np.array([1,2,3,4,5,6,7,8])\nSums\n\\[\nS = \\sum_{i=1}^{n} x_i\n\\]\nIn NumPy, this is translated as:\nS = np.sum(x)\nprint(S)"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#sums-1",
    "href": "slides/07_intro_numpy_slides.html#sums-1",
    "title": "The numpy module",
    "section": "Sums",
    "text": "Sums\nCumulative sums\nA cumulative sum is a sequence where each element is the sum of all previous elements up to that position. \\[\ny_i = \\sum_{j=1}^{i} x_j\n\\]\nIn NumPy, this is translated as:\n y = np.cumsum(x)\n print(y)"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#example-molecular-masses",
    "href": "slides/07_intro_numpy_slides.html#example-molecular-masses",
    "title": "The numpy module",
    "section": "Example: molecular masses",
    "text": "Example: molecular masses\nLet’s consider the formula for the molecular mass of a compound:\n\\[\nM = \\sum_{i=1}^{n} a_i m_i\n\\]\nwhere\n\n\\(a_i\\) is the number of atoms of element \\(i\\)\n\\(m_i\\) is the atomic mass of element \\(i\\)\n\n\nWith numpy, you can compute this as:\na = np.array([2, 1, 4])      # Number of atoms for each element\nm = np.array([12.01, 1.01, 16.00])  # Atomic masses (e.g., C, H, O)\nM = np.sum(a * m)\nprint(f\"Molecular mass: {M}\")"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#operations-between-arrays",
    "href": "slides/07_intro_numpy_slides.html#operations-between-arrays",
    "title": "The numpy module",
    "section": "Operations between arrays",
    "text": "Operations between arrays\nYou can perform arithmetic operations directly between arrays of the same shape. Operations like addition, subtraction, multiplication, and division are applied element-wise.\nFor example:\nElement-wise operations:\nadded = arr1 + arr2\nmultiplied = arr1 * arr2\nprint(f\"Added: {added}\")\nprint(f\"Multiplied: {multiplied}\")\n\nNote: Arrays must have compatible shapes!\narr3 = np.array([1, 2, 3])\narr4 = np.array([4, 5])\nresult = arr3 + arr4"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#combining-arrays",
    "href": "slides/07_intro_numpy_slides.html#combining-arrays",
    "title": "The numpy module",
    "section": "Combining arrays",
    "text": "Combining arrays\nWith lists, the + operator concatenated different lists. Since for arrays the sign + corresponds to true mathematical addition, a dedicated concatenation function exists:\ncombined = np.concatenate([arr1, arr2])\nprint(f\"Unique elements: {combined}\")\nMany other variations of concatenation exist. Consult the documentation."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#key-takeaways",
    "href": "slides/07_intro_numpy_slides.html#key-takeaways",
    "title": "The numpy module",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nNumPy arrays are optimized for numerical operations\nElement-wise operations work implicitly\nPerformance benefits for large datasets\nMathematical functions apply to entire arrays\nShape compatibility required for operations\nChoose the right tool for your task"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html",
    "href": "07/exercises_numpy_solutions.html",
    "title": "numpy Exercises",
    "section": "",
    "text": "These exercises test your understanding of the NumPy concepts covered in the introduction notebook."
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-1-import-and-basic-array-creation",
    "href": "07/exercises_numpy_solutions.html#exercise-1-import-and-basic-array-creation",
    "title": "numpy Exercises",
    "section": "Exercise 1: Import and Basic Array Creation",
    "text": "Exercise 1: Import and Basic Array Creation\nTask: Import NumPy with the standard import command and create a NumPy array from the list [2, 4, 6, 8, 10, 12]. Print the array, its data type, and its shape."
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-2-array-indexing-and-slicing",
    "href": "07/exercises_numpy_solutions.html#exercise-2-array-indexing-and-slicing",
    "title": "numpy Exercises",
    "section": "Exercise 2: Array Indexing and Slicing",
    "text": "Exercise 2: Array Indexing and Slicing\nTask: Using the array you created in Exercise 1:\n\nPrint the first element\nPrint the last element\nPrint elements from index 2 to 4 (inclusive of 2, exclusive of 5)\nPrint every second element"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-3-element-wise-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-3-element-wise-operations",
    "title": "numpy Exercises",
    "section": "Exercise 3: Element-wise Operations",
    "text": "Exercise 3: Element-wise Operations\nTask: Create a NumPy array arr = np.array([1, 4, 9, 16, 25]). Perform the following operations and print the results:\n\nMultiply each element by 3\nAdd 10 to each element\nCalculate the square root of each element\nApply the sine function to each element"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-4-array-operations-with-two-arrays",
    "href": "07/exercises_numpy_solutions.html#exercise-4-array-operations-with-two-arrays",
    "title": "numpy Exercises",
    "section": "Exercise 4: Array Operations with Two Arrays",
    "text": "Exercise 4: Array Operations with Two Arrays\nTask: Create two NumPy arrays:\n\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([10, 20, 30, 40, 50])\n\nPerform element-wise operations and print the results:\n\nAdd the two arrays\nSubtract arr1 from arr2\nMultiply the two arrays\nDivide arr2 by arr1"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-5-shape-mismatch-error",
    "href": "07/exercises_numpy_solutions.html#exercise-5-shape-mismatch-error",
    "title": "numpy Exercises",
    "section": "Exercise 5: Shape Mismatch Error",
    "text": "Exercise 5: Shape Mismatch Error\nTask: Create two arrays with different lengths:\n\narr_a = np.array([1, 2, 3, 4])\narr_b = np.array([10, 20])\n\nTry to add these arrays together. What happens? Write the code and explain the error in a comment."
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-6-reductive-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-6-reductive-operations",
    "title": "numpy Exercises",
    "section": "Exercise 6: Reductive Operations",
    "text": "Exercise 6: Reductive Operations\nTask: Create a NumPy array data = np.array([12, 8, 15, 3, 7, 20, 11, 9]). Calculate and print:\n\nThe sum of all elements\nThe mean (average) of all elements\nThe maximum value\nThe minimum value\nThe standard deviation"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-7-array-manipulation",
    "href": "07/exercises_numpy_solutions.html#exercise-7-array-manipulation",
    "title": "numpy Exercises",
    "section": "Exercise 7: Array Manipulation",
    "text": "Exercise 7: Array Manipulation\nTask: Create a NumPy array numbers = np.array([5, 2, 8, 1, 9, 3]). Perform the following operations:\n\nSort the array and print the result\nCalculate the cumulative sum and print the result\nCreate a new array with duplicates: with_duplicates = np.array([5, 2, 8, 1, 9, 3, 5, 2, 1]) and find the unique elements"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-8-list-vs-numpy-comparison",
    "href": "07/exercises_numpy_solutions.html#exercise-8-list-vs-numpy-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 8: List vs NumPy Comparison",
    "text": "Exercise 8: List vs NumPy Comparison\nTask: Compare the flexibility of lists vs NumPy arrays:\n\nCreate a Python list containing mixed data types: mixed_list = [1, 'hello', 3.14, True]\nTry to create a NumPy array from this list. What happens to the data types?\nCreate a list of numbers: num_list = [1, 2, 3, 4, 5]\nTry to multiply the entire list by 2 using num_list * 2. What happens?\nCreate a NumPy array from the same numbers and multiply by 2. Compare the results."
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-9-performance-comparison",
    "href": "07/exercises_numpy_solutions.html#exercise-9-performance-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 9: Performance Comparison",
    "text": "Exercise 9: Performance Comparison\nTask: Compare the performance of list comprehension vs NumPy operations:\n\nImport the time module\nCreate a range of 50,000 numbers using numpy np.arange()\nTime how long it takes to square each number using a list comprehension, i.e. the syntax [x**2 for x in myarray]\nTime how long it takes to square each number using NumPy operations\nCalculate and print how many times faster the NumPy operation is"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-10-complex-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-10-complex-operations",
    "title": "numpy Exercises",
    "section": "Exercise 10: Complex Operations",
    "text": "Exercise 10: Complex Operations\nTask: Create a NumPy array representing angles in degrees: angles_deg = np.array([0, 30, 45, 60, 90, 120, 180])\n\nConvert these angles to radians (hint: multiply by π/180, use np.pi)\nCalculate the sine and cosine of each angle\nVerify that sin²(x) + cos²(x) = 1 for each angle (use np.sin() and np.cos())\nPrint all results"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#challenge-exercise-temperature-conversion",
    "href": "07/exercises_numpy_solutions.html#challenge-exercise-temperature-conversion",
    "title": "numpy Exercises",
    "section": "Challenge Exercise: Temperature Conversion",
    "text": "Challenge Exercise: Temperature Conversion\nTask: You have temperature readings in Celsius: celsius_temps = np.array([0, 10, 20, 25, 30, 35, 40])\n\nConvert all temperatures to Fahrenheit using the formula: F = (C × 9/5) + 32\nConvert all temperatures to Kelvin using the formula: K = C + 273.15\nCalculate the temperature range (max - min) for each scale\n\n\n\n\n\n\n\n## Challenge 2: Kinetic energy\n\n**Task** Given arrays of mass (kg) and velocity (m/s) for several objects:\n```python\n# copy and paste this code below\nmasses = np.array([2.0, 1.5, 3.0, 0.5])      # in kilograms\nvelocities = np.array([10.0, 20.0, 15.0, 5.0]) # in meters per second\n```\n\n1. Calculate the kinetic energy $K$ for each object using the formula: \n\n$$K =  \\dfrac{1}{2}m v^2$$\n\n2. Calculate the total kinetic energy of the system (sum of all objects)"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#challenge-3-temperature-analysis",
    "href": "07/exercises_numpy_solutions.html#challenge-3-temperature-analysis",
    "title": "numpy Exercises",
    "section": "Challenge 3: Temperature Analysis",
    "text": "Challenge 3: Temperature Analysis\nTask: Given a NumPy array of daily temperatures for 30 days:\ntemperatures = np.array([23.5, 24.0, 21.2, 25.6, 22.8, 23.9, 26.1, 27.3, 21.7, 22.5,\n                         24.6, 25.8, 20.9, 22.3, 24.7, 26.0, 27.5, 21.0, 22.9, 24.8,\n                         25.9, 27.6, 20.8, 22.7, 24.5, 26.2, 27.7, 20.5, 22.6, 24.9])\nPerform the following tasks:\n\nFind the top 3 hottest days and their temperatures.\nCalculate the day-to-day percentage change in temperature."
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html",
    "href": "09/lecture_intro_matplotlib.html",
    "title": "Plotting with matplotlib",
    "section": "",
    "text": "One way to plot a graph in Python is to use the matplotlib package.\nMatplotlib is a powerful and widely-used Python library for creating static, animated, and interactive visualizations. It provides a flexible framework for generating a wide variety of plots and charts, making it a popular choice for data analysis and scientific research. With matplotlib, you can customize every aspect of your figures, from colors and styles to labels and legends.\nWe start by importing the pyplot sub-module from matplotlib.\nThe most widespread convention is to use the shorthand plt to refer to this package with the as syntax and so we can import this in the following way:"
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#figure-and-axes",
    "href": "09/lecture_intro_matplotlib.html#figure-and-axes",
    "title": "Plotting with matplotlib",
    "section": "Figure and Axes",
    "text": "Figure and Axes\nThere are two main interfaces for plotting using matplotlib.\n\nThe first is to use Pyplot (plt) to create a plot directly e.g. using plt.plot(). This is the type of syntax you may see often when looking online. This way of interacting with and plotting data was created to replicate the functionality of an alternative, and common programming language called MATLAB, which a lot of early Python adopters were familiar with.\nThe second, more modern way to create plots is to use the object-oriented approach where the figure is created first and then explicitly referenced when creating a plot. One way to do this is by calling the subplots() function to create a Figure (the canvas) and an Axes (the x-y axes) object which can then be used for plotting.\n\nfig, ax = plt.subplots()\nWe can plot using the ax object directly using whichever type of graph we want to create e.g.  - for a simple line graph we can use the plot() function - for a scatter graph we can use the scatter() function. - for a 1D histogram we can the hist() function\nYou can also add multiple graphs to the same set of Axes to plot sets of data on top of each other:\n\n\n\n\n\n\n\n\n\n\n\n\nYou may notice that unlike other Python you have been writing, in Jupyter notebooks you should keep your plotting code together in one code cell as this will immediately be displayed when the code cell is run.\nTo create another plot in a new cell you can create new Figure and Axes objects using the same names fig, ax or name them something different if you’d prefer.\nMatplotlib sample plots - https://matplotlib.org/3.3.3/tutorials/introductory/sample_plots.html\n\nAside: subplots\nYou may ask why the function for creating a new plot is called subplots(). By default, this function allows you to create one plot on one figure, which is usually what you want for an initial plot. However, it is possible to use the subplots() function to create multiple plots on the same figure. One way to do this is by specifying the number of rows (nrows) and number of columns (ncols) you want when using the subplots() function. Note that this will pass back an array of Axes objects rather than just one which you can then use to plot.\nWe won’t explore this further, but for more details on how this is done have a look at the subplots demo.\n\n\n\nExercise A\nFor this exercise, we have created some random sample data which we can plot. Here we have created several numpy arrays each 100 elements long (based on num_points).\n\n\n\n\n\n\n\nCreate a scatter plot of x_range versus random_sample1.\n\n\nStart by creating your Figure and Axes objects (fig, ax) using the subplots function\nUse the scatter method to plot your data using your Axes object\n\n\n\n\n\n\n\n\nCreate a line plot of x_range versus random_sample2\n\n\nAs before, start by creating your Figure and Axes objects (fig, ax) using the subplots function\nUse the plot method to plot your data using your Axes object"
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#annotating-and-adding-features",
    "href": "09/lecture_intro_matplotlib.html#annotating-and-adding-features",
    "title": "Plotting with matplotlib",
    "section": "Annotating and adding features",
    "text": "Annotating and adding features\nAs well as plotting you can, and should, add additional information to your plot as appropriate. For instance, you can:\n\nchange the style, colour etc. of your initial plot (e.g. see examples within matplotlib decoration)\nadd additional features such as axis labels, legend etc.\n\nThe code below demonstrates how we could customise the plot above using these inputs:\n\n1. Using more of the available plotting options\n\n\n\n\n\n\nWe can include more inputs for both our subplots function and our plotting functions such as plot() and scatter():\n\nFor the subplots() initial step we specified the figure size, figsize, as an input. This is set using a tuple of (width, height) in inches.\nFor the plot function we set:\n\nthe colour to be a named colour called “slategrey” using the color input\nthe style of the line to be dashed, using “–” and the linestyle input\n\nFor the scatter function we set:\n\nthe colour to be a named colour called “indianred” using the color input\nthe marker shape to a cross shape, using “+” and the marker input\nsize to be 60 (area of the marker) using the s input\n\n\nFor in-built options see: - Colours - https://matplotlib.org/stable/gallery/color/named_colors.html - Line style - https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html - Markers - https://matplotlib.org/api/markers_api.html\n\n\n2. Setting properties on the plot\n\n\n\n\n\n\nHere we set additional parameters for the plot - the x and y labels and an x limit. We have done this by calling the relevant functions (e.g. set_xlabel, set_ylim) on our ax variable.\nFor some examples of different Axes functions of this type see: - Axes - labels and limits - https://matplotlib.org/stable/api/axes_api.html#axis-labels-title-and-legend - Axes - tick labels - https://matplotlib.org/stable/api/axes_api.html#ticks-and-tick-labels\n\n\n3. Additional labelling - legend\n\n\n\n\n\n\nA legend can be created using the .legend() function (method) and this will use the label value supplied when creating each plot. If ax.legend() is not included then, even if a label variable is specified, no legend will be added to the plot.\nSee: - legend function - https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html"
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#other-plot-types",
    "href": "09/lecture_intro_matplotlib.html#other-plot-types",
    "title": "Plotting with matplotlib",
    "section": "Other plot types",
    "text": "Other plot types\nWe can also apply similiar principles to other plot types. We can generate some more random data to look at this. Here we have created two normal distributions containing different numbers of points.\n\n\n\n\n\n\nWe could create a simple plot using the subplots function and the hist() function:\n\n\n\n\n\n\nUsing the exact same data we could update our plot using relevant inputs for our hist function and setting values on our axis:\n\n\n\n\n\n\nFor our histogram, in addition to options we used for our scatter and line plot, we have set more options available to us: - alpha - This allows us to make our data partially transparent to better view overlapping data - bins - We defined and included an input for the bin sizes rather than using the default - density - This is a plot type we can set which normalised our data for the different datasets. This can be useful if you are comparing datasets which have different sample sizes.\nIn general, you will need to look at the specific documentation for each of the the plot types to see what options are available."
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#anatomy-of-a-figure",
    "href": "09/lecture_intro_matplotlib.html#anatomy-of-a-figure",
    "title": "Plotting with matplotlib",
    "section": "Anatomy of a figure",
    "text": "Anatomy of a figure\nThis is a summary image to show the make up (anatomy) of a plot in matplotlib.\n\nYou can see some features we have described above such as “Figure”, “Axes”, “x axis label”, “y axis label”, “legend”. But you can also see how our inputs have influenced other aspects of the plot e.g. “Major tick”, “Minor tick”, “Major tick label”, “Minor tick label”, which were updated when we set the limits on the x and y axes, and “Markers” from our scatter plot which updated the marker style and colour.\nBecoming familiar with this terminology when applied to a matplotlib figure allows you to put a name to any part of the plot you wish to modify and to dig into the features offered for how to update these plots.\n\n\nExercise B\n\nCreate a scatter plot with the same data from Exercise A showing x_range versus random_sample1 adding or setting the following features:\n\n\nchanging the marker and colour\nsetting appropriate x and y labels\n\nRemember, you always need to recreate your fig and ax objects using the subplots function to create a new plot using Jupyter notebooks\n\n\n\n\n\n\n\nCreate a histogram plot overlaying data from random_sample1 and random_sample2.\n\n\nExperiment with different inputs to see if you can improve the default plot (e.g. setting the bin size, including transparency, changing the colours etc.)\nYou can also look at the hist() function documentation for more inputs to try e.g. histtype.\n\n\n\n\n\n\n\nExtra. Create a plot containing both a scatter plot for x_range versus random_sample1 AND a line plot for x_range versus random_sample2. Add or set the following features: - changing the line style and colour - setting a title for your plot\nHint: Look at “set_” commands within https://matplotlib.org/stable/api/axes_api.html#axis-labels-title-and-legend\n\n\n\n\n\n\n\nExtended: Pick an interesting plot from the matplotlib gallery and see if you replicate some of the additional features for these plots.\n\nYou can now proceed with the remaining exercises\n\nExercise C - Plotting data from a file\nA fun session - Using matplotlib to create a fun plot"
  },
  {
    "objectID": "09/exercises_plotting_data_from_file.html",
    "href": "09/exercises_plotting_data_from_file.html",
    "title": "Plotting data from file",
    "section": "",
    "text": "How can we use what we have learnt in the past few workshops to read data from a file? And how can we plot this?\nOne way to then plot this data would be to extract the index and/or multiple columns we are interested in plotting and use matplotlib as we have done before.\nAs an example, we’ll look at a new data file. This contains a simulation of the (fractional) concentration change for two species in a reaction, “A” and “B” where \\(A \\rightarrow B\\).\n\n\n\n\n\n\nIf we open this file more directly in Python when we looked at a text file) we can take quick look at the contents to see what this looks like:\n\n\n\n\n\n\nFrom printing out the first 200 characters, we can see this looks like a table of data with each column separated by spaces. This looks nicely formatted with a title row including the column names and no extra header rows.\nWe will see in the next year that there are dedicate packages to manipulate large tabulated files. However, for now we can exploit numpy as a quick and effective way to read such input.\n\n\n\n\n\n\nThis is a special kind of array called a structured array, because it has named fields. You can check this by querying the subproperties of the array:\n\n\n\n\n\n\nThese various names are the fields of the array, corresponding to the columns in the file. This syntax is reminiscent of what we have seen in the case of dictionaries, where keys are used to specific other objects stored in the dictionary.\n\n\n\n\n\n\nThis data also has a column for “Time” as the number of seconds elapsed.\n\n\n\n\n\n\nTo create a plot for time vs concentration of A, we can extract this data from our array\n\n\n\n\n\n\nWe could then use matplotlib to plot this:\n\n\n\n\n\n\nThis simulation shows a clean relationship as concentration decreases over time (in an exponential way).\nSuppose we want to filter our data and plot only concentrations less than 0.5. We can simply create a boolean array that masks the invalid data.\n\n\n\n\n\n\nHere we have filtered our data to include all fractional concentrations less than (or equal to) 0.5. Notice we have also matched our time values to plot to these concentrations by extracting the index from our new array concentration_A_low.\n\n\n\n\n\n\nYou can also see the slope is similiar (in fact it is the same) between our unfiltered and filtered data (this is due to the exponential relationship).\n\n\nExercise\n\nRe-plot the un-filtered graph created above and add another line to show concentration of B vs time from the data_kinetic_k0005 array on the same plot.\n\n\nCan you include a label for A and B?\n\n\nCalculate the the sum of the concentrations for these two columns (A and B).\nRe-plot the graph created in the previous question and add this sum as a third line.\n\n\nConsider: What does this sum tell us about “A” is decaying into “B”?"
  },
  {
    "objectID": "08/lecture_working_with_numpy.html",
    "href": "08/lecture_working_with_numpy.html",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "",
    "text": "NumPy is a powerful library for numerical computing in Python, providing efficient multi-dimensional array operations and a wide range of mathematical functions. With NumPy, you can perform fast element-wise computations, advanced indexing, slicing, and generate random data for simulations and analysis.\nThis notebook illustrates array indexing, boolean arrays, generating sequences using np.arange and np.linspace, and generating random samples with NumPy’s random number generator."
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#array-indexing-slicing-views-and-copies",
    "href": "08/lecture_working_with_numpy.html#array-indexing-slicing-views-and-copies",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Array indexing, slicing, views and copies",
    "text": "Array indexing, slicing, views and copies\nIndexing in NumPy allows you to access and modify individual elements or groups of elements within an array. You can use integer indices, slices, and even boolean arrays to select data efficiently. For example:\n\nInteger Indexing: Select a single element by its position.\nSlicing: Extract a range of elements.\nBoolean Indexing: Filter elements based on a condition.\n\n\nInteger indexing\nWe have already seen that the lements of an array are idnexed similarly to lists. The syntax simply requires you to enter the integer index of the element you want to access. For example, if you have an array arr, you can access the element at index 1 using arr[1]. You can also slice arrays using the same syntax as lists, such as arr[1:4] to get elements from index 1 to 3.\n\n\n\n\n\n\n\n\nSlicing\nSlicing allows you to extract a portion of an array by specifying a start index, an end index, and an optional step. The syntax is similar to that used for lists in Python. For example, arr[1:4] retrieves elements from index 1 to 3 (the end index is exclusive).\n\n\n\n\n\n\n\n\nAdvanced Slicing Techniques\nNumPy slicing can be extended beyond basic start and end indices:\n\nStep Size: Use a third parameter to specify the step, e.g., arr[::2] selects every other element.\nNegative Indices: Negative values index from the end, e.g., arr[-3:] gets the last three elements.\nReverse Slicing: Use a negative step to reverse an array, e.g., arr[::-1].\n\n\n\n\n\n\n\nSlicing creates views, not copies, so modifying a slice affects the original array. Use arr.copy() to create a copy if needed.\nA view is a new array object that looks at the same data as the original array. Changes made to a view will affect the original array, since they share the same underlying data. For example, arr[1:4] returns a view of arr, not a separate copy.\n\n\n\n\n\n\nSlices can be programmaticaly generated using the slice function, which allows you to create a slice object that can be reused. For example, s = slice(1, 4) creates a slice object that can be used as arr[s] to get the same result as arr[1:4].\n\n\n\n\n\n\nTo create an independent copy of an array (rather than a view), use the copy() method. For example, arr_copy = arr[1:4].copy() creates a new array with its own data, so changes to arr_copy will not affect the original arr. This is useful when you want to modify a subset of an array without altering the original data.\n\n\n\n\n\n\n\n\nBoolean Indexing\nBoolean indexing allows you to select elements from an array based on a condition. When you apply a condition to a NumPy array, it returns a boolean (an array that contains only True/False values ) array indicating which elements satisfy the condition. You can then use this boolean array to filter the original array, extracting only the elements that meet the criteria. This technique is powerful for data selection and analysis.\n\n\n\n\n\n\n\n\nUsing np.where for conditional selection\nThe np.where function in NumPy is a powerful tool for conditional selection and element-wise operations. It allows you to choose values from arrays based on a condition, returning indices or constructing new arrays.\n\nBasic usage:\nnp.where(condition) returns the indices where the condition is True.\n\n\n\n\n\n\n\nnp.where(arr &gt; threshold) returns a tuple because, for 1D arrays, it provides the indices where the condition is True. In NumPy, the output is always a tuple of arrays—one for each dimension of the input array. For a 1D array, it’s a single-element tuple containing the indices. For higher dimensions, it returns a tuple with arrays for each axis. This consistent tuple format makes it easy to handle multi-dimensional indexing.\nSo, for 1D arrays as the ones considered up to now, we should get the indices by extracting the first element of the tuple returned by np.where\n\n\n\n\n\n\n\nElement-wise selection:\nnp.where(condition, x, y) returns elements from x where the condition is True, and from y where it is False. Here the result is an array of the same shape as x and y, containing values from x where the condition is met, and from y otherwise. This is useful for creating new arrays based on conditions without using loops.\n\n\n\n\n\n\n\nThis creates a new array where each element is 100 if the condition is met, otherwise 0."
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#function-to-generate-numerical-arrays",
    "href": "08/lecture_working_with_numpy.html#function-to-generate-numerical-arrays",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Function to generate numerical arrays",
    "text": "Function to generate numerical arrays\nNumPy provides automated methods for generating numerical sequences, which are essential for simulations, sampling, and creating structured data.\n\nGenerating sequences\nThe two most used functions for generating ordered numerical sequences in NumPy are np.arange and np.linspace.\n\nnp.arange(start, stop, step): Generates an array of evenly spaced values within a specified range. The start value is inclusive, while the stop value is exclusive. The step parameter defines the spacing between values.\nExample: np.arange(0, 10, 2) produces [0, 2, 4, 6, 8].\nnp.linspace(start, stop, num): Creates an array of num evenly spaced values between start and stop, inclusive. This is useful for generating a specific number of points in a range.\n\n\n\n\n\n\n\nMost importantly, these functions can be used to create arrays of any kinds of numerical data, including integers and floating-point numbers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice that linspace is useful when we know the start and end value and the specific number of points we want to generate, while arange is useful when we know the start and end value and the step size between the points."
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#generating-filled-arrays",
    "href": "08/lecture_working_with_numpy.html#generating-filled-arrays",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Generating filled arrays",
    "text": "Generating filled arrays\nNumPy provides functions to create arrays filled with specific values, such as zeros, ones, or a constant value. These functions are useful for initializing arrays before performing computations.\nThe main functions for generating filled arrays are: - np.zeros(shape): Creates an array filled with zeros, where shape specifies the dimensions of the array. - np.ones(shape): Creates an array filled with ones. - np.full(shape, fill_value): Creates an array filled with a specified value (fill_value), where shape defines the dimensions of the array.\n- np.empty(shape): Creates an uninitialized array with the specified shape. The values in this array are not set to any particular value, so they may contain random data.\nThere are also functions that create arrays with the same shape and type as an existing array, which can be useful for initializing arrays that will be used in computations:\n\nnp.zeros_like(array): Creates an array of zeros with the same shape and type as the input array.\nnp.ones_like(array): Creates an array of ones with the same shape and type as the input array.\nnp.full_like(array, fill_value): Creates an array filled with a specified value, with the same shape and type as the input array."
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#random-data-generation",
    "href": "08/lecture_working_with_numpy.html#random-data-generation",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Random Data Generation",
    "text": "Random Data Generation\nRandom data generation is essential for simulations, statistical modeling, and testing algorithms.\nFor example, you might want to generate random samples from a normal distribution to simulate real-world data or create random datasets for testing purposes. Or you may want to simulate the effect of measurement errors in your data analysis. Or you may want to sub-sample a large dataset randomly to take a representative sample without bias.\nTo do all this, one needs methods to sample numbers that possess the statistical properties of the desired distribution, such as uniform, normal, or binomial distributions.\nStrictly speaking (classical) computers are deterministic machines, meaning they follow a set of rules and produce the same output for the same input every time. We have therefore to use algorithms to produce sequences of numbers that mimic the properties of random numbers.\nThese are called pseudo-random numbers. Pseudo-random number generators (PRNGs) use algorithms to produce sequences of numbers that appear random but are actually deterministic.\nA simple and classic example of a pseudo-random number generator is the Linear Congruential Generator (LCG). The LCG produces a sequence of numbers using the recurrence relation:\n\\[x_{n+1} = (a \\times  x_{n} + c)\\,\\mathrm{mod}\\, m\\]\nwhere\n- \\(x_n\\) is the current value,\n- \\(a\\) is the multiplier,\n- \\(c\\) is the increment,\n- \\(m\\) is the modulus.\nIn vanilla Python this looks like the following custom function\n\n\n\n\n\n\n\n\n\n\n\n\nThis will generate a sequence of pseudo-random integers. The choice of parameters (a, c, m) affects the quality and period of the generator.\n\n\n\n\n\n\nThe seed is crucial: it is the initial value that starts the algorithm to determin the subsequent values in the sequence. By setting the seed, you can ensure that the sequence is reproducible, meaning that running the same code with the same seed will produce the same sequence of numbers every time.\nIn numpy, we do not need to implement our own LCG, as it provides a built-in random number generator that is based on the Mersenne Twister algorithm, which is a widely used and efficient pseudo-random numbwer generator.\nWhat we do instead is to use the numpy.random sub-module, which provides a wide range of functions for generating random numbers from various distributions, including uniform, normal, and binomial distributions.\nThe standard way to to use it is the following:\n\nfirst, one initialises a new kind of object called a random number generator (RNG) using np.random.default_rng(). This is a numpy object capable of generating random numbers from various distributions. It allows us in particular to set the seed and therefore ensure reproducibility.\n\n\n\n\n\n\n\nWe can do this at any point in our code, but it is a good practice to do it at the beginning of our script or notebook, so that we can ensure that all random numbers generated in the script are reproducible. Putting the generator elsewhere (for example, inside a function) could lead to unexpected results, as the generator would be re-initialised each time the function is called.\nOnce we have a generator we can access any of its method to sample numbers from various distributions\nFor example:\n\nIntegers\nTo sample uniformly distributed integers, we can use the integers method of the generator. This method allows us to specify a range and the number of integers to generate.\n\n\n\n\n\n\n\n\n[0-1) uniform floats\nTo sample uniformly distributed floats between 0 and 1, we can use the random method of the generator. This method generates random floats in the range [0.0, 1.0) (which means 0 included and 1 excluded).\n\n\n\n\n\n\nAlternatively, we can use the uniform method to sample uniformly distributed floats in a specified range. This method allows us to specify the lower and upper bounds of the range, as well as the number of samples to generate.\n\n\n\n\n\n\n\n\nNormal distribution\nTo sample from a normal distribution, we can use the normal method of the generator. This method allows us to specify the mean and standard deviation of the distribution, as well as the number of samples to generate. The generated samples will follow a normal (Gaussian) distribution with the specified parameters."
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#sampling-a-siingle-value",
    "href": "08/lecture_working_with_numpy.html#sampling-a-siingle-value",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Sampling a siingle value",
    "text": "Sampling a siingle value\nIf we only want to sample a single value, we can simply not specify the size parameter, or set it to 1. This will return a single value sampled from the specified distribution.\n\n\n\n\n\n\nHowever, this can sometimes be more computationally costly than generating a larger sample and then selecting a single value from it.\n\n\n\n\n\n\nThis is a good example of the tradeoff between memory usage and computational efficiency: in modern machines, memory is quite cheap, so it is often more efficient to preallocate a larger array and then sample from it, rather than generating a single value at a time.\nA good size for preallocated numbers depends on your use case and available memory. Typical choices are:\n\nSmall tasks: 100 to 1,000 elements\nMedium tasks: 10,000 to 100,000 elements\nLarge tasks: 1,000,000 or more elements\n\nFor most data analysis or simulation tasks, starting with 100,000 elements is practical and efficient. Always ensure the size fits within your system’s memory limits."
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy.html",
    "href": "08/exercises_lecture_working_with_numpy.html",
    "title": "Exercises - Working with NumPy",
    "section": "",
    "text": "Create a 1D NumPy array arr of integers from 10 to 19. Access the element at index 3."
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy.html#exercise-9-problem-solving-with-numpy",
    "href": "08/exercises_lecture_working_with_numpy.html#exercise-9-problem-solving-with-numpy",
    "title": "Exercises - Working with NumPy",
    "section": "Exercise 9: Problem solving with NumPy",
    "text": "Exercise 9: Problem solving with NumPy\nConsider the following problem:\n\nA panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.\n\nThe problem is a two-dimensional problem. The passenger has coordinates \\(x(t), y(t)\\) and is performing uniform rotational motion, with angular velocity \\(\\omega\\) and radius \\(R\\).\nThe angle formed at which the passenger is located is \\(\\theta(t)\\) and simply evolves as\n\\[\\theta(t) = \\omega t +\\theta_0\\]\nwhere \\(\\theta_0\\) is the initial angle (\\(\\theta_0=0\\) in our case).\nHence, the trajectory is expressed by\n\\[\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n\\]\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\nThe first approach is via using vanilla Python\n\n\n\n\n\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on avoiding for loops and using NumPy’s array operations instead."
  },
  {
    "objectID": "01/week_01_home.html",
    "href": "01/week_01_home.html",
    "title": "Introduction to Data Types",
    "section": "",
    "text": "Welcome to the 2025 SCIF10002 Introduction to Coding and Data Analysis for Scientists course!",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_home.html#using-the-notebooks",
    "href": "01/week_01_home.html#using-the-notebooks",
    "title": "Introduction to Data Types",
    "section": "Using the Notebooks",
    "text": "Using the Notebooks\nThe file you have open is aJupyter Notebook. This is an interactive Python environment where you can both write and run code. All of the interactive parts of this course will take place in Jupyter notebooks.\nEach notebook is made up of two types of cells:\n- Text cells (like this one), which introduce and explain new topics.\n- Code cells, which contain Python code you can run and modify.\nTo run a code cell, click inside it and press Shift + Enter. You can also edit the code before running it. Give it a try in the cell below!",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_home.html#todays-material",
    "href": "01/week_01_home.html#todays-material",
    "title": "Introduction to Data Types",
    "section": "Today’s Material",
    "text": "Today’s Material\nToday, we will be learning about data types. As there is a range of ability in the class we have prepared three options for today’s work.\n\nImportant: For today, please choose just one of the options below. You’ll have many opportunities to revisit the other concepts later in the course, so focus on building confidence with the Beginner material before tackling more advanced work.\n\n\nOption 1: Beginner\nIf you are new to coding, or still building confidence in Python, today you should work through the Basic Data Types notebook linked below:\n\nBeginner: Basic Data Types\n\nIn this notebook you will find interactive code blocks and plenty of exercises. Coding is best learned by doing, so take your time to work through the material and attempt as many exercises as you can during today’s session!\n\n\nOption 2: Intermediate\nIf you have some coding experience and are already somewhat familiar with basic data types in Python, you may wish to choose this option.\nFirst, please do check over the exercises in the Basic Data Types notebook and ensure you can answer them. Even the most experienced programmers will have gaps in their knowledge, so it is important you check this.\n\nBeginner: Basic Data Types\n\nOnce you feel confident with the material above, move on to the Collections notebook. This will introduce you to Python’s built-in collections and highlight the differences between sets, lists, dicts, and tuples. As always, aim to complete as many of the exercises as you can.\n\nIntermediate: Collections\n\n\n\nOption 3: Advanced\nIf you are an experienced programmer with a strong grasp of Python, begin by reviewing the exercises in the notebooks below to ensure you are fully comfortable with the material:\n\nBeginner: Basic Data Types\n\nIntermediate: Collections\n\nOnce you are confident in your understanding, move on to the following notebook:\n\nAdvanced: Copying and References",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_home.html#getting-help",
    "href": "01/week_01_home.html#getting-help",
    "title": "Introduction to Data Types",
    "section": "Getting Help",
    "text": "Getting Help\nThere is a lot to remember when first learning Python. To get more help see the Python API. Another useful link is the W3 schools series on Python which is very good, especially for new users. Another way to get help if you are ever unsure what a function is doing is to use thehelp function in the Python terminal like so:\n\n\n\n\n\n\nIn class, you can ask for help from the lecturer, demonstrators and your peers around you. We advise you do not ask AI for help unless you are really stuck.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html",
    "href": "01/week_01_intro_to_data_types_intermediate.html",
    "title": "Intermediate: Collections",
    "section": "",
    "text": "Welcome to the Week 1 Intermediate Python Notebook. This notebook is designed for students who already have some experience with Python and are ready to build on the basics.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are designed to deepen your understanding and give you practical experience with new concepts.\nIn this notebook, you will explore Python’s collection data types: tuples, lists, dictionaries, and sets. These are powerful tools for grouping, organizing, and working with data in more complex ways.\nBe sure to work through the examples and attempt all the exercises. They are designed to help you practice, reinforce your learning, and prepare you for the more advanced topics ahead.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html#tuples-and-lists",
    "href": "01/week_01_intro_to_data_types_intermediate.html#tuples-and-lists",
    "title": "Intermediate: Collections",
    "section": "Tuples and lists",
    "text": "Tuples and lists\nIn this section, we are going to look at Tuples and Lists.\n\nA tuple is a collection which is ordered and unchangeable. In Python tuples are written with round brackets.\nA list is a collection which is ordered and changeable. In Python lists are written with square brackets.\n\n*where changeable means that once\nBoth tuples and lists are built-in data types, can hold elements of arbitrary datatypes and behave, in many respects, like mathematical vectors. However, for numerical vectors and arrays it is much better to use numpy arrays, which are covered later in the course.\nBelow are some examples of lists and tuples. Note again that lists and tuples can contain data of any type.\n\n\n\n\n\n\nThis means they can also be nested. I.e. we can put a list in a list, a tuple in a tuple, a list in a tuple and a tuple in a list!\n\n\n\n\n\n\n\nAdding to Lists and Tuples\nLists and tuples can be added to using the concatenation operator, +, like so:\n\n\n\n\n\n\n\n\nIndexing Lists and Tuples\nTo index in python, square brackets are used. This is a common convention which applies to almost all vector-like datatypes in Python, e.g. tuples, lists, strings, numpy arrays, etc.\nPython uses zero indexing, which means that the first element in a list of length n is indexed as 0 and the last element is indexed as n-1. For example see the below (note that the same can also be done for tuples):\n\n\n\n\n\n\nNegative numbers can also be used to index lists (and other similar datatypes). For example, the index -1 will give the last element of the list, the index -2 will give the second to last element of the list and so on. This is known as circular wrap-around.\nFor a list of length n any index can be used between -n and (n-1) (inclusive) to access elements in the list. Indices outside of this range, however, will give an “index out of range” error.\n\n\n\n\n\n\nNote that nested lists and tuples support nested indexing but this involve multiple sets of square brackets (for example see below).\nYou may be more familiar with indexing of the form example_list[a,b] (i.e. only one set of square brackets); this syntax does exist in Python but unfortunately not for lists. In fact, this syntax is used heavily by numpy arrays (which we will cover later in the course).\n\n\n\n\n\n\n\n\nSlicing Tuples and Lists\nA range of index values can be specified to extract values from a list using a colon, :. This way of accessing data is known as slicing and can be performed as follows:\n\n\n\n\n\n\n\nWarning: Often, in other languages such as Matlab the syntax 0:3 represents the range [0,1,2,3]; however, in python 0:3 represents only [0,1,2]. In other words the syntax k:n includes [k,k+1,...n-1] but does not include n itself! This is common to all data types in python and should always be remembered when indexing anything in Python!\n\nWhen indexing in python you can leave the start and end values implicit. This will give the same effect as starting from the beginning of the list and ending at the end of the list. For example:\n\n\n\n\n\n\nYou can also indicate a step size when indexing by using the following syntax:\n\n\n\n\n\n\nAnd you can run backwards through the list by using negative integers as the step size. For example:\n\n\n\n\n\n\n\n\nOperations on Lists and Tuples\nOther operations are also available for lists and tuples. Most notably, the * symbol can be used to replicate a list or tuple like so:\n\n\n\n\n\n\nOther notable operations for lists include:\n\ninsert: This function adds an element to the list at a specified position.\npop: This function removes the element in the list at the specified position.\nremove: This function removes the item with the specified value from the list.\nreverse: This function reverses the order of the list.\nsort: This function sorts the list.\n\nA few examples of these functions are given below. Try changing and editing the below code to check your understanding! Again, this is by no means a comprehensive list; more information can be found in the Python API or in the W3 schools documentation.\n\n\n\n\n\n\nNot as many operations are available for tuples as tuples are immutable (not meant to change in value). Two available operations are:\n\ncount: This function returns the number of times a specified value occurs in the tuple.\nindex: This function searches the tuple for a specified value and returns the position of where it was found.\n\nExamples of these are given below. For more information on tuples please visit the Python API or the W3 schools documentation.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html#sets-and-dictionarys",
    "href": "01/week_01_intro_to_data_types_intermediate.html#sets-and-dictionarys",
    "title": "Intermediate: Collections",
    "section": "Sets and Dictionarys",
    "text": "Sets and Dictionarys\nIn this section, we are going to look in more detail at Sets and Dictionarys.\n\nA set is a collection which is unordered, changeable and unindexed. In Python sets are written with curly brackets.\nA dictionary is a collection which is unordered, changeable and indexed. In Python dictionarys are also written with curly brackets but also with keys and values.\n\nLike tuples and lists, both sets and dictionarys are built-in python types and can hold elements of arbitrary data types. However, unlike tuples and lists they do not behave like vectors as they are unordered. In other programming languages, such as Java, you may have heard of dictionarys referred to as hashmaps.\nBelow are some examples of sets and dictionarys.\n\n\n\n\n\n\n\nAdding elements to and retreiving elements from Dictionarys\nElements can be added to dictionarys as keys and values. For example; in the first line below the key is a and the value is b. Note that a key does not have to be a string; integers and floats work just as well. Values can be of any data type.\n\n\n\n\n\n\nWe can then retreive values from the dictionary using the keys we stored them under. This can be done with either square brackets or the built-in get function. For example:\n\n\n\n\n\n\n\n\nRemoving elements from a dictionary\nElements can be removed from a dictionary using the pop and del methods. For example:\n\n\n\n\n\n\n\n\nOperations on Dictionarys\nOther operations are also available for dictionarys. Some of the most useful of these are;\n\nkeys: This function returns a list containing the dictionary’s keys.\nvalues: This function returns a list of all the values in the dictionary.\nitems: This function returns a list containing a tuple for each (key, value) pair.\n\nExamples of these functions are given below. For full documentation and details on more functions see the Python API and W3 schools Python documentation.\n\n\n\n\n\n\n\n\nAdding elements to a set\nElements can be added to a set using the add function. For example, see the below code.\nNote that a set is designed to mimic the idea of a set in mathematics and, therefore, sets do not allow for duplicate entries. An entry is either in or not in a set; it cannot be “in” a set twice.\nMultiple elements can also be added to a set at once using the update method.\n\n\n\n\n\n\nHowever, there is no notion of indexing for Python sets as sets are unordered. This means that individual elements cannot be accessed in the same manor as in dictionarys, lists and tuples. We can check if an element is in a set, however, using the in keyword.\n\n\n\n\n\n\n\n\nRemoving elements from a set\nElements can be removed from a set using the remove function. Note: the remove function will errror if the requested value is not in the set.\n\n\n\n\n\n\n\n\nOperations on Sets\nOther operations are also available for sets, many of which are designed to mimic mathematic functions. For example:\n\ndifference: This function returns a set containing the difference between two or more sets.\nintersection: This function returns a set which is the intersection of two other sets.\nissubset: This function returns True if the first set input contains the second set input and False otherwise.\nissuperset: This function returns True if the first set input is contained within the second set input and False otherwise.\nunion: This function returns a set containing the union of input sets.\n\nExamples of these are given below. For full documentation and details on more functions see the Python API and W3 schools Python documentation.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html#exercises",
    "href": "01/week_01_intro_to_data_types_intermediate.html#exercises",
    "title": "Intermediate: Collections",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: The below code creates a list of numbers:\n\n\n\n\n\n\nUsing this list, write code which does the following: 1. retrieves the third element of the list 2. slice the first three elements of the list 3. replaces the last element with 10 4. appends 7 to the end of the list 5. removes the first occurrence of 2\nMake sure to print the list after each change.\n\n\n\n\n\n\nQuestion 2: The below code creates a list, casts it to a set and then casts it back to a list.\n\n\n\n\n\n\nThe new list doesn’t equal the original list. Why do you think this might be?\nHint: Try printing my_list and my_new_list.\nQuestion 3: A string can be converted to a set using the set() constructor. Use this fact to identify which letter appears in string2 but not in string1 below:\n\n\n\n\n\n\nHint: You might want to recap difference function from this notebook and the lower() function from the beginner notebook.\nQuestion 4: The below code creates a tuple named t.\n\n\n\n\n\n\nWrite some code which does the following:\n\naccess the first and last elements of t\nslice out ('b', 'c', 'd')\ncheck whether 'c' is in t\nfind the index of 'd' in t\ncount how many times 'a' appears in t\n\n\n\n\n\n\n\nQuestion 5: You are given the below dataset for 5 individuals in a clinical trial.\n\n\n\nName\nWeight (kg)\nHeight (cm)\n\n\n\n\nJohn\n82\n178\n\n\nAlice\n68\n165\n\n\nMaria\n74\n170\n\n\nDavid\n90\n185\n\n\nSarah\n60\n160\n\n\n\nUsing the collection types introduced in this notebook (lists, tuples, sets, dictionaries - no loops or user-defined functions), choose an appropriate way to represent the clinical-trial table. Write your code in the box below.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html",
    "href": "01/week_01_solutions_demonstrator_version.html",
    "title": "Week 1: Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 1 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html#beginner-basic-data-types",
    "href": "01/week_01_solutions_demonstrator_version.html#beginner-basic-data-types",
    "title": "Week 1: Solutions",
    "section": "Beginner: Basic Data Types",
    "text": "Beginner: Basic Data Types\nQuestion 1: The solution to the question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: The purpose of this question is to prompt students to think about the use of the and and or boolean operators, as well as the syntax for &lt;. When advising students on this question, make sure to help them break the inequalities \\(x^2&lt;y&lt;z^3\\) and \\(z^3&lt;y&lt;x^2\\) down using the and statement.\n\nQuestion 2: The solution to the question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: Last year, many of the students struggled with Boolean logic. This question aims to get them thinking about how to combine logical connectives like and and not. If students are struggling with this, please try and prompt them to convert the natural language sentence it's raining and I don't have my umbrella to logical syntax by breaking it down into smaller sentences. Highlight that I don't have my umbrella is the logical opposite (negation) of I have my umbrella.\n\nQuestion 3: The completed truth table for this question is:\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\nA and B\nnot C\n(A and B) or (not C)\n\n\n\n\nTrue\nTrue\nTrue\nTrue\nFalse\nTrue\n\n\nTrue\nTrue\nFalse\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nTrue\nFalse\nFalse\nFalse\nTrue\nTrue\n\n\nFalse\nTrue\nTrue\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nFalse\nFalse\nFalse\nFalse\nTrue\nTrue\n\n\n\nAnd the code for this question is:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is again designed to get students thinking about Boolean logic. It is expected that, for many students, this will be their first encounter with truth tables and first-order logical operators.\nIf a student is struggling with the abstraction, try to relate A, B and C to the example given in the slides. In the slides, A represents the statement The cat is black and B represents the statement The cat has four legs. To extend the example, you could define C to be, for instance, The cat has blue eyes. Once this is understood, try building the truth table column by column, starting with the A and B column, then the not C column and then finally the (A and B) or (not C) column.\nWhen giving examples, try to avoid statements with vague/ambiguous truth values. For instance, The cat is tall has an ambiguous truth value as there is not a clear distinction between tall and not tall.\n\nQuestion 4: The solution to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: At this stage, students will not know any numpy, so please make sure to use x**(1/2) instead of functions such as np.sqrt(x). These functions will be taught at a later stage. It is expected that many students here will mistakenly write ^ for exponentiation instead of **, so please look out for this mistake. Some students may also need reminding that Pythagoras’ theorem can be used to compute the length of the diagonal.\n\nQuestion 5: The solution to this question is given by:\n\n\n\n\n\n\n\nDemonstrator Notes: Whilst the SUVAT equations are part of the UK A-level Physics syllabus, please be aware that many students may not know them. For instance, data science or chemistry students may not have taken Physics A-level (or potentially even GCSE) and overseas students may have been taught the subject using different notations. For this reason, be aware students may be non-responsive to this question because they do not understand that, e.g., a should be set to 9.81. Try to assess whether the student is comfortable with the subject material before giving advice on how to solve the problem here.\n\nQuestion 6: The solution to this question is given by:\n\n\n\n\n\n\n\nDemonstrator Notes: See comments on previous question. Also be aware that there are multiple solutions to this question, as any of the equations \\(v=u+at\\), \\(s=ut+\\frac{1}{2}at^2\\) or \\(s=\\frac{(u+v)t}{2}\\) can be used. Students who are unsure what to do should be encouraged to look at the linked document for question 5.\n\nQuestion 7: A code block containing the examples from the question is given below:\n\n\n\n\n\n\nThe answers follow by standard boolean logic. The only difficult parts are determining the order of operations for the third example (python will interpret this as True or (False and False) rather than (True or False) and False) and the xor (^) on the fourth line.\n\nDemonstrator Notes: Some students may find this question confusing because we are using the Boolean values True and False directly, rather than naming them as variables (e.g. A and B). Emphasize that there is no difference between the below code:\nA = True\nB = False\nprint(A and B)\nand this code:\nprint(True and False)\nThe logic is identical - the only change is whether we use named variables or literal values. Point this out clearly so students see that the rules of Boolean logic still apply in exactly the same way.\n\nQuestion 8: The error in the code occurs when float(x + y) is run.\nWhen x and y are numeric, the + symbol is interpreted as addition and the result is cast to a float (e.g. if x=1 and y=5 as in the first example then x+y yeilds 6). However, if they are instead strings (as in the second example), then the + symbol is interpreted as concatenation rather than addition. Therefore, when x='2' and y='5', we get that 2+5 yeilds 25, not 7.\nThere are two approaches to resolving the issue. The first is to replace x='2' and y='5' with x=2 and y=5. The second, and preferred option, is to replace float(x + y) with float(x)+float(y) so there is no possibility that the + symbol is interpreted as concatenation here.\n\nDemonstrator Notes: If students are struggling with this question, suggest that they search the document for the + symbol and make sure they understand how it is being used. Hint that the symbol might not be interpreted in the way they first expect, but avoid giving away the full answer unless they are really stuck. The aim is to guide them toward discovering the behaviour themselves.\n\nQuestion 9: The first box is an assignment of the value 2 + 1 to a variable named three, so does not print anything. The second box prints true as the variable z = (1 + 2 == 3) is interpreted as a Boolean variable, and in Jupyter notebooks, if the last line of a box is simply a variable, with no assignment, then that variable is printed out. z is evaluated as True (as 1 + 2 does equal 3 in Python), so True is printed.\nFor the third box, False is printed as due to rounding errors 0.1 + 0.2 is evaluated to 0.30000000000000004 rather than 0.3. This is a cautionary note that floating point math is not perfect.\n\nDemonstrator Notes: First, it aims to get students to think about the difference between the assignment operator = and the equality operator ==. Second, it serves as a cautionary note about floating point arithmetic in Python.\nAfter seeing the result, many students may ask how to properly check whether 0.1 + 0.2 equals 0.3. For now, explain that we will cover this in more detail when we look at numpy. If they push further, encourage them to think about constructing a Boolean expression (similar to Question 1) that checks whether two numbers differ by only a very small amount. The aim here is to prepare them for the np.allclose function later on, while prompting them to reason about the problem themselves rather than being given the solution straight away.\n\nQuestion 10: The final solution is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is designed to give students practice with the string replace function. Encourage them to experiment and work through the task step by step, even if their first attempt doesn’t work. The key learning outcome is to get comfortable with testing, adjusting, and trying again - it aims to enforce good programming habits."
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html#intermediate-collections",
    "href": "01/week_01_solutions_demonstrator_version.html#intermediate-collections",
    "title": "Week 1: Solutions",
    "section": "Intermediate: Collections",
    "text": "Intermediate: Collections\n\nBroad Notes for Demonstrators: If you see a student attempting the intermediate questions who does not seem at the level of the material, please do encourage them to first try the beginner notebook.\n\nQuestion 1: The code for this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question aims to give students some initial practice with lists. Common errors to look out for include failing to account for the fact Python uses zero indexing, or that slicing syntax such as nums[:3] doesn’t include nums[3] in the output, only nums[0],nums[1] and nums[2].\n\nQuestion 2: The key to this question is that a list is ordered whilst a set is unordered. When the list is converted to a set, it’s ordering is lost, and when converted back to a list it is now given in increasing (numerical) order by default.\n\nDemonstrator Notes: Hopefully, this should not be a difficult question. Encourage students who are struggling to print out my_set and my_list and describe what is different between them.\n\nQuestion 3: The answer to this question is the letter k. To see this, the below code can be used:\n\n\n\n\n\n\n\nDemonstrator Notes: This question brings together concepts from both the Beginner and Intermediate notebooks, making it a good checkpoint to assess whether students are ready to move into the Intermediate material.\nIf students are struggling, suggest that they try the task on paper first. They will probably start by writing out the letters from each sentence and then comparing the two sets of letters. From there, you can show how Python supports the same process by turning a string into a list of characters and then using the set constructor to remove duplicates. This should hopefully help them connect the manual approach with the Python solution.\nOnce they have these concepts down, encourage students to think about why the lower() function (as suggested in the hint) is useful here. It ensures that comparisons between characters are case-insensitive.\n\nQuestion 4: The code for this question is provided below.\n\n\n\n\n\n\n\nDemonstrator Notes: See notes on Question 1.\n\nQuestion 5: There are many ways to approach this question. Two examples are given below:\n\n\n\n\n\n\n\nDemonstrator Notes: The aim of this question is to help students recognise that there are multiple valid ways to represent the same dataset in Python. The important part is thinking about how the data will be used. For example, if we need to look up information by subject name, a dictionary of dictionaries might be best; if we want to work with all weights at once (e.g. to build a histogram), a dictionary of lists is more convenient. Emphasise that the choice of data structure depends on the task - there isn’t one ‘right’ answer."
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html#advanced-copying-and-references",
    "href": "01/week_01_solutions_demonstrator_version.html#advanced-copying-and-references",
    "title": "Week 1: Solutions",
    "section": "Advanced: Copying and References",
    "text": "Advanced: Copying and References\n\nBroad Notes for Demonstrators: If you see a student attempting the intermediate or advanced questions who does not seem at the level of the material, please do encourage them to first try the earlier notebooks.\n\nQuestion 1: The expected output is [1,2,3,4]. This is because list_a and list_b reference the same location in memory.\n\n\n\n\n\n\n\nDemonstrator Notes: The aim of this question is to get students to recognise that lists are mutable. As a list is mutable, both list_a and list_b refer to the same underlying object in memory. When we do list_b = list_a, we are not creating a copy of the list, but simply creating a new reference to the same list object. Therefore, when we perform list_a.append(4), the change is reflected in both list_a and list_b. Encourage students to think about how they could gain the desired behaviour using the .copy() function (e.g. list_b = list_a.copy()).\n\nQuestion 2: Code A will print [1,2,3] whilst Code B will print [4,5,6]. This is because, when we replace a with [4,5,6] we change the reference to point to a new location in memory, breaking the connection between a and b. However, when we change the elements in a individually, both a and b remain pointing to the same location in memory. Thus, when we print b, we get [4,5,6].\n\n\n\n\n\n\n\nDemonstrator Notes: See notes for Question 1.\n\nQuestion 3: The variable names xyz and xyzsquared are pointing to the same array. When we squared xyzsquared we also squared xyz. We could have avoided this by making xyzsquared a seperate copy of xyz using the list constructor like so:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is designed to give students practice debugging code. Try to guide them to the solution where possible, rather than providing the full solution straight away.\n\nQuestion 4: When you do backup = list(grid), Python only makes a new outer list. The smaller lists inside ([1, 2], [3, 4], [5, 6]) are still the exact same objects that grid is using. Because of that, if you change one of the inner lists, the same change shows up backup.\n\nDemonstrator Notes: The aim of this question is to understand why the unexpected behaviour occured. If students ask how to fix this, that’s a natural question, but at this stage they don’t yet have the tools to do so. For now, keep the focus on helping them understand why the behaviour occurs, instead of talking about fixes at this stage.\n\nQuestion 5: The reasoning for this question is similar to that of Question 4, but noting that the three inner lists are all pointing to the same place in memory.\n\nDemonstrator Notes: See the notes for Question 4."
  }
]