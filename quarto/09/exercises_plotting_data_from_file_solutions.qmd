---
title: Plotting data from file
jupyter: python3
---



How can we use what we have learnt in the past few workshops to read data from a file? And how can we plot this?

One way to then plot this data would be to extract the index and/or multiple columns we are interested in plotting and use `matplotlib` as we have done before.

As an example, we'll look at a new data file. This contains a simulation of the (fractional) concentration change for two species in a reaction, "A" and "B" where $A \rightarrow B$.

```{python}
data_filename = "data/FIRST ORDER_k=0.0005.txt"
```

If we open this file more directly in Python when we looked at a text file) we can take quick look at the contents to see what this looks like:

```{python}
open_file = open(data_filename)
data_from_file = open_file.read()
print(data_from_file[0:200])
```

From printing out the first 200 characters, we can see this looks like a table of data with each column separated by spaces. This looks nicely formatted with a title row including the column names and no extra header rows.

We will see in the next year that there are dedicate packages to manipulate large tabulated files. However, for now we can exploit `numpy` as a quick and effective way to read such input.

```{python}
import numpy as np

data_kinetic_k0005 = np.genfromtxt("data/FIRST ORDER_k=0.0005.txt", names=True)
```

This is a special kind of array called a **structured** array, because it has **named fields**. You can check this by querying the subproperties of the array:

```{python}
data_kinetic_k0005.dtype.names
```

These various **names are the fields** of the array, corresponding to the columns in the file. This syntax is reminiscent of what we have seen in the case of **dictionaries**, where **keys** are used to specific other objects stored in the dictionary.

```{python}
data_kinetic_k0005['A']
```

This data also has a column for "Time" as the number of seconds elapsed.

```{python}
data_kinetic_k0005 ['Time']
```

To create a plot for **time** vs **concentration of A**, we can extract this data from our array

```{python}
# Extract time and concentration of A from our array
time = data_kinetic_k0005['Time']
concentration_A = data_kinetic_k0005["A"]
```

We could then use matplotlib to plot this:

```{python}
import matplotlib.pyplot as plt

# Create our Figure and Axes objects for plotting
fig, ax = plt.subplots()

# Plot our data - time vs concentration of A
ax.plot(time, concentration_A)

# Add x and y labels for this data
ax.set_xlabel("Time (s)")
ax.set_ylabel("Concentration")
```

This simulation shows a clean relationship as concentration decreases over time (in an exponential way).

Suppose we want to filter our data and plot only concentrations less than 0.5. We can simply create a **boolean** array that masks the invalid data.

```{python}
mask = concentration_A <= 0.5
concentration_A_low = concentration_A[mask]
# Make sure to match the time values (index) to our filtered data
time_low = time[mask]
```

Here we have filtered our data to include all fractional concentrations less than (or equal to) 0.5. Notice we have also matched our time values to plot to these concentrations by extracting the index from our new array `concentration_A_low`.

```{python}
# Create our Figure and Axes objects for plotting
fig, ax = plt.subplots()

# Plot our data - time vs concentration of A
ax.plot(time_low, concentration_A_low)

# Note: Alternative syntax! we can set multiple properties at once
ax.set(xlabel = "Time (s)",  ylabel="Concentration")
```

You can also see the slope is similiar (in fact it is the same) between our unfiltered and filtered data (this is due to the exponential relationship).

---

### Exercise 

 1. Re-plot the un-filtered graph created above and add another line to show **concentration of B** vs **time**  from the `data_kinetic_k0005` array on the same plot. 
  - Can you include a label for A and B?

```{python}
#| tags: [sol]
### ADD CODE HERE (copy code from above and add to this)

fig, ax = plt.subplots()

ax.plot(time, concentration_A, label="A")
ax.plot(time, data_kinetic_k0005["B"], label="B")

ax.set_xlabel("Time (s)")
ax.set_ylabel("Concentration")
ax.legend()
```

2. Calculate the the sum of the concentrations for these two columns (A and B).

```{python}
#| tags: [sol]
### ADD CODE HERE

sum_concentration = concentration_A + data_kinetic_k0005["B"]
print(sum_concentration)
```

3. Re-plot the graph created in the previous question and add this sum as a third line.

 - Consider: What does this sum tell us about "A" is decaying into "B"?

```{python}
#| tags: [sol]
### ADD CODE HERE (copy code from previous question and add to this)

fig, ax = plt.subplots()

ax.plot(time, concentration_A, label="A")
ax.plot(time, data_kinetic_k0005["B"], label="B")

ax.set_xlabel("Time (s)")
ax.set_ylabel("Concentration")
ax.plot(time, sum_concentration, label="A+B")
ax.legend()
```

> We add the sum of concentrations (A+B) as a third line to the plot. This sum remains very close to 1 throughout the reaction, indicating that as "A" decays, it is converted into "B" without significant loss or gain of total concentration. This demonstrates conservation of mass in the reaction: all of "A" is accounted for as it becomes "B".


