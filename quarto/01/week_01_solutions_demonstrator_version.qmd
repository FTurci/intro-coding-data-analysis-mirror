---
title: 'Week 1: Solutions'
jupyter: python3
---



This notebook contains the solutions to the week 1 `Beginner`, `Intermediate` and `Advanced` exercises.

### Table of Contents

 - [Welcome Page](./week_01_home.qmd)
 - [Beginner: Basic Data Types](./week_01_intro_to_data_types_beginner.qmd)
 - [Intermediate: Collections](./week_01_intro_to_data_types_intermediate.qmd)
 - [Advanced: Copying and References](./week_01_intro_to_data_types_advanced.qmd)

 - [**Solutions**](./week_01_solutions.qmd)
   - [Beginner: Basic Data Types](#Beginner:-Basic-Data-Types)
   - [Intermediate: Collections](#Intermediate:-Collections)
   - [Advanced: Copying and References](#Advanced:-Copying-and-References)

## Beginner: Basic Data Types

**Question 1:** The solution to the question is given below:

```{python}
# Variables x, y and z
x = 1
y = 2
z = 1.26

my_boolean = ((x**2 < y) and (y < z**3)) or ((z**3 < y) and (y < x**2))
```

> **Demonstrator Notes:** The purpose of this question is to prompt students to think about the use of the `and` and `or` boolean operators, as well as the syntax for `<`. When advising students on this question, make sure to help them break the inequalities $x^2<y<z^3$ and $z^3<y<x^2$ down using the `and` statement.

**Question 2:** The solution to the question is given below:

```{python}
# Boolean variables
is_raining = True
have_umbrella = False

# Boolean telling you if you are going to get rained on
got_soaked = is_raining and (not have_umbrella)

print('Question: Will I get rained on?')
print('Answer: ' + str(got_soaked))
```

> **Demonstrator Notes:** Last year, many of the students struggled with Boolean logic. This question aims to get them thinking about how to combine logical connectives like `and` and `not`. If students are struggling with this, please try and prompt them to convert the natural language sentence `it's raining and I don't have my umbrella` to logical syntax by breaking it down into smaller sentences. Highlight that `I don't have my umbrella` is the logical opposite (negation) of `I have my umbrella`.

**Question 3:** The completed truth table for this question is:


| `A`     | `B`     | `C`     | `A and B` | `not C` | `(A and B) or (not C)` |
|---------|---------|---------|-----------|---------|------------------------|
| `True`  | `True`  | `True`  | `True`    | `False` | `True`                 | 
| `True`  | `True`  | `False` | `True`    | `True`  | `True`                 | 
| `True`  | `False` | `True`  | `False`   | `False` | `False`                | 
| `True`  | `False` | `False` | `False`   | `True`  | `True`                 | 
| `False` | `True`  | `True`  | `False`   | `False` | `False`                | 
| `False` | `True`  | `False` | `False`   | `True`  | `True`                 | 
| `False` | `False` | `True`  | `False`   | `False` | `False`                | 
| `False` | `False` | `False` | `False`   | `True`  | `True`                 | 

And the code for this question is:

```{python}
# Boolean variables
A = True
B = False
C = True

# Compute new boolean
my_boolean = (A and B) or (not C)
print(my_boolean)
```

> **Demonstrator Notes:** This question is again designed to get students thinking about Boolean logic. It is expected that, for many students, this will be their first encounter with truth tables and first-order logical operators. 
>
> If a student is struggling with the abstraction, try to relate `A`, `B` and `C` to the example given in the slides. In the slides, `A` represents the statement `The cat is black` and `B` represents the statement `The cat has four legs`. To extend the example, you could define `C` to be, for instance, `The cat has blue eyes`. Once this is understood, try building the truth table column by column, starting with the `A and B` column, then the `not C` column and then finally the `(A and B) or (not C)` column.
> 
> When giving examples, try to avoid statements with vague/ambiguous truth values. For instance, `The cat is tall` has an ambiguous truth value as there is not a clear distinction between `tall` and `not tall`.

**Question 4:** The solution to this question is given below:

```{python}
# Height and width variables
height = 10
width = 3

# Perimeter
perimeter = 2*(height+width)

# Area
area = height*width

# Diagonal
diag = (height**2 + width**2)**(1/2)

# Print results
print(perimeter, area, diag)
```

> **Demonstrator Notes:** At this stage, students will not know any `numpy`, so please make sure to use `x**(1/2)` instead of functions such as `np.sqrt(x)`. These functions will be taught at a later stage. It is expected that many students here will mistakenly write `^` for exponentiation instead of `**`, so please look out for this mistake. Some students may also need reminding that Pythagoras' theorem can be used to compute the length of the diagonal.

**Question 5:** The solution to this question is given by:

```{python}
# Known variables
v = 10
u = 0
a = 9.81

# Compute s
s = (v**2-u**2)/(2*a)
print(s)
```

 > **Demonstrator Notes:** Whilst the SUVAT equations are part of the UK A-level Physics syllabus, please be aware that many students may not know them. For instance, data science or chemistry students may not have taken Physics A-level (or potentially even GCSE) and overseas students may have been taught the subject using different notations. For this reason, be aware students may be non-responsive to this question because they do not understand that, e.g., `a` should be set to `9.81`. Try to assess whether the student is comfortable with the subject material before giving advice on how to solve the problem here.

**Question 6:** The solution to this question is given by:

```{python}
# Compute time using variables from Question 5
t = 2*s/(u+v)
print(t)
```

 > **Demonstrator Notes:** See comments on previous question. Also be aware that there are multiple solutions to this question, as any of the equations $v=u+at$, $s=ut+\frac{1}{2}at^2$ or $s=\frac{(u+v)t}{2}$ can be used. Students who are unsure what to do should be encouraged to look at the linked document for question 5.

**Question 7:** A code block containing the examples from the question is given below:

```{python}
print((True and False) or True)
print(not (False or False))
print(True or False and False)
print(False ^ True)
print((True and not True) and (False or not False))
```

The answers follow by standard boolean logic. The only difficult parts are determining the order of operations for the third example (python will interpret this as `True or (False and False)` rather than `(True or False) and False`) and the xor (`^`) on the fourth line.

> **Demonstrator Notes:** Some students may find this question confusing because we are using the Boolean values `True` and `False` directly, rather than naming them as variables (e.g. `A` and `B`). Emphasize that there is no difference between the below code:  
> ```
> A = True
> B = False
> print(A and B)
> ```  
> and this code: 
> ```
> print(True and False)
> ```  
> The logic is identical - the only change is whether we use named variables or literal values. Point this out clearly so students see that the rules of Boolean logic still apply in exactly the same way.  

**Question 8:** The error in the code occurs when `float(x + y)` is run. 

When `x` and `y` are numeric, the `+` symbol is interpreted as addition and the result is cast to a float (e.g. if `x=1` and `y=5` as in the first example then `x+y` yeilds `6`). However, if they are instead strings (as in the second example), then the `+` symbol is interpreted as concatenation rather than addition. Therefore, when `x='2'` and `y='5'`, we get that `2+5` yeilds `25`, not `7`.

There are two approaches to resolving the issue. The first is to replace `x='2'` and `y='5'` with  `x=2` and `y=5`. The second, and preferred option, is to replace `float(x + y)` with `float(x)+float(y)` so there is no possibility that the `+` symbol is interpreted as concatenation here.

> **Demonstrator Notes:** If students are struggling with this question, suggest that they search the document for the `+` symbol and make sure they understand how it is being used. Hint that the symbol might not be interpreted in the way they first expect, but avoid giving away the full answer unless they are really stuck. The aim is to guide them toward discovering the behaviour themselves.  

**Question 9:** The first box is an assignment of the value `2 + 1` to a variable named `three`, so does not print anything. The second box prints `true` as the variable `z = (1 + 2 == 3)` is interpreted as a Boolean variable, and in Jupyter notebooks, if the last line of a box is simply a variable, with no assignment, then that variable is printed out. `z` is evaluated as `True` (as `1 + 2` does equal `3` in Python), so `True` is printed.

For the third box, `False` is printed as due to rounding errors `0.1 + 0.2` is evaluated to `0.30000000000000004` rather than `0.3`. This is a cautionary note that floating point math is not perfect.

> **Demonstrator Notes:** First, it aims to get students to think about the difference between the assignment operator `=` and the equality operator `==`. Second, it serves as a cautionary note about floating point arithmetic in Python.
> 
> After seeing the result, many students may ask how to properly check whether `0.1 + 0.2` equals `0.3`. For now, explain that we will cover this in more detail when we look at `numpy`. If they push further, encourage them to think about constructing a Boolean expression (similar to Question 1) that checks whether two numbers differ by only a very small amount. The aim here is to prepare them for the `np.allclose` function later on, while prompting them to reason about the problem themselves rather than being given the solution straight away.  

**Question 10:** The final solution is given below:

```{python}
# The string we want to transform
start_string = 'Thas as te arang we want!'
print('Start:  ', start_string)

# Helper strings you can use for replacements
string1 = 'a'
string2 = 'st'
string3 = 'he a'
string4 = ' ge'
string5 = 'stri'
string6 = 'sts'
string7 = 'is'
string8 = 'ara'
string9 = 'gen'
string10 = 'e a'

# Step 1
step1 = start_string.replace(string1,string2)
print('Step 1: ', step1)

# Step 2
step2 = step1.replace(string6,string7)
print('Step 2: ', step2)

# Step 3
step3 = step2.replace(string2, string1)
print('Step 3: ', step3)

# Step 4
step4 = step3.replace(string10, string3)
print('Step 4: ', step4)

# Step 5
step5 = step4.replace(string8, string5)
print('Step 5: ', step5)
```

> **Demonstrator Notes:**  This question is designed to give students practice with the string `replace` function. Encourage them to experiment and work through the task step by step, even if their first attempt doesn’t work. The key learning outcome is to get comfortable with testing, adjusting, and trying again - it aims to enforce good programming habits.  

## Intermediate: Collections

> **Broad Notes for Demonstrators:** If you see a student attempting the intermediate questions who does not seem at the level of the material, please do encourage them to first try the beginner notebook. 

**Question 1:** The code for this question is given below:

```{python}
# Original list
nums = [5, 2, 8, 2, 9]
print("Original list:", nums)

# 1. Retrieve the third element (index 2 because indexing starts at 0)
third_element = nums[2]
print("Third element:", third_element)

# 2. Slice the first three elements
first_three = nums[:3]
print("First three elements:", first_three)

# 3. Replace the last element with 10
nums[-1] = 10
print("After replacing last element with 10:", nums)

# 4. Append 7 to the end of the list
nums.append(7)
print("After appending 7:", nums)

# 5. Remove the first occurrence of 2
nums.remove(2)
print("After removing first occurrence of 2:", nums)
```

 > **Demonstrator Notes:** This question aims to give students some initial practice with lists. Common errors to look out for include failing to account for the fact Python uses zero indexing, or that slicing syntax such as `nums[:3]` doesn't include `nums[3]` in the output, only `nums[0]`,`nums[1]` and `nums[2]`.

**Question 2:** The key to this question is that a list is *ordered* whilst a set is *unordered*. When the list is converted to a set, it's ordering is lost, and when converted back to a list it is now given in increasing (numerical) order by default.

> **Demonstrator Notes:** Hopefully, this should not be a difficult question. Encourage students who are struggling to print out `my_set` and `my_list` and describe what is different between them.

**Question 3:** The answer to this question is the letter `k`. To see this, the below code can be used:

```{python}
# Here are two strings
string1 = "This is a long random sentence - I wonder which letters it contains and which letters it doesn't."
string2 = "This task makes a clear and coherent string with words taken inside a small set"

# Make strings lowercase
string1 = string1.lower()
string2 = string2.lower()

# Convert strings to sets
string1 = set(string1)
string2 = set(string2)

# Compute the set difference
print(string2.difference(string1))
```

> **Demonstrator Notes:** This question brings together concepts from both the `Beginner` and `Intermediate` notebooks, making it a good checkpoint to assess whether students are ready to move into the `Intermediate` material. 
>
> If students are struggling, suggest that they try the task on paper first. They will probably start by writing out the letters from each sentence and then comparing the two sets of letters. From there, you can show how Python supports the same process by turning a string into a list of characters and then using the `set` constructor to remove duplicates. This should hopefully help them connect the manual approach with the Python solution.  
>
> Once they have these concepts down, encourage students to think about why the `lower()` function (as suggested in the hint) is useful here. It ensures that comparisons between characters are case-insensitive.  

**Question 4:** The code for this question is provided below.

```{python}
# given tuple
t = ('a', 'b', 'c', 'd', 'e')

# 1. access the first and last elements of t
first = t[0]
last = t[-1]
print("First element:", first)
print("Last element:", last)

# 2. slice out ('b', 'c', 'd')
slice_part = t[1:4]
print("Slice ('b', 'c', 'd'):", slice_part)

# 3. check whether 'c' is in t
is_c_present = 'c' in t
print("'c' in t?", is_c_present)

# 4. find the index of 'd' in t
index_d = t.index('d')
print("Index of 'd':", index_d)

# 5. count how many times 'a' appears in t
count_a = t.count('a')
print("Count of 'a':", count_a)
```

> **Demonstrator Notes:** See notes on Question 1.

**Question 5:** There are many ways to approach this question. Two examples are given below:

```{python}
# ----------------------------------------------------------------
# Option 1:
# ----------------------------------------------------------------
# clinical trial dataset represented as a dictionary of lists
clinical_data = {
    "Name": ["John", "Alice", "Maria", "David", "Sarah"],
    "Weight (kg)": [82, 68, 74, 90, 60],
    "Height (cm)": [178, 165, 170, 185, 160]
}

print(clinical_data)

# ----------------------------------------------------------------
# Option 2:
# ----------------------------------------------------------------
# clinical trial dataset represented as a dictionary of dictionaries
clinical_data = {
    "John": {"Weight (kg)": 82, "Height (cm)": 178},
    "Alice": {"Weight (kg)": 68, "Height (cm)": 165},
    "Maria": {"Weight (kg)": 74, "Height (cm)": 170},
    "David": {"Weight (kg)": 90, "Height (cm)": 185},
    "Sarah": {"Weight (kg)": 60, "Height (cm)": 160}
}
```

> **Demonstrator Notes:** The aim of this question is to help students recognise that there are multiple valid ways to represent the same dataset in Python. The important part is thinking about how the data will be used. For example, if we need to look up information by subject name, a dictionary of dictionaries might be best; if we want to work with all weights at once (e.g. to build a histogram), a dictionary of lists is more convenient. Emphasise that the choice of data structure depends on the task - there isn’t one 'right' answer.

## Advanced: Copying and References

> **Broad Notes for Demonstrators:** If you see a student attempting the intermediate or advanced questions who does not seem at the level of the material, please do encourage them to first try the earlier notebooks. 

**Question 1:** The expected output is `[1,2,3,4]`. This is because `list_a` and `list_b` reference the same location in memory.

```{python}
list_a = [1, 2, 3]
list_b = list_a
list_a.append(4)
print(list_b)
```

> **Demonstrator Notes:** The aim of this question is to get students to recognise that lists are mutable. As a list is mutable, both `list_a` and `list_b` refer to the same underlying object in memory. When we do `list_b = list_a`, we are not creating a copy of the list, but simply creating a new reference to the same list object. Therefore, when we perform `list_a.append(4)`, the change is reflected in both `list_a` and `list_b`. Encourage students to think about how they could gain the desired behaviour using the `.copy()` function (e.g. `list_b = list_a.copy()`).

**Question 2:** Code A will print `[1,2,3]` whilst Code B will print `[4,5,6]`. This is because, when we replace `a` with `[4,5,6]` we change the reference to point to a new location in memory, breaking the connection between `a` and `b`. However, when we change the elements in `a` individually, both `a` and `b` remain pointing to the same location in memory. Thus, when we print `b`, we get `[4,5,6]`.

```{python}
a = [1, 2, 3]
b = a
a = [4, 5, 6]
print(b)

a = [1, 2, 3]
b = a
a[0] = 4
a[1] = 5
a[2] = 6
print(b)
```

> **Demonstrator Notes:** See notes for Question 1.

**Question 3:** The variable names `xyz` and `xyzsquared` are pointing to the same array. When we squared `xyzsquared` we also squared `xyz`. We could have avoided this by making `xyzsquared` a seperate copy of `xyz` using the `list` constructor like so:

```{python}
xyz = [1,2,3]

# Make a list of x squared, y squared, z squared
xyzsquared = list(xyz) # The change was implemented here!
xyzsquared[0] = xyzsquared[0]**2
xyzsquared[1] = xyzsquared[1]**2
xyzsquared[2] = xyzsquared[2]**2

# Get x, y and z from xyz list
x = xyz[0]
y = xyz[1]
z = xyz[2]

# Get x squared, y squared and z squared from
# xyzsquared list
xsquared = xyzsquared[0]
ysquared = xyzsquared[1]
zsquared = xyzsquared[2]

print(x + y + z + xsquared + ysquared + zsquared)
```

> **Demonstrator Notes:** This question is designed to give students practice debugging code. Try to guide them to the solution where possible, rather than providing the full solution straight away.

**Question 4:** When you do `backup = list(grid)`, Python only makes a new outer list. The smaller lists inside `([1, 2], [3, 4], [5, 6])` are still the exact same objects that grid is using. Because of that, if you change one of the inner lists, the same change shows up `backup`.

 > **Demonstrator Notes:** The aim of this question is to understand why the unexpected behaviour occured. If students ask how to fix this, that’s a natural question, but at this stage they don’t yet have the tools to do so. For now, keep the focus on helping them understand why the behaviour occurs, instead of talking about fixes at this stage.

**Question 5:** The reasoning for this question is similar to that of Question 4, but noting that the three inner lists are all pointing to the same place in memory.

 > **Demonstrator Notes:** See the notes for Question 4.

