---
# title: 'Week 1: Introduction to Data Types'
jupyter: python3
---



# Exercises - Beginner: Basic Data Types

Welcome to the *Week 1 Beginner Python Notebook*. This notebook is designed for students who are just starting out with the Python programming language.  

Your task today is to read through the material carefully and complete the exercises provided at the end. These exercises are an important part of the learning process and will help you check your understanding.  

> **Important:** You have three options for today’s work:  [`Beginner`](./week_01_intro_to_data_types_beginner.qmd), [`Intermediate`](./week_01_intro_to_data_types_intermediate.qmd), or [`Advanced`](./week_01_intro_to_data_types_advanced.qmd). If you are new to Python, please choose this *Beginner* notebook. You will have plenty of opportunities later in the course to explore the other levels.  

In this notebook, you will be introduced to the *numeric*, *boolean*, and *string* Python data types. Gaining experience with these data types is essential, as they form the foundation for everything else you will learn in Python.  

Be sure to work through the examples and attempt all the exercises. They are designed to reinforce your learning and build your confidence.  

### Table of Contents

 - [Welcome Page](./week_01_home.qmd)
 - [**Beginner: Basic Data Types**](#Basic-Data-Types)
     - [What are Data Types?](#What-are-Data-Types?)
     - [Integers and floats](#Integers-and-floats)
     - [Strings](#Strings)
     - [Booleans](#Booleans)
     - [Casting Between Data Types](#Casting-Between-Data-Types)
     - [Exercises](#Exercises)
 - [Intermediate: Collections](./week_01_intro_to_data_types_intermediate.qmd)
 - [Advanced: Copying and References](./week_01_intro_to_data_types_advanced.qmd)
 - [Slides](./week_01_slides.qmd) ([Powerpoint](./Lecture1_Introduction_And_Data_Types.pptx))

## What are Data Types?

Writing code is a lot like writing a recipe for cooking. When writing a recipe, you might first list some ingredients, then give a careful sequence of steps, with the end result being some tasty and (hopefully!) digestible baked goods. Coding works the same way; we start with some inputs (the ingredients), ask the computer to perform a series of steps and produce some easy-to-digest result (the outputs).

In the same way that ingredients can be referred to as **objects** in the real-world, we refer to the data we use in coding as **objects** too. 


Furthermore, when cooking we might refer to objects by *types of food*. For instance, we may want to use 2 apples and an orange in a recipe, as opposed to 3 generic "food-objects". Similarly, when coding we refer to *types of data*, or **data types**. 

## Basic Data Types


In Python there are many different data types with some of the most commonly used built-in data types being:

 - integer and floating point scalars
 - boolean values
 - strings
 - tuples
 - lists
 - sets
 - dictionaries


 > **Note:** This list is by no means comprehensive. Other data types are also supported through common packages (e.g., `numpy`, `scipy`, `...`) and it is even possible to make your own custom datatypes! For now we will just focus on the built-in datatypes. However, packages such as `numpy` and `pandas` will be explored in later notebooks.

The "type" of a variable can be found using the `type()` function in python. Try changing and running the below code to see how this function is used. 

```{pyodide}
a = 1
b = 1.1e-6
c = True
d = 'word'
e = (2,3)
f = [1, 2, 3]
g = {'key1' : '9', 'key2': 20}

type(a)
```

In the above code, `a`, `b`, ..., `g` are variables. A variable is a named reference to a piece of data, created using the = (assignment) operator. The *type of a variable* describes the kind of data it stores. For example, `a` stores an integer (a whole number), so its type is `int`.

 > **Note:** Python allows for scientific notation for floats (decimal numbers). For example, in the above code `1.1e-6` means `1.1` times `10` to the minus `6`.

Values of variables can also be displayed with the `print()` function. If given many arguments, the print statement will print all of them. Try this below:

```{pyodide}
a = 0.01
b = 'strrring'
c = [1,2,3]

print(a)
print(a,b,c)
print(a,c)
```

By default, a Jupyter notebook will treat the last line of a code box as a print statement if it can.

```{pyodide}
# Here is some arbitrary code
d = 'another string'

# The below line will print a, as it is the last line in this box
a
```

## Integers and floats

When first getting to grips with python, you can think of integers as "whole numbers" and floats as "numbers including decimals". Integers are represented with the `int` datatype and floats are represented with the `float` datatype. Basic mathematical operations are available for `int` types and `float` types. Try a few below:

 > **Warning:** A common mistake made by new users of Python is to use `^` for exponentiation (e.g. $2^5$). In fact, in Python `^` represents the logical `XOR` operator and the `**` operator represents exponentiation. By performing your own research online, see if you can work out what the `XOR` function is doing here.

```{pyodide}
a = 3
b = 2

# Addition
print(a+b)

# Subtraction
print(a-b)

# Multiplication
print(a*b)

# Exponentiation
print(a**b)

# NOT EXPONENTIATION - ACTUALLY XOR
print(a^b)

# Division
print(a/b)

# Integer division (i.e. division with rounding down)
print(a//b)

# Modulo
print(a % b)
```

You can combine operations using round brackets, `(` and `)`, much in the same way you would in everyday math. For example:

```{pyodide}
print((a+b)/(b**2)+1/(3*a))
```

Often, you may hear it mentioned that Python allows for *arbitrary precision* integers. This means that Python can accurately manipulate very large numbers stored as `int`s. For example;

```{pyodide}
a = 174129409583938905209834890385935802
b = 417873297348327895798237589723987598

# Both a and b are ints
print(type(a))
print(type(b))

# You can check for yourself that this is correct!
print(a+b)
```

 > **Warning:** Although `int`s can store arbitrary precision whole numbers in Python, `float`s cannot!! Failure to realize this can result in all sorts of strange errors. For example, consider the below;

```{pyodide}
# Very big float
a = 1e30

# Lets have a look at `a`
print(a)
print(type(a))

# Now let's round `a` to the nearest whole number... this shouldn't change `a`... right?
b = round(a)

# Wrong... try repeating the above but with `a` as an integer (i.e. change the first line to `a=1000...00`)
print(b)
print(type(b))
```

> **Check your understanding:** What’s the difference between `/` and `//`? Why might `3 * 0.1` not equal `0.3` exactly in Python?

## Strings


In this section we are going to look more at strings. 

A string is a finite sequence of characters (e.g., letters, numbers, symbols and punctuation marks). In python, strings can be specified with either double of single quotes like so:

```{pyodide}
string1 = 'This is a string'
string2 = "This is also a string"
string3 = ""
string4 = 'string3 is also a string!'

print(string1)
print(string2)
print(string3)
print(string4)
```

An important characteristic of each string is its length, which is the number of characters in it. The length can be any natural number (i.e., zero or any positive integer). In python we can see the length of a string by using the `len()` function. In fact, this function can be used to assess the length of many different variable types such as lists, tuples, sets and so on (more on those later).

```{pyodide}
string1 = 'loooooong string'
string2 = 'shor'
string3 = ''


print(len(string1))
print(len(string2))
print(len(string3))
```

 > **Brief interlude:** In Python, you can add comments to your code using the `#` symbol. Comments are lines of text that are ignored when the code runs, but they play an important role in explaining what your code is doing. Writing clear and meaningful comments as you code is considered best practice. It helps others (and your future self) understand your logic and what you are trying to do. Below is a simple example that shows how to use comments in Python. Make sure you are comfortable with this, as commenting is a crucial habit for anyone working with code.

```{pyodide}
# The below line prints a string, this line is a comment
print('This statement is printed') # This is another comment

# The below line is not a comment as the # is contained within quotes
text = "# This is not a comment because it's inside quotes."
print(text)
```

> **Check your understanding:** What is the difference between `print(2 + 3)` and `print("2" + "3")`? What happens if you try `x = "hello" + 5`? Using the below box, write some code to answer these questions.

```{pyodide}
# Write your code here...
```

### String manipulation

Python has many useful tools for manipulating strings. One such function is the `format` function, which allows you to insert variables of different types into strings. Note that `x` in the below example does not need to be a string.

```{pyodide}
x = 8
y = 'John'
s = "{} is {} feet tall".format(y, x)
print(s)
```

Another useful tool is the concatenation operater; `+`. Concatenation in programming is another way for saying "join together". See the below for an example of how this is done.

```{pyodide}
a = 'string1'
b = 'string2'
c = a + ' ' + b

print(c)
```

In fact, the previous example could be done using concatenation instead of the `format` funtion. Note though that we must be careful and convert `x` from an integer to a string, using `str()`, in this case.

```{pyodide}
x = 8
y = 'John'

print(y + ' is ' + str(x) + ' feet tall')
```

Other useful functions for string manipulation include

 - `strip`; which, by default, removes any white space from the beginning and end of a string. However, you can also specify which characters you wish to remove.
 
 - `split`; splits a string by specified character (known as a seperator), and returns a list. By default, the separator is a space and this function splits a sentence into individual words.
 
 - `replace`; this returns a string with some specified value replaced with another specified value.
 
 - `upper`; this makes a string all uppercase.
 
 - `lower`; this makes a string all lowercase.
 
Several examples are given below. Please make sure you understand what each of these functions does before moving on to the next section. There are many other functions available and a good resource for learning about each individual function and trying them for yourself is the [w3 schools python reference site](https://www.w3schools.com/python/python_ref_string.asp).
 


```{pyodide}
# Demonstration of the strip function
print("Demonstration of strip function\n")


x = '    this is a string     '
print(x)
print(x.strip())
y = '...another string...'
print(y)
print(y.strip('.'))

# -------------------------------------------------------------------
# Demonstration of the split function
print("\nDemonstration of split function\n")


x = 'This is a string'
print(x)
print(x.split())
print(x.split('i'))

# -------------------------------------------------------------------
# Demonstration of the replace function
print("\nDemonstration of replace function\n")

x = 'I am not sure that I understand how the replace function works'
print(x)
y = x.replace('am not sure', 'am totally sure')
print(y)
z = y.replace('sure', 'sure, 100% sure in fact thanks to this (rather well put together) notebook,')
print(z)

# -------------------------------------------------------------------
# Demonstration of the upper and lower functions
print("\nDemonstration of upper and lower functions\n")

x = 'RaNDom CAseS'
print(x)
print(x.lower())
print(x.upper())
```

## Booleans

A boolean in python is a variable that can be either `True` or `False`. For instance:

```{pyodide}
# Create a boolean variable 
my_boolean = True
print(my_boolean)
```

Booleans arise in all sorts of situations. For example, consider the below code:

```{pyodide}
print(128 > 100)
```

You should see it print `True`, which makes sense as `128` is indeed larger than `100`. Try changing the numbers above; can you make this print `False`?

In this code, the expression `128 > 100` is a boolean statement. We can make this clearer like so:

```{pyodide}
my_boolean = 128 > 100
print(my_boolean)
```

The above code is identical to the previous, but we have now saved the `True/False` value as `my_boolean`.

Some common boolean operators include: 

 - `not`: This negates the value of a variable (i.e. turns `True` to `False` and `False` to `True`).
 - `and`: This is a logical `and`.
 - `or`: This is a logical `or`.
 - `is`: This checks whether two variables point to the same object in memory.
 - `==`: This checks whether two variables are equal in value (Note: This shouldn't be confused for the assigment operator; `=`).
 - `!=`: This checks whether two variables are not equal in value.
 
Boolean operators in Python are designed to be intuitive and as close to natural language as possible. The below code demonstrates how the boolean operations `and`, `or`, `==` and `!=` and `not` are used. Try changing the values of `a` and `b` to ensure you understand how these operations work.

```{pyodide}
a = True
b = False

print("not a: ", not a)
print("a and b: ", a and b)
print("a or b: ", a or b)
print("a==b: ", a==b)
print("a!=b: ", a!=b)

# Note: both c and b are treated as False, but they are not equal, see below;
c = {}
print("not c: ", not c)
print("not b: ", not b)
print("b==c: ", b==c)
```

Other common relational expressions which give `True/False` output include `<=`, `>=`, `<` and `>` for numeric datatypes (e.g. `int`s and `float`s) and `in` for collection datatypes (such as `list`s or `tuple`s, which we shall look at next). 

```{pyodide}
a = 1
b = 1.1

print("a>b:    ", a>b)
print("a<b:    ", a<b)
print("a>=b:   ", a>=b)
print("a<=b:   ", a<=b)

c = "Some string"
d = "om"
print("c in d: ", c in d)
print("d in c: ", d in c)

e = 1
f = 0.1
g = [1,2,3]
print("e in g: ", e in g)
print("f in g: ", f in g)
```

## Casting Between Data Types

In Python the data type of a variable is dynamic. This means that you do not need to specify the data type beforehand and that it can easily be changed. For example, try moving the type statement before and after the sum in the below block and see how the output is changed. Why does the output change?

```{pyodide}
a = 1
b = 1.1

print(type(a))

a = a+b
```

Several inbuilt functions are available for converting between types. The most commonly used of these are the `int`, `float` and `str` functions. Try these out below. **Caution**: Note how converting `z` back to a float does not give the original value `x`. Why do you think this is?

```{pyodide}
x = 1.1
y = str(x)
z = int(x)

print(x)
print(y)
print(z)

print(type(x))
print(type(y))
print(type(z))

print(x - float(z))
```

The act of converting one data type to another is often referred to as **casting**. For instance, in the above code, we *cast* `x` from a `float` to a `string` and then from a `string` to an `integer`.

 > **Check your Understanding:** What happens if you try `int("10.5")`? Why might you convert a number to a string using `str()`? Use the below code box to answer these questions.

```{pyodide}
# Write your answers here...
```

## Exercises

**Question 1:** Below are three variables `x`, `y` and `z`. By using the operators introduced in the `Booleans` section of this notebook, construct a boolean variable, `my_boolean` which is true if and only if $y$ lies strictly between $x^2$ and $z^3$. That is, `my_boolean` should be true if and only if either $x^2<y<z^3$ or $z^3<y<x^2$.

```{pyodide}
# Variables x, y and z
x = 1
y = 2
z = 1.26

my_boolean = # Write your code here...
```

**Question 2:** In the below code, we have two boolean variables; `is_raining` and `have_umbrella`. We will assume that these represent the sentences "It is raining outside" and "I have my umbrella with me", respectively. 

```{pyodide}
# Boolean variables
is_raining = True
have_umbrella = False
```

We will assume that you are going to get wet if and only if it is raining outside and you do not have your umbrella. Using logical operators (e.g. `and`, `or`, `not`...), make a new boolean variable that tells you if you are going to get wet.

```{pyodide}
# Boolean telling you if you are going to get rained on
got_soaked = # Write your code here...

print('Question: Will I get rained on?')
print('Answer: ' + str(got_soaked))
```

**Question 3:** In this question, we are interested in three boolean variables `A`, `B` and `C`. By performing your own research online, write down (on paper) a ["Truth Table"](https://en.wikipedia.org/wiki/Truth_table) for the expression `(A and B) or (not C)`. Your table should have the following columns:

| `A`     | `B`     | `C`     | `A and B` | `not C` | `(A and B) or (not C)` |
|---------|---------|---------|-----------|---------|------------------------|
| `True`  | `True`  | `True`  |           |         |                        | 
| `True`  | `True`  | `False` |           |         |                        | 
| `True`  | `False` | `True`  |           |         |                        | 
| `True`  | `False` | `False` |           |         |                        | 
| `False` | `True`  | `True`  |           |         |                        | 
| `False` | `True`  | `False` |           |         |                        | 
| `False` | `False` | `True`  |           |         |                        | 
| `False` | `False` | `False` |           |         |                        | 


In the following box, write some code which computes  `(A and B) or (not C)`. By changing the values of `A`, `B` and `C` check the correctness of your truth table.

```{pyodide}
# Boolean variables
A = True
B = False
C = True

# Compute new boolean
my_boolean = # Write your code here...
```

**Question 4:** Below are two variables representing the `width` and `height` of a rectangle. Write some code that computes the `area`, `perimeter` and length of the `diagonal` of the rectangle. Your code should print the results.

```{pyodide}
# Height and width variables
height = 10
width = 3

# Write your code here...
```

**Question 5:** An object dropped from a height satisfies the [SUVAT equations](https://www.pearsonschoolsandfecolleges.co.uk/asset-library/pdf/Secondary/science/edexcel-as-and-a-level-science/revise-edexcel-a-level-physics-revision-guide-samples.pdf). In particular, it satisfies the following equation:

$$v^2 = u^2 + 2as$$

where
 - $v$ is the final velocity,
 - $u$ is the initial velocity,
 - $a$ is the acceleration, equal to gravity in this case,
 - $s$ is the distance.
 
Given the object is at rest initially and it's final velocity is $10$ meters per second, write code to compute the distance it has fallen.

```{pyodide}
# Known variables
v = 10
u = # You must choose an appropriate value for this variable...
a = # You must choose an appropriate value for this variable...

# Compute s
s = # Write your code here.
```

**Question 6:** Building on your answer to Question 5, by researching the SUVAT equations and writing code below, compute the time in seconds that the object spends in freefall.

```{pyodide}
# Compute time using variables from Question 5
t = # Write your answer here...
```

**Question 7:** Without running code, predict the result of these, then check your answers in Python:

 - `(True and False) or True`
 - `not (False or False)`
 - `True or False and False`
 - `False ^ True`
 - `(True and not True) and (False or not False)`

```{pyodide}
# Write your code here...
```

*Hint: You may wish to look up `Truthy` and `Falsy` values.*

**Question 8:**  The below code takes two numbers, `x` and `y` and computes $z=\frac{x+y}{y^2}$. For instance, when we set $x=1$ and $y=5$ we get $z=0.24$.

```{pyodide}
# Set the values of x and y
x = 1
y = 5

# Add x and y together
z = float(x + y)/float(y)**2

# Print the result
print(z)
```

Suppose you were change the inputs, `x` and `y`, to 2 and 5. Work out by hand what you would expect $z$ to equal.

The below code is the same as the above but the values of `x` and `y` have been changed. This time, something has gone wrong! `z` does not give the expected value. Explain what has happened and how you would fix it.

```{pyodide}
# Set the values of x and y
x = '2'
y = '5'

# Add x and y together
z = float(x + y)/float(y)**2

# Print the result
print(z)
```

**Question 9:** Explain why the first code box below prints nothing but the second prints `True`.

```{pyodide}
three = 2 + 1
```

```{pyodide}
3 == 2 + 1
```

*Hint: Consider the below variable `z`. What is it's datatype?*

```{pyodide}
# Set the vairable z.
z = (3 == 2 + 1)

# Print it's type
# write your code here...
```

Given your answer to the above, you may expect the below code to also print `True`. 

```{pyodide}
0.3 == 0.1 + 0.2
```

However, it doesn't! Why do you think this is?

*Hint: Try printing (0.1 + 0.2) and 0.3 seperately. What do you notice?*

**Question 10:** In the code block below, you are given 12 strings:  

- one `start_string`  
- ten "helper" strings (`string1` to `string10`)  
- one `end_string`  

Your task is to transform the `start_string` into the `end_string` **using only**:  

- the `start_string`  
- the helper strings (`string1` … `string10`)  
- the `.replace()` function  

A complete solution can be given in **5 replacement steps**. We’ve given you the first step to get you started.  

*Hint: You might not need all ten helper strings.*

```{pyodide}
# The string we want to transform
start_string = 'Thas as te arang we want!'
print('Start:  ', start_string)

# Helper strings you can use for replacements
string1 = 'a'
string2 = 'st'
string3 = 'he a'
string4 = ' ge'
string5 = 'stri'
string6 = 'sts'
string7 = 'is'
string8 = 'ara'
string9 = 'gen'
string10 = 'e a'

# Step 1 (given as an example)
step1 = start_string.replace(string1,string2)
print('Step 1: ',step1)

# Step 2 (fill in the correct strings)
step2 = step1.replace(string_ , string_) # Fill in the underscores
print('Step 2: ', step2)

# Step 3–5 (repeat the process until you reach the final string)

print('...')


# Target string you should reach in 5 steps
end_string = 'This is the string we want!'
print('End:    ', end_string)
```

