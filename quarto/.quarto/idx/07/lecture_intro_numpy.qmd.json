{"title":"The `numpy` module","markdown":{"yaml":{"title":"The `numpy` module","jupyter":"python3"},"headingText":"What is the `numpy` module?","containsRefs":false,"markdown":"\n\n\n\n\nA collection of many functions is called a *module*. One of the most useful modules in Python is called *numpy* (**num**erical **Py**thon) – it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we've been focussing on so far but now comes as standard in most Python installations.\n\nThe `numpy` module builds on the core functionality but also adds additional features including:\n\n - It is *performant* which means it is well optimised\n - It offers additional *numerical computing tools*\n - It adds an additional object called an *n-dimensional array*\n\n### Numpy arrays vs lists\nOne thing we can use the `numpy` module for is to create a new object called a *numpy array*. This is another data structure, in addition to the in-built Python types we've been learning about, and is similiar to a list. \n\n<table style=\"font-size:0.95em;font-family:Arial, Helvetica, sans-serif;border-spacing:5px;border-collapse:initial\">\n    <tr>\n        <th style=\"background-color:lavender\">\n            Numpy arrays\n        <td style=\"width:50%;text-align:left;vertical-align:top\">\n            Numpy module (and arrays) are a Python extension (but often come as standard)<br>\n            <br>\n            Ordered<br>\n            <br>\n            Mutable<br>\n            <br>\n            Less flexible<br>\n             - One data type per array<br>\n            <br>\n            Allows implicit element-wise operations<br>\n            <br>\n            Generally quicker (optimised)<br>\n            More memory efficient\n        <th style=\"background-color:linen\">\n            Lists\n        <td style=\"width:50%;text-align:left;vertical-align:top\">\n            Lists are part of Python in-built functionality<br>\n            <br>\n            Ordered<br>\n            <br>\n            Mutable<br>\n            <br>\n            Very flexible<br>\n             - All types in any list<br>\n            <br>\n            Needs explicit element-wise operations<br>\n            <br>\n            Generally slower performance<br>\n            Less memory efficient\n    </tr>\n</table>\n\nWhen using these objects, `list` objects are highly flexible, in both content and shape whereas `numpy.array` objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n### Numpy arrays\n\n`numpy.array` objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\n\nTo use the `numpy` module we first need to *import* it.\n\n```{python}\nimport numpy as np\n```\n\nThe `as` part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case `np`. This is the convention most often used for the numpy module. `import` statements themselves are the way we access additional Python modules such as `numpy` or `matplotlib`. \n\nOne way to create a `numpy.array` is from a `list`:\n\n```{python}\nlist1 = [1.,1.,2.,3.,5.,8.]\narr1 = np.array(list1)\n```\n\nwhere we need the `np.` at the start of the function to tell python to access the `numpy` module.\n\nWe can also index and slice `numpy.arrays` in a similar way to other iterable objects (i.e. objects with length like `lists`):\n\n```{python}\nprint(arr1[0])\nprint(arr1[2:-1])\n```\n\nAnd a `numpy.array` has an additional properties (*attributes*) called *dtype* which tells us what is contained within the array and *shape* which tells us the dimensions of the array.\n\n```{python}\nprint(arr1.dtype)\nprint(arr1.shape)\n```\n\n### Element-wise operations\n\nThe `numpy` module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we've shown before one way to act on every item in a `list` using a `for` loop:\n\n```{python}\nlist2 = []\nfor item in list1:\n    list2.append(item*4)\nprint(list2)\n```\n\nThere is actually a short hand for creating a new list using a `for` loop for very simple operations called a *list comprehension*.\n\n```{python}\nlist2 = [item*4 for item in list1]\nprint(list2)\n```\n\nBut this is still more complex than using a `numpy.array`, where the same operation can be performed using an operator directly on the whole array:\n\n```{python}\narr2 = arr1*4\nprint(arr2)\n```\n\n### Operation speed\n\nFor large numbers of elements the time difference between operations using `lists` and `numpy.arrays` can start to be measurable. We can quickly check this my importing the `time` module:\n\n```{python}\nimport time\nnum_range = 100000\n```\n\n```{python}\ntime1 = time.time()\nlist_out = [item*4 for item in range(num_range)]\ntime2 = time.time()\n\nlist_time = time2-time1\n```\n\n```{python}\ntime1 = time.time()\narr_out = np.arange(num_range)*4\ntime2 = time.time()\n\narr_time = time2-time1\n```\n\nComparing the two operations we can see that performing this operation with the `list` takes longer than within a `numpy.array` (this is highly variable though):\n\n```{python}\nprint(f\"Array operation is {list_time/arr_time:.0f} times faster for {num_range:,} numbers\")\n```\n\nYou may recall, when we first introduced `list` and `dict` objects, we also mentioned other Python objects which were similar but with some differences in functionality (`tuple` and `set` objects).  In Python, as in many languages, there are often many tools which can be used to complete a task and it's up to you to choose the correct tool for the job. Overall, `list` objects may be more appropriate when you need to store a set of strings or if you don't know the number of elements in advance (appending to a `list` is faster than appending to an `numpy.array` due to the way the data is stored in memory). Whereas `numpy.array` objects would be more appropriate when performance is a factor or for simpler numerical operations.\n\n## Working with `numpy`\n\nTo use the `numpy` module we always need to start by using an import statement. In this case we import the `numpy` module and use the shorthand `np`:\n\n```{python}\nimport numpy as np\n```\n\n```{python}\narr1 = np.array([1.,1.,2.,3.,5.,8.])\n```\n\nWe've seen that we can apply operators directly to a `numpy.array`:\n\n```{python}\narr1*3/2 + 5\n```\n\nSimilarly you can use additional functions provided by the `numpy` module to do something to each element in the array. For example you can apply a square root:\n\n```{python}\nprint(np.sqrt(arr1))\n```\n\nOr perform a reductive operation such as calculating the mean of all the elements:\n\n```{python}\nprint(np.mean(arr1))\n```\n\nWe can also apply mathematical operations over the whole array. For instance we can look at the `np.cos` function which produces applies the cosine function element-wise:\n\n```{python}\nnp.cos?\n```\n\nThe help states that this wants an *array-like* object and wants the input in radians. We can write this as:\n\n```{python}\nprint(np.cos(arr1))\n```\n\nIf we look at `arr1` we can see that this has not been updated by the application of these operations - when using this functionality a copy of the array is returned which you can choose to re-assign to the original variable name or create a new variable:\n\n```{python}\nprint(arr1)\narr2 = arr1*3/2 + 5\nprint(arr2)\n```\n\n## Element-wise operations on 1D arrays\n\nElement-wise operations in numpy allow you to perform arithmetic or mathematical functions on each corresponding element of arrays. For example, if you have two arrays of the same length, `arr1` and `arr2`, you can add them directly: `arr1 + arr2`. This will produce a new array where each element is the sum of the elements at the same position in the original arrays. Similarly, you can use other operators (`-`, `*`, `/`) or numpy functions (`np.sqrt(arr1)`, `np.cos(arr1)`) to apply operations to each element individually. The arrays must have compatible shapes for these operations.\n\n```{python}\n# Element-wise addition of arr1 and arr2\nadded = arr1 + arr2\nprint(added)\n# Element-wise subtraction of arr1 and arr2\nsubtracted = arr1 - arr2\nprint(subtracted)\n```\n\n```{python}\n# Element-wise multiplication and division of arr1 and arr2\nmultiplied = arr1 * arr2\ndivided = arr1 / arr2\n\nprint(\"Element-wise multiplication:\", multiplied)\nprint(\"Element-wise division:\", divided)\n```\n\nWhen 1D arrays have different lengths, you need to be careful about the operations you perform. **Element-wise operations**: Operations such as `arr1 + arr3` or `arr1 * arr3` require arrays to have the same length or compatible shapes. If the lengths differ, numpy will raise a `ValueError` due to shape mismatch.\n\n```{python}\n# This will raise a ValueError because arr1 and arr3 have different lengths\nresult = arr1 + arr3\n```\n\n## Basic operations on 1D arrays\n\nSumming all elements in a 1D numpy array can be done with `np.sum(arr1)`.\n\nFor cumulative summing, use `np.cumsum(arr1)`, which returns an array where each element is the sum of all previous elements.\n\n\nSorting is performed with `np.sort(arr1)`, which returns a sorted copy of the array.\n \nTo concatenate two arrays, use `np.concatenate([arr1, arr2])`. This joins the arrays end-to-end, creating a new array containing all elements from both arrays in order. Concatenation is useful for combining datasets or extending arrays.\n  \nTo find unique elements, use `np.unique(arr1)`, which returns an array of the distinct values in `arr1`. These operations are efficient and commonly used for data analysis.\n\n```{python}\n# Summing all elements in arr1\ntotal_sum = np.sum(arr1)\nprint(\"Sum of arr1:\", total_sum)\n\n# Cumulative summing of arr1\ncumulative_sum = np.cumsum(arr1)\nprint(\"Cumulative sum of arr1:\", cumulative_sum)\n\n# Sorting arr1\nsorted_arr = np.sort(arr1)\nprint(\"Sorted arr1:\", sorted_arr)\n\n# Combine arr1 and arr2 into a single array\ncombined = np.concatenate([arr1, arr2])\nprint(\"Combined array:\", combined)\n\n# Finding unique elements in combined\nunique_elements = np.unique(combined)\nprint(\"Unique elements in combined:\", unique_elements)\n```\n\n\n","srcMarkdownNoYaml":"\n\n\n\n## What is the `numpy` module?\n\nA collection of many functions is called a *module*. One of the most useful modules in Python is called *numpy* (**num**erical **Py**thon) – it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we've been focussing on so far but now comes as standard in most Python installations.\n\nThe `numpy` module builds on the core functionality but also adds additional features including:\n\n - It is *performant* which means it is well optimised\n - It offers additional *numerical computing tools*\n - It adds an additional object called an *n-dimensional array*\n\n### Numpy arrays vs lists\nOne thing we can use the `numpy` module for is to create a new object called a *numpy array*. This is another data structure, in addition to the in-built Python types we've been learning about, and is similiar to a list. \n\n<table style=\"font-size:0.95em;font-family:Arial, Helvetica, sans-serif;border-spacing:5px;border-collapse:initial\">\n    <tr>\n        <th style=\"background-color:lavender\">\n            Numpy arrays\n        <td style=\"width:50%;text-align:left;vertical-align:top\">\n            Numpy module (and arrays) are a Python extension (but often come as standard)<br>\n            <br>\n            Ordered<br>\n            <br>\n            Mutable<br>\n            <br>\n            Less flexible<br>\n             - One data type per array<br>\n            <br>\n            Allows implicit element-wise operations<br>\n            <br>\n            Generally quicker (optimised)<br>\n            More memory efficient\n        <th style=\"background-color:linen\">\n            Lists\n        <td style=\"width:50%;text-align:left;vertical-align:top\">\n            Lists are part of Python in-built functionality<br>\n            <br>\n            Ordered<br>\n            <br>\n            Mutable<br>\n            <br>\n            Very flexible<br>\n             - All types in any list<br>\n            <br>\n            Needs explicit element-wise operations<br>\n            <br>\n            Generally slower performance<br>\n            Less memory efficient\n    </tr>\n</table>\n\nWhen using these objects, `list` objects are highly flexible, in both content and shape whereas `numpy.array` objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n### Numpy arrays\n\n`numpy.array` objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\n\nTo use the `numpy` module we first need to *import* it.\n\n```{python}\nimport numpy as np\n```\n\nThe `as` part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case `np`. This is the convention most often used for the numpy module. `import` statements themselves are the way we access additional Python modules such as `numpy` or `matplotlib`. \n\nOne way to create a `numpy.array` is from a `list`:\n\n```{python}\nlist1 = [1.,1.,2.,3.,5.,8.]\narr1 = np.array(list1)\n```\n\nwhere we need the `np.` at the start of the function to tell python to access the `numpy` module.\n\nWe can also index and slice `numpy.arrays` in a similar way to other iterable objects (i.e. objects with length like `lists`):\n\n```{python}\nprint(arr1[0])\nprint(arr1[2:-1])\n```\n\nAnd a `numpy.array` has an additional properties (*attributes*) called *dtype* which tells us what is contained within the array and *shape* which tells us the dimensions of the array.\n\n```{python}\nprint(arr1.dtype)\nprint(arr1.shape)\n```\n\n### Element-wise operations\n\nThe `numpy` module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we've shown before one way to act on every item in a `list` using a `for` loop:\n\n```{python}\nlist2 = []\nfor item in list1:\n    list2.append(item*4)\nprint(list2)\n```\n\nThere is actually a short hand for creating a new list using a `for` loop for very simple operations called a *list comprehension*.\n\n```{python}\nlist2 = [item*4 for item in list1]\nprint(list2)\n```\n\nBut this is still more complex than using a `numpy.array`, where the same operation can be performed using an operator directly on the whole array:\n\n```{python}\narr2 = arr1*4\nprint(arr2)\n```\n\n### Operation speed\n\nFor large numbers of elements the time difference between operations using `lists` and `numpy.arrays` can start to be measurable. We can quickly check this my importing the `time` module:\n\n```{python}\nimport time\nnum_range = 100000\n```\n\n```{python}\ntime1 = time.time()\nlist_out = [item*4 for item in range(num_range)]\ntime2 = time.time()\n\nlist_time = time2-time1\n```\n\n```{python}\ntime1 = time.time()\narr_out = np.arange(num_range)*4\ntime2 = time.time()\n\narr_time = time2-time1\n```\n\nComparing the two operations we can see that performing this operation with the `list` takes longer than within a `numpy.array` (this is highly variable though):\n\n```{python}\nprint(f\"Array operation is {list_time/arr_time:.0f} times faster for {num_range:,} numbers\")\n```\n\nYou may recall, when we first introduced `list` and `dict` objects, we also mentioned other Python objects which were similar but with some differences in functionality (`tuple` and `set` objects).  In Python, as in many languages, there are often many tools which can be used to complete a task and it's up to you to choose the correct tool for the job. Overall, `list` objects may be more appropriate when you need to store a set of strings or if you don't know the number of elements in advance (appending to a `list` is faster than appending to an `numpy.array` due to the way the data is stored in memory). Whereas `numpy.array` objects would be more appropriate when performance is a factor or for simpler numerical operations.\n\n## Working with `numpy`\n\nTo use the `numpy` module we always need to start by using an import statement. In this case we import the `numpy` module and use the shorthand `np`:\n\n```{python}\nimport numpy as np\n```\n\n```{python}\narr1 = np.array([1.,1.,2.,3.,5.,8.])\n```\n\nWe've seen that we can apply operators directly to a `numpy.array`:\n\n```{python}\narr1*3/2 + 5\n```\n\nSimilarly you can use additional functions provided by the `numpy` module to do something to each element in the array. For example you can apply a square root:\n\n```{python}\nprint(np.sqrt(arr1))\n```\n\nOr perform a reductive operation such as calculating the mean of all the elements:\n\n```{python}\nprint(np.mean(arr1))\n```\n\nWe can also apply mathematical operations over the whole array. For instance we can look at the `np.cos` function which produces applies the cosine function element-wise:\n\n```{python}\nnp.cos?\n```\n\nThe help states that this wants an *array-like* object and wants the input in radians. We can write this as:\n\n```{python}\nprint(np.cos(arr1))\n```\n\nIf we look at `arr1` we can see that this has not been updated by the application of these operations - when using this functionality a copy of the array is returned which you can choose to re-assign to the original variable name or create a new variable:\n\n```{python}\nprint(arr1)\narr2 = arr1*3/2 + 5\nprint(arr2)\n```\n\n## Element-wise operations on 1D arrays\n\nElement-wise operations in numpy allow you to perform arithmetic or mathematical functions on each corresponding element of arrays. For example, if you have two arrays of the same length, `arr1` and `arr2`, you can add them directly: `arr1 + arr2`. This will produce a new array where each element is the sum of the elements at the same position in the original arrays. Similarly, you can use other operators (`-`, `*`, `/`) or numpy functions (`np.sqrt(arr1)`, `np.cos(arr1)`) to apply operations to each element individually. The arrays must have compatible shapes for these operations.\n\n```{python}\n# Element-wise addition of arr1 and arr2\nadded = arr1 + arr2\nprint(added)\n# Element-wise subtraction of arr1 and arr2\nsubtracted = arr1 - arr2\nprint(subtracted)\n```\n\n```{python}\n# Element-wise multiplication and division of arr1 and arr2\nmultiplied = arr1 * arr2\ndivided = arr1 / arr2\n\nprint(\"Element-wise multiplication:\", multiplied)\nprint(\"Element-wise division:\", divided)\n```\n\nWhen 1D arrays have different lengths, you need to be careful about the operations you perform. **Element-wise operations**: Operations such as `arr1 + arr3` or `arr1 * arr3` require arrays to have the same length or compatible shapes. If the lengths differ, numpy will raise a `ValueError` due to shape mismatch.\n\n```{python}\n# This will raise a ValueError because arr1 and arr3 have different lengths\nresult = arr1 + arr3\n```\n\n## Basic operations on 1D arrays\n\nSumming all elements in a 1D numpy array can be done with `np.sum(arr1)`.\n\nFor cumulative summing, use `np.cumsum(arr1)`, which returns an array where each element is the sum of all previous elements.\n\n\nSorting is performed with `np.sort(arr1)`, which returns a sorted copy of the array.\n \nTo concatenate two arrays, use `np.concatenate([arr1, arr2])`. This joins the arrays end-to-end, creating a new array containing all elements from both arrays in order. Concatenation is useful for combining datasets or extending arrays.\n  \nTo find unique elements, use `np.unique(arr1)`, which returns an array of the distinct values in `arr1`. These operations are efficient and commonly used for data analysis.\n\n```{python}\n# Summing all elements in arr1\ntotal_sum = np.sum(arr1)\nprint(\"Sum of arr1:\", total_sum)\n\n# Cumulative summing of arr1\ncumulative_sum = np.cumsum(arr1)\nprint(\"Cumulative sum of arr1:\", cumulative_sum)\n\n# Sorting arr1\nsorted_arr = np.sort(arr1)\nprint(\"Sorted arr1:\", sorted_arr)\n\n# Combine arr1 and arr2 into a single array\ncombined = np.concatenate([arr1, arr2])\nprint(\"Combined array:\", combined)\n\n# Finding unique elements in combined\nunique_elements = np.unique(combined)\nprint(\"Unique elements in combined:\", unique_elements)\n```\n\n\n"},"formats":{"live-html":{"identifier":{"display-name":"HTML","target-format":"live-html","base-format":"html","extension-name":"live"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":true,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["/Users/ft14968/Repos/intro-coding-data-analysis/quarto/_extensions/r-wasm/live/live.lua"],"include-in-header":{"text":"<meta name=\"robots\" content=\"noindex, nofollow\">\n"},"css":["../styles.css"],"toc":true,"toc-depth":3,"highlight-style":"github","number-sections":false,"output-file":"lecture_intro_numpy.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","ojs-engine":true,"revealjs-plugins":[],"theme":"cosmo","toc-location":"right","code-copy":true,"grid":{"sidebar-width":"350px"},"title":"The `numpy` module","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["live-html"]}