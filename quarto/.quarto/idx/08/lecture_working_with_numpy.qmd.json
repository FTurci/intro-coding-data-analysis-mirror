{"title":"Working with Arrays in NumPy: Indexing and Random Data Generation","markdown":{"yaml":{"title":"Working with Arrays in NumPy: Indexing and Random Data Generation","jupyter":"python3"},"headingText":"Array indexing, slicing, views and copies","containsRefs":false,"markdown":"\n\n\n\nNumPy is a powerful library for numerical computing in Python, providing efficient multi-dimensional array operations and a wide range of mathematical functions. With NumPy, you can perform fast element-wise computations, advanced indexing, slicing, and generate random data for simulations and analysis.\n\nThis notebook illustrates array indexing, boolean arrays, generating sequences using `np.arange` and `np.linspace`, and generating random samples with NumPy's random number generator.\n\n\n\nIndexing in NumPy allows you to access and modify individual elements or groups of elements within an array. You can use integer indices, slices, and even boolean arrays to select data efficiently. For example:\n\n- **Integer Indexing:** Select a single element by its position.\n- **Slicing:** Extract a range of elements.\n- **Boolean Indexing:** Filter elements based on a condition.\n\n### Integer indexing\n\nWe have already seen that the lements of an array are idnexed similarly to lists. The syntax simply requires you to enter the integer index of the element you want to access. For example, if you have an array `arr`, you can access the element at index 1 using `arr[1]`. You can also slice arrays using the same syntax as lists, such as `arr[1:4]` to get elements from index 1 to 3.\n\n```{python}\nimport numpy as np\n\narr = np.array([10, 20, 30, 40, 50])\nprint(\"Array:\", arr)\nprint(\"Element at index 1:\", arr[1])\n```\n\n### Slicing\n\n**Slicing** allows you to extract a portion of an array by specifying a start index, an end index, and an optional step. The syntax is similar to that used for lists in Python. For example, `arr[1:4]` retrieves elements from index 1 to 3 (the end index is exclusive).\n\n\n```{python}\n\nprint(\"Slice from index 1 to 3:\", arr[1:4])\n```\n\n### Advanced Slicing Techniques\n\nNumPy slicing can be extended beyond basic start and end indices:\n\n- **Step Size:** Use a third parameter to specify the step, e.g., `arr[::2]` selects every other element.\n- **Negative Indices:** Negative values index from the end, e.g., `arr[-3:]` gets the last three elements.\n- **Reverse Slicing:** Use a negative step to reverse an array, e.g., `arr[::-1]`.\n\n\n```{python}\n# Step size: select every other element\nprint(\"Every other element:\", arr[::2])\n\n# Negative indices: last three elements\nprint(\"Last three elements:\", arr[-3:])\n\n# Reverse slicing: reverse the array\nprint(\"Reversed array:\", arr[::-1])\n\n# Selecting all elements\nprint(\"All elements:\", arr[:])\n```\n\n\nSlicing creates **views**, not copies, so modifying a slice affects the original array. Use `arr.copy()` to create a copy if needed.\n\nA **view** is a new array object that looks at the same data as the original array. Changes made to a view will affect the original array, since they share the same underlying data. For example, `arr[1:4]` returns a view of `arr`, not a separate copy.\n\n```{python}\n# Demonstrating that slicing creates a view, not a copy\nslice_view = arr[2:5]\nprint(\"Original array before modification:\", arr)\nslice_view[0] = 99  # Modify the view\nprint(\"Modified slice_view:\", slice_view)\nprint(\"Original array after modification:\", arr)  # arr is also changed\n```\n\nSlices can be programmaticaly generated using the `slice` function, which allows you to create a slice object that can be reused. For example, `s = slice(1, 4)` creates a slice object that can be used as `arr[s]` to get the same result as `arr[1:4]`.\n\n```{python}\n# Creating an independent copy of a slice\nexample_slice = slice(1, 4, 2)\nprint(\"Using slice(1, 4, 2) on arr:\", arr[example_slice])\n```\n\nTo create an **independent copy** of an array (rather than a view), use the `copy()` method. For example, `arr_copy = arr[1:4].copy()` creates a new array with its own data, so changes to `arr_copy` will not affect the original `arr`. This is useful when you want to modify a subset of an array without altering the original data.\n\n```{python}\n# Creating an independent copy of a slice\narr_copy = arr[2:5].copy()\narr_copy[0] = 100  # Modify the copy\nprint(\"arr_copy:\", arr_copy)\nprint(\"Original arr:\", arr)  # arr remains unchanged\n```\n\n### Boolean Indexing\n\nBoolean indexing allows you to select elements from an array based on a condition. When you apply a condition to a NumPy array, it returns a **boolean** (an array that contains only True/False values ) array indicating which elements satisfy the condition. You can then use this boolean array to filter the original array, extracting only the elements that meet the criteria. This technique is powerful for data selection and analysis.\n\n```{python}\narr = np.array([1, 2, 3, 4, 5, 6])\nthreshold = 3\nbool_mask = arr > threshold\nprint(\"Original array:\", arr)\nprint(f\"Boolean mask for threshold {threshold}:\", bool_mask)\nprint(\"Filtered values:\", arr[bool_mask])\n```\n\n### Using `np.where` for conditional selection\n\nThe `np.where` function in NumPy is a powerful tool for conditional selection and element-wise operations. It allows you to choose values from arrays based on a condition, returning indices or constructing new arrays.\n\n- **Basic usage:**  \n    `np.where(condition)` returns the indices where the condition is `True`.\n\n\n\n```{python}\nnp.where(arr > threshold)\n```\n\n`np.where(arr > threshold)` returns a tuple because, for 1D arrays, it provides the indices where the condition is `True`. In NumPy, the output is always a tuple of arrays—one for each dimension of the input array. For a 1D array, it's a single-element tuple containing the indices. For higher dimensions, it returns a tuple with arrays for each axis. This consistent tuple format makes it easy to handle multi-dimensional indexing.\n\nSo, for 1D arrays as the ones considered up to now, we should get the indices by extracting the first element of the tuple returned by `np.where`\n\n```{python}\nnp.where(arr > threshold)[0]\n```\n\n\n- **Element-wise selection:**  \n    `np.where(condition, x, y)` returns elements from `x` where the condition is `True`, and from `y` where it is `False`. Here the result is an array of the same shape as `x` and `y`, containing values from `x` where the condition is met, and from `y` otherwise. This is useful for creating new arrays based on conditions without using loops.\n\n\n\n\n```{python}\na  = np.array([1, 2, 3, 4, 5])\nb = np.array([-1,-2, -3, - 4, -5])\nc = np.array([10, 20, 30, 40, 50])\n\nresult = np.where(a > 2, x, y)\nprint(result)\n```\n\n\n\nThis creates a new array where each element is `100` if the condition is met, otherwise `0`.\n\n## Function to generate numerical arrays\n\nNumPy provides automated methods for generating numerical sequences, which are essential for simulations, sampling, and creating structured data. \n\n### Generating sequences\n\nThe two most used functions for generating  ordered numerical sequences in NumPy are `np.arange` and `np.linspace`.\n\n- **`np.arange(start, stop, step)`**: Generates an array of evenly spaced values within a specified range. The `start` value is inclusive, while the `stop` value is exclusive. The `step` parameter defines the spacing between values.\n  \n  Example: `np.arange(0, 10, 2)` produces `[0, 2, 4, 6, 8]`.\n\n- **`np.linspace(start, stop, num)`**: Creates an array of `num` evenly spaced values between `start` and `stop`, inclusive. This is useful for generating a specific number of points in a range.\n\n\n\n\n```{python}\nprint(\"np.arange(0, 10, 2):\", np.arange(0, 10, 2))\nprint(\"np.linspace(0, 1, 5):\", np.linspace(0, 1, 5))\n```\n\nMost importantly, these functions can be used to create arrays of any kinds of numerical data, including integers and floating-point numbers. \n\n```{python}\n# integers\nnp.arange(0, 10, 2)  # Creates an array with values from 0 to 10 with a step of 2\n```\n\n```{python}\n# floating-point numbers\nnp.arange(0.0, 1.0, 0.2)  # Creates an array with values from 0.0 to 1.0 with a step of 0.2\n```\n\n```{python}\n# complex numbers, by using the data type specifier `dtype=complex`\nnp.arange(0, 10, 2, dtype=complex)  # Creates an array with complex numbers from 0 to 10 with a step of 2\n```\n\nNotice that `linspace` is useful when we know the start and end value and the specific number of points we want to generate, while `arange` is useful when we know the start and end value and the step size between the points.\n\n## Generating filled arrays\n\nNumPy provides functions to create arrays filled with specific values, such as zeros, ones, or a constant value. These functions are useful for initializing arrays before performing computations.\n\nThe main functions for generating filled arrays are:\n- **`np.zeros(shape)`**: Creates an array filled with zeros, where `shape` specifies the dimensions of the array.\n- **`np.ones(shape)`**: Creates an array filled with ones.\n- **`np.full(shape, fill_value)`**: Creates an array filled with a specified value (`fill_value`), where `shape` defines the dimensions of the array.   \n- **`np.empty(shape)`**: Creates an uninitialized array with the specified shape. The values in this array are not set to any particular value, so they may contain random data.\n\nThere are also functions that create arrays with the same shape and type as an existing array, which can be useful for initializing arrays that will be used in computations:\n\n- **`np.zeros_like(array)`**: Creates an array of zeros with the same shape and type as the input array.\n- **`np.ones_like(array)`**: Creates an array of ones with the same shape and type as the input array.\n- **`np.full_like(array, fill_value)`**: Creates an array filled with a specified value, with the same shape and type as the input array.\n\n```{python}\n# Examples using filled array generation functions\n\n# Create a 1D array of zeros with the same shape as arr\nzeros_arr = np.zeros_like(arr)\nprint(\"Zeros array:\", zeros_arr)\n\n# Create a 1D array of ones with the same shape as arr\nones_arr = np.ones_like(arr)\nprint(\"Ones array:\", ones_arr)\n\n# Create a 1D array filled with the value 7, same shape as arr\nfull_arr = np.full_like(arr, 7)\nprint(\"Full array (filled with 7):\", full_arr)\n\n# Create an uninitialized array (values may be random, or zeros)\nempty_2d = np.empty(5)\nprint(\"An empty array:\\n\", empty_2d)\n```\n\n## Random Data Generation\n\nRandom data generation is essential for simulations, statistical modeling, and testing algorithms. \n\nFor example, you might want to generate random samples from a normal distribution to simulate real-world data or create random datasets for testing purposes. Or you may want to simulate the effect of measurement errors in your data analysis. Or you may want to sub-sample a large dataset randomly to take a representative sample without bias.\n\nTo do all this, one needs methods to sample numbers that possess the statistical properties of the desired distribution, such as uniform, normal, or binomial distributions.\n\nStrictly speaking (classical) computers are **deterministic machines**, meaning they follow a set of rules and produce the same output for the same input every time. We have therefore to use algorithms to produce sequences of numbers that mimic the properties of random numbers.\n\nThese are called **pseudo-random numbers**. Pseudo-random number generators (PRNGs) use algorithms to produce sequences of numbers that appear random but are actually deterministic.\n\nA simple and classic example of a pseudo-random number generator is the **Linear Congruential Generator (LCG)**. The LCG produces a sequence of numbers using the recurrence relation:\n\n$$x_{n+1} = (a \\times  x_{n} + c)\\,\\mathrm{mod}\\, m$$\n\nwhere  \n- $x_n$ is the current value,  \n- $a$ is the multiplier,  \n- $c$ is the increment,  \n- $m$ is the modulus.\n\nIn *vanilla* Python this looks like the following custom function\n\n```{python}\ndef lcg(seed, a=1664525, c=1013904223, m=2**32, size=10):\n    nums = []\n    x = seed\n    for _ in range(size):\n        x = (a * x + c) % m\n        nums.append(x)\n    return nums\n```\n\n```{python}\n# Example usage:\nlcg_sequence = lcg(seed=42, size=5)\nprint(\"LCG sequence:\", lcg_sequence)\n```\n\n\n\n\nThis will generate a sequence of pseudo-random integers. The choice of parameters (`a`, `c`, `m`) affects the quality and period of the generator.\n\n```{python}\n# Example of LCG with a short period by choosing small modulus\nshort_period_seq = lcg(seed=1,  a=5, c=3, m=16, size=20)\nprint(\"LCG sequence with short period:\", short_period_seq)\n```\n\nThe **seed** is crucial: it is the initial value that starts the algorithm to determin the subsequent values in the sequence. By setting the seed, you can ensure that the sequence is **reproducible**, meaning that running the same code with the same seed will produce the same sequence of numbers every time.\n\nIn numpy, we do not need to implement our own LCG, as it provides a built-in random number generator that is based on the Mersenne Twister algorithm, which is a widely used and efficient pseudo-random numbwer generator.\n\nWhat we do instead is to use the `numpy.random` **sub-module**, which provides a wide range of functions for generating random numbers from various distributions, including uniform, normal, and binomial distributions.\n\n\nThe standard way to to use it is the following:\n\n- first, one initialises a new kind of object called a **random number generator** (RNG) using `np.random.default_rng()`.  This is a `numpy` object capable of generating random numbers from various distributions. It allows us in particular to set the **seed** and therefore ensure reproducibility.\n\n```{python}\nrng = np.random.default_rng(seed=123)\n```\n\nWe can do this at any point in our code, but it is a good practice to do it at the beginning of our script or notebook, so that we can ensure that all random numbers generated in the script are reproducible. Putting the generator elsewhere (for example, inside a function) could lead to unexpected results, as the generator would be re-initialised each time the function is called.\n\nOnce we have a generator we can access any of its method to sample numbers from various distributions\n\nFor example:\n\n\n\n### Integers\n\nTo sample uniformly distributed integers, we can use the `integers` method of the generator. This method allows us to specify a range and the number of integers to generate.\n\n```{python}\nrng.integers(0, 100, size=5)  # 5 random integers between 0 and 100\n```\n\n### [0-1) uniform floats\n\nTo sample uniformly distributed floats between 0 and 1, we can use the `random` method of the generator. This method generates random floats in the range [0.0, 1.0) (which means 0 included and 1 excluded).\n\n```{python}\nrng.random(1000)\n```\n\nAlternatively, we can use the `uniform` method to sample uniformly distributed floats in a specified range. This method allows us to specify the lower and upper bounds of the range, as well as the number of samples to generate.\n\n```{python}\nrng.uniform(0,1,1000)\n```\n\n### Normal distribution\n\nTo sample from a normal distribution, we can use the `normal` method of the generator. This method allows us to specify the mean and standard deviation of the distribution, as well as the number of samples to generate. The generated samples will follow a normal (Gaussian) distribution with the specified parameters.\n\n```{python}\nnormal_rv = rng.normal(loc=0, scale=4, size=10000)  # 10000 samples from a normal distribution with mean 0 and std dev 1\n```\n\n```{python}\n# check that the sample mean and standard deviation are close to the specified values \n\nnormal_rv.mean()\n```\n\n```{python}\nnormal_rv.std()\n```\n\n## Sampling a siingle value \n\nIf we only want to sample a single  value, we can simply not specify the `size` parameter, or set it to `1`. This will return a single value sampled from the specified distribution.\n\n```{python}\nrng.integers(0,100) # run this multiple times to observe the random nature of the output\n```\n\nHowever, this can sometimes be more computationally costly than generating a larger sample and then selecting a single value from it. \n\n```{python}\nimport time\n\n# Timing a for loop that generates a random integer in each iteration\nstart_time = time.time()\nsteps = 1000000\nfor _ in range(steps):\n    # use a random value\n    val = 2*rng.integers(0, 100)\nelapsed_no_prealloc = time.time() - start_time\n\n# Timing a for loop that uses preallocated random integers\npreallocated = rng.integers(0, 100, size=steps)\nstart_time = time.time()\nfor u in preallocated:\n    val = 2*u  # use the preallocated value\nelapsed_prealloc = time.time() - start_time\n\nprint(f\"Time without preallocation: {elapsed_no_prealloc:.4f} seconds\")\nprint(f\"Time with preallocation: {elapsed_prealloc:.4f} seconds\")\n```\n\nThis is a good example of the tradeoff between memory usage and computational efficiency: in modern machines, memory is quite cheap, so it is often more efficient to preallocate a larger array and then sample from it, rather than generating a single value at a time.\n\nA good size for preallocated numbers depends on your use case and available memory. Typical choices are:\n\n- Small tasks: `100` to `1,000` elements\n- Medium tasks: `10,000` to `100,000` elements\n- Large tasks: `1,000,000` or more elements\n\nFor most data analysis or simulation tasks, starting with `100,000` elements is practical and efficient. Always ensure the size fits within your system's memory limits.\n\n\n\n","srcMarkdownNoYaml":"\n\n\n\nNumPy is a powerful library for numerical computing in Python, providing efficient multi-dimensional array operations and a wide range of mathematical functions. With NumPy, you can perform fast element-wise computations, advanced indexing, slicing, and generate random data for simulations and analysis.\n\nThis notebook illustrates array indexing, boolean arrays, generating sequences using `np.arange` and `np.linspace`, and generating random samples with NumPy's random number generator.\n\n\n## Array indexing, slicing, views and copies\n\nIndexing in NumPy allows you to access and modify individual elements or groups of elements within an array. You can use integer indices, slices, and even boolean arrays to select data efficiently. For example:\n\n- **Integer Indexing:** Select a single element by its position.\n- **Slicing:** Extract a range of elements.\n- **Boolean Indexing:** Filter elements based on a condition.\n\n### Integer indexing\n\nWe have already seen that the lements of an array are idnexed similarly to lists. The syntax simply requires you to enter the integer index of the element you want to access. For example, if you have an array `arr`, you can access the element at index 1 using `arr[1]`. You can also slice arrays using the same syntax as lists, such as `arr[1:4]` to get elements from index 1 to 3.\n\n```{python}\nimport numpy as np\n\narr = np.array([10, 20, 30, 40, 50])\nprint(\"Array:\", arr)\nprint(\"Element at index 1:\", arr[1])\n```\n\n### Slicing\n\n**Slicing** allows you to extract a portion of an array by specifying a start index, an end index, and an optional step. The syntax is similar to that used for lists in Python. For example, `arr[1:4]` retrieves elements from index 1 to 3 (the end index is exclusive).\n\n\n```{python}\n\nprint(\"Slice from index 1 to 3:\", arr[1:4])\n```\n\n### Advanced Slicing Techniques\n\nNumPy slicing can be extended beyond basic start and end indices:\n\n- **Step Size:** Use a third parameter to specify the step, e.g., `arr[::2]` selects every other element.\n- **Negative Indices:** Negative values index from the end, e.g., `arr[-3:]` gets the last three elements.\n- **Reverse Slicing:** Use a negative step to reverse an array, e.g., `arr[::-1]`.\n\n\n```{python}\n# Step size: select every other element\nprint(\"Every other element:\", arr[::2])\n\n# Negative indices: last three elements\nprint(\"Last three elements:\", arr[-3:])\n\n# Reverse slicing: reverse the array\nprint(\"Reversed array:\", arr[::-1])\n\n# Selecting all elements\nprint(\"All elements:\", arr[:])\n```\n\n\nSlicing creates **views**, not copies, so modifying a slice affects the original array. Use `arr.copy()` to create a copy if needed.\n\nA **view** is a new array object that looks at the same data as the original array. Changes made to a view will affect the original array, since they share the same underlying data. For example, `arr[1:4]` returns a view of `arr`, not a separate copy.\n\n```{python}\n# Demonstrating that slicing creates a view, not a copy\nslice_view = arr[2:5]\nprint(\"Original array before modification:\", arr)\nslice_view[0] = 99  # Modify the view\nprint(\"Modified slice_view:\", slice_view)\nprint(\"Original array after modification:\", arr)  # arr is also changed\n```\n\nSlices can be programmaticaly generated using the `slice` function, which allows you to create a slice object that can be reused. For example, `s = slice(1, 4)` creates a slice object that can be used as `arr[s]` to get the same result as `arr[1:4]`.\n\n```{python}\n# Creating an independent copy of a slice\nexample_slice = slice(1, 4, 2)\nprint(\"Using slice(1, 4, 2) on arr:\", arr[example_slice])\n```\n\nTo create an **independent copy** of an array (rather than a view), use the `copy()` method. For example, `arr_copy = arr[1:4].copy()` creates a new array with its own data, so changes to `arr_copy` will not affect the original `arr`. This is useful when you want to modify a subset of an array without altering the original data.\n\n```{python}\n# Creating an independent copy of a slice\narr_copy = arr[2:5].copy()\narr_copy[0] = 100  # Modify the copy\nprint(\"arr_copy:\", arr_copy)\nprint(\"Original arr:\", arr)  # arr remains unchanged\n```\n\n### Boolean Indexing\n\nBoolean indexing allows you to select elements from an array based on a condition. When you apply a condition to a NumPy array, it returns a **boolean** (an array that contains only True/False values ) array indicating which elements satisfy the condition. You can then use this boolean array to filter the original array, extracting only the elements that meet the criteria. This technique is powerful for data selection and analysis.\n\n```{python}\narr = np.array([1, 2, 3, 4, 5, 6])\nthreshold = 3\nbool_mask = arr > threshold\nprint(\"Original array:\", arr)\nprint(f\"Boolean mask for threshold {threshold}:\", bool_mask)\nprint(\"Filtered values:\", arr[bool_mask])\n```\n\n### Using `np.where` for conditional selection\n\nThe `np.where` function in NumPy is a powerful tool for conditional selection and element-wise operations. It allows you to choose values from arrays based on a condition, returning indices or constructing new arrays.\n\n- **Basic usage:**  \n    `np.where(condition)` returns the indices where the condition is `True`.\n\n\n\n```{python}\nnp.where(arr > threshold)\n```\n\n`np.where(arr > threshold)` returns a tuple because, for 1D arrays, it provides the indices where the condition is `True`. In NumPy, the output is always a tuple of arrays—one for each dimension of the input array. For a 1D array, it's a single-element tuple containing the indices. For higher dimensions, it returns a tuple with arrays for each axis. This consistent tuple format makes it easy to handle multi-dimensional indexing.\n\nSo, for 1D arrays as the ones considered up to now, we should get the indices by extracting the first element of the tuple returned by `np.where`\n\n```{python}\nnp.where(arr > threshold)[0]\n```\n\n\n- **Element-wise selection:**  \n    `np.where(condition, x, y)` returns elements from `x` where the condition is `True`, and from `y` where it is `False`. Here the result is an array of the same shape as `x` and `y`, containing values from `x` where the condition is met, and from `y` otherwise. This is useful for creating new arrays based on conditions without using loops.\n\n\n\n\n```{python}\na  = np.array([1, 2, 3, 4, 5])\nb = np.array([-1,-2, -3, - 4, -5])\nc = np.array([10, 20, 30, 40, 50])\n\nresult = np.where(a > 2, x, y)\nprint(result)\n```\n\n\n\nThis creates a new array where each element is `100` if the condition is met, otherwise `0`.\n\n## Function to generate numerical arrays\n\nNumPy provides automated methods for generating numerical sequences, which are essential for simulations, sampling, and creating structured data. \n\n### Generating sequences\n\nThe two most used functions for generating  ordered numerical sequences in NumPy are `np.arange` and `np.linspace`.\n\n- **`np.arange(start, stop, step)`**: Generates an array of evenly spaced values within a specified range. The `start` value is inclusive, while the `stop` value is exclusive. The `step` parameter defines the spacing between values.\n  \n  Example: `np.arange(0, 10, 2)` produces `[0, 2, 4, 6, 8]`.\n\n- **`np.linspace(start, stop, num)`**: Creates an array of `num` evenly spaced values between `start` and `stop`, inclusive. This is useful for generating a specific number of points in a range.\n\n\n\n\n```{python}\nprint(\"np.arange(0, 10, 2):\", np.arange(0, 10, 2))\nprint(\"np.linspace(0, 1, 5):\", np.linspace(0, 1, 5))\n```\n\nMost importantly, these functions can be used to create arrays of any kinds of numerical data, including integers and floating-point numbers. \n\n```{python}\n# integers\nnp.arange(0, 10, 2)  # Creates an array with values from 0 to 10 with a step of 2\n```\n\n```{python}\n# floating-point numbers\nnp.arange(0.0, 1.0, 0.2)  # Creates an array with values from 0.0 to 1.0 with a step of 0.2\n```\n\n```{python}\n# complex numbers, by using the data type specifier `dtype=complex`\nnp.arange(0, 10, 2, dtype=complex)  # Creates an array with complex numbers from 0 to 10 with a step of 2\n```\n\nNotice that `linspace` is useful when we know the start and end value and the specific number of points we want to generate, while `arange` is useful when we know the start and end value and the step size between the points.\n\n## Generating filled arrays\n\nNumPy provides functions to create arrays filled with specific values, such as zeros, ones, or a constant value. These functions are useful for initializing arrays before performing computations.\n\nThe main functions for generating filled arrays are:\n- **`np.zeros(shape)`**: Creates an array filled with zeros, where `shape` specifies the dimensions of the array.\n- **`np.ones(shape)`**: Creates an array filled with ones.\n- **`np.full(shape, fill_value)`**: Creates an array filled with a specified value (`fill_value`), where `shape` defines the dimensions of the array.   \n- **`np.empty(shape)`**: Creates an uninitialized array with the specified shape. The values in this array are not set to any particular value, so they may contain random data.\n\nThere are also functions that create arrays with the same shape and type as an existing array, which can be useful for initializing arrays that will be used in computations:\n\n- **`np.zeros_like(array)`**: Creates an array of zeros with the same shape and type as the input array.\n- **`np.ones_like(array)`**: Creates an array of ones with the same shape and type as the input array.\n- **`np.full_like(array, fill_value)`**: Creates an array filled with a specified value, with the same shape and type as the input array.\n\n```{python}\n# Examples using filled array generation functions\n\n# Create a 1D array of zeros with the same shape as arr\nzeros_arr = np.zeros_like(arr)\nprint(\"Zeros array:\", zeros_arr)\n\n# Create a 1D array of ones with the same shape as arr\nones_arr = np.ones_like(arr)\nprint(\"Ones array:\", ones_arr)\n\n# Create a 1D array filled with the value 7, same shape as arr\nfull_arr = np.full_like(arr, 7)\nprint(\"Full array (filled with 7):\", full_arr)\n\n# Create an uninitialized array (values may be random, or zeros)\nempty_2d = np.empty(5)\nprint(\"An empty array:\\n\", empty_2d)\n```\n\n## Random Data Generation\n\nRandom data generation is essential for simulations, statistical modeling, and testing algorithms. \n\nFor example, you might want to generate random samples from a normal distribution to simulate real-world data or create random datasets for testing purposes. Or you may want to simulate the effect of measurement errors in your data analysis. Or you may want to sub-sample a large dataset randomly to take a representative sample without bias.\n\nTo do all this, one needs methods to sample numbers that possess the statistical properties of the desired distribution, such as uniform, normal, or binomial distributions.\n\nStrictly speaking (classical) computers are **deterministic machines**, meaning they follow a set of rules and produce the same output for the same input every time. We have therefore to use algorithms to produce sequences of numbers that mimic the properties of random numbers.\n\nThese are called **pseudo-random numbers**. Pseudo-random number generators (PRNGs) use algorithms to produce sequences of numbers that appear random but are actually deterministic.\n\nA simple and classic example of a pseudo-random number generator is the **Linear Congruential Generator (LCG)**. The LCG produces a sequence of numbers using the recurrence relation:\n\n$$x_{n+1} = (a \\times  x_{n} + c)\\,\\mathrm{mod}\\, m$$\n\nwhere  \n- $x_n$ is the current value,  \n- $a$ is the multiplier,  \n- $c$ is the increment,  \n- $m$ is the modulus.\n\nIn *vanilla* Python this looks like the following custom function\n\n```{python}\ndef lcg(seed, a=1664525, c=1013904223, m=2**32, size=10):\n    nums = []\n    x = seed\n    for _ in range(size):\n        x = (a * x + c) % m\n        nums.append(x)\n    return nums\n```\n\n```{python}\n# Example usage:\nlcg_sequence = lcg(seed=42, size=5)\nprint(\"LCG sequence:\", lcg_sequence)\n```\n\n\n\n\nThis will generate a sequence of pseudo-random integers. The choice of parameters (`a`, `c`, `m`) affects the quality and period of the generator.\n\n```{python}\n# Example of LCG with a short period by choosing small modulus\nshort_period_seq = lcg(seed=1,  a=5, c=3, m=16, size=20)\nprint(\"LCG sequence with short period:\", short_period_seq)\n```\n\nThe **seed** is crucial: it is the initial value that starts the algorithm to determin the subsequent values in the sequence. By setting the seed, you can ensure that the sequence is **reproducible**, meaning that running the same code with the same seed will produce the same sequence of numbers every time.\n\nIn numpy, we do not need to implement our own LCG, as it provides a built-in random number generator that is based on the Mersenne Twister algorithm, which is a widely used and efficient pseudo-random numbwer generator.\n\nWhat we do instead is to use the `numpy.random` **sub-module**, which provides a wide range of functions for generating random numbers from various distributions, including uniform, normal, and binomial distributions.\n\n\nThe standard way to to use it is the following:\n\n- first, one initialises a new kind of object called a **random number generator** (RNG) using `np.random.default_rng()`.  This is a `numpy` object capable of generating random numbers from various distributions. It allows us in particular to set the **seed** and therefore ensure reproducibility.\n\n```{python}\nrng = np.random.default_rng(seed=123)\n```\n\nWe can do this at any point in our code, but it is a good practice to do it at the beginning of our script or notebook, so that we can ensure that all random numbers generated in the script are reproducible. Putting the generator elsewhere (for example, inside a function) could lead to unexpected results, as the generator would be re-initialised each time the function is called.\n\nOnce we have a generator we can access any of its method to sample numbers from various distributions\n\nFor example:\n\n\n\n### Integers\n\nTo sample uniformly distributed integers, we can use the `integers` method of the generator. This method allows us to specify a range and the number of integers to generate.\n\n```{python}\nrng.integers(0, 100, size=5)  # 5 random integers between 0 and 100\n```\n\n### [0-1) uniform floats\n\nTo sample uniformly distributed floats between 0 and 1, we can use the `random` method of the generator. This method generates random floats in the range [0.0, 1.0) (which means 0 included and 1 excluded).\n\n```{python}\nrng.random(1000)\n```\n\nAlternatively, we can use the `uniform` method to sample uniformly distributed floats in a specified range. This method allows us to specify the lower and upper bounds of the range, as well as the number of samples to generate.\n\n```{python}\nrng.uniform(0,1,1000)\n```\n\n### Normal distribution\n\nTo sample from a normal distribution, we can use the `normal` method of the generator. This method allows us to specify the mean and standard deviation of the distribution, as well as the number of samples to generate. The generated samples will follow a normal (Gaussian) distribution with the specified parameters.\n\n```{python}\nnormal_rv = rng.normal(loc=0, scale=4, size=10000)  # 10000 samples from a normal distribution with mean 0 and std dev 1\n```\n\n```{python}\n# check that the sample mean and standard deviation are close to the specified values \n\nnormal_rv.mean()\n```\n\n```{python}\nnormal_rv.std()\n```\n\n## Sampling a siingle value \n\nIf we only want to sample a single  value, we can simply not specify the `size` parameter, or set it to `1`. This will return a single value sampled from the specified distribution.\n\n```{python}\nrng.integers(0,100) # run this multiple times to observe the random nature of the output\n```\n\nHowever, this can sometimes be more computationally costly than generating a larger sample and then selecting a single value from it. \n\n```{python}\nimport time\n\n# Timing a for loop that generates a random integer in each iteration\nstart_time = time.time()\nsteps = 1000000\nfor _ in range(steps):\n    # use a random value\n    val = 2*rng.integers(0, 100)\nelapsed_no_prealloc = time.time() - start_time\n\n# Timing a for loop that uses preallocated random integers\npreallocated = rng.integers(0, 100, size=steps)\nstart_time = time.time()\nfor u in preallocated:\n    val = 2*u  # use the preallocated value\nelapsed_prealloc = time.time() - start_time\n\nprint(f\"Time without preallocation: {elapsed_no_prealloc:.4f} seconds\")\nprint(f\"Time with preallocation: {elapsed_prealloc:.4f} seconds\")\n```\n\nThis is a good example of the tradeoff between memory usage and computational efficiency: in modern machines, memory is quite cheap, so it is often more efficient to preallocate a larger array and then sample from it, rather than generating a single value at a time.\n\nA good size for preallocated numbers depends on your use case and available memory. Typical choices are:\n\n- Small tasks: `100` to `1,000` elements\n- Medium tasks: `10,000` to `100,000` elements\n- Large tasks: `1,000,000` or more elements\n\nFor most data analysis or simulation tasks, starting with `100,000` elements is practical and efficient. Always ensure the size fits within your system's memory limits.\n\n\n\n"},"formats":{"live-html":{"identifier":{"display-name":"HTML","target-format":"live-html","base-format":"html","extension-name":"live"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":true,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["/Users/ft14968/Repos/intro-coding-data-analysis/quarto/_extensions/r-wasm/live/live.lua"],"include-in-header":{"text":"<meta name=\"robots\" content=\"noindex, nofollow\">\n"},"css":["../styles.css"],"toc":true,"toc-depth":3,"highlight-style":"github","number-sections":false,"output-file":"lecture_working_with_numpy.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","ojs-engine":true,"revealjs-plugins":[],"theme":"cosmo","toc-location":"right","code-copy":true,"grid":{"sidebar-width":"350px"},"title":"Working with Arrays in NumPy: Indexing and Random Data Generation","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["live-html"]}