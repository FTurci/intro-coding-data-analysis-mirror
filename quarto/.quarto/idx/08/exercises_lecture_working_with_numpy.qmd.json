{"title":"Exercises - Working with NumPy","markdown":{"yaml":{"title":"Exercises - Working with NumPy","jupyter":"python3"},"headingText":"Exercise 1: Basic Indexing","containsRefs":false,"markdown":"\n\n\n\nCreate a 1D NumPy array `arr` of integers from 10 to 19. Access the element at index 3.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 2: Slicing\nSlice the array `arr` to get elements from index 2 to 6 included.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 3: Step Slicing\nUse slicing with a step to get every second element from index 1 to 9.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 4: Copy vs View\nDemonstrate that slicing creates a view, not a copy, by modifying a slice and showing the original array changes.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 5: Copying Arrays\nUse `.copy()` to create a slice that doesn't affect the original array. In particular, select only the elements from index 2 to 5 and assign 99 to all of them. Show that the original array remains unchanged.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 6: Generating sequences and Boolean indexing\n\nGenerate a NumPy sequence of 100 integers from 0 to 99. Use Boolean indexing to select only the even numbers from this array.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 8: Random Array Generation\n\nRandom numbers from arbitrary distributions are in fact generated through the transformation of uniformly distributed random numbers.\n\nThe trick is the following:\n\n- calculate the cumulative distribution function (CDF) of the desired distribution\n- calculate the inverse of the CDF (also known as the quantile function), which maps probabilities (values between 0 and 1) to values of the random variable\n- sample a uniformly distributed random number between 0 and 1 and use the the inverse CDF to read off the value of the random variable.\n\n\nLet's take the example of the exponential distribution. This is defined by the following probability density function (PDF):\n\n$$\nf(x) = \\lambda e^{-\\lambda x}\n$$\nwith mean $1/\\lambda$ and standard deviation $1/\\lambda$. \n\nThe CDF of the exponential distribution is given by:\n\n$$F(x) = 1 - e^{-\\lambda x}\n$$\n\nSo its inverse is:\n$$F^{-1}(p) = -\\frac{1}{\\lambda} \\ln(1 - p)$$\n\nSo in the following cell:\n\n- define a random number generator `rng` with a fixed seed 10\n- sample 1000 uniformly distributed random numbers between 0 and 1\n- use the inverse CDF to transform them into exponentially distributed random numbers with mean  30.0\n- calculate the mean and standard deviation of the resulting array.\n- compare this with the results obtained using `rng.exponential`.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n## Exercise 9: Problem solving with NumPy\n\nConsider the following problem:\n\n> A panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. **Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.**\n\nThe problem is a two-dimensional problem. The passenger has coordinates $x(t), y(t)$ and is performing uniform rotational motion, with angular velocity $\\omega$ and radius $R$. \n\nThe angle formed at which the passenger is located is $\\theta(t)$ and simply evolves as \n\n$$\\theta(t) = \\omega t +\\theta_0$$\n\nwhere $\\theta_0$ is the initial angle ($\\theta_0=0$ in our case).\n\n\nHence, the trajectory is expressed by \n\n$$\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n$$\n\n\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\n\nThe first approach is via using vanilla Python\n\n```{python}\nimport math\nR = 10.0 #in metres\nomega = 2.0*2*math.pi/60. # in radians per second\nx0 = R # in metres\ny0 = 0 # in metres\ndt = 2.0 # in seconds\nduration = 20.0 #in seconds\nnum_iterations  = int(duration/dt)\nx, y = [], []\nt = 0\nfor _ in range(num_iterations):\n    x.append(R*math.cos(omega*t)+x0)\n    y.append(R*math.sin(omega*t)+y0)\n    t += dt \n\n# plotting, ignore the details for now sicne we will cover this in a later lecture\nimport matplotlib.pyplot as plt\nplt.scatter(x,y)\nplt.axis(\"equal\")\nplt.show()\n```\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on **avoiding for loops** and using NumPy's array operations instead.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n\n","srcMarkdownNoYaml":"\n\n\n\n### Exercise 1: Basic Indexing\nCreate a 1D NumPy array `arr` of integers from 10 to 19. Access the element at index 3.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 2: Slicing\nSlice the array `arr` to get elements from index 2 to 6 included.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 3: Step Slicing\nUse slicing with a step to get every second element from index 1 to 9.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 4: Copy vs View\nDemonstrate that slicing creates a view, not a copy, by modifying a slice and showing the original array changes.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 5: Copying Arrays\nUse `.copy()` to create a slice that doesn't affect the original array. In particular, select only the elements from index 2 to 5 and assign 99 to all of them. Show that the original array remains unchanged.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 6: Generating sequences and Boolean indexing\n\nGenerate a NumPy sequence of 100 integers from 0 to 99. Use Boolean indexing to select only the even numbers from this array.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n### Exercise 8: Random Array Generation\n\nRandom numbers from arbitrary distributions are in fact generated through the transformation of uniformly distributed random numbers.\n\nThe trick is the following:\n\n- calculate the cumulative distribution function (CDF) of the desired distribution\n- calculate the inverse of the CDF (also known as the quantile function), which maps probabilities (values between 0 and 1) to values of the random variable\n- sample a uniformly distributed random number between 0 and 1 and use the the inverse CDF to read off the value of the random variable.\n\n\nLet's take the example of the exponential distribution. This is defined by the following probability density function (PDF):\n\n$$\nf(x) = \\lambda e^{-\\lambda x}\n$$\nwith mean $1/\\lambda$ and standard deviation $1/\\lambda$. \n\nThe CDF of the exponential distribution is given by:\n\n$$F(x) = 1 - e^{-\\lambda x}\n$$\n\nSo its inverse is:\n$$F^{-1}(p) = -\\frac{1}{\\lambda} \\ln(1 - p)$$\n\nSo in the following cell:\n\n- define a random number generator `rng` with a fixed seed 10\n- sample 1000 uniformly distributed random numbers between 0 and 1\n- use the inverse CDF to transform them into exponentially distributed random numbers with mean  30.0\n- calculate the mean and standard deviation of the resulting array.\n- compare this with the results obtained using `rng.exponential`.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n## Exercise 9: Problem solving with NumPy\n\nConsider the following problem:\n\n> A panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. **Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.**\n\nThe problem is a two-dimensional problem. The passenger has coordinates $x(t), y(t)$ and is performing uniform rotational motion, with angular velocity $\\omega$ and radius $R$. \n\nThe angle formed at which the passenger is located is $\\theta(t)$ and simply evolves as \n\n$$\\theta(t) = \\omega t +\\theta_0$$\n\nwhere $\\theta_0$ is the initial angle ($\\theta_0=0$ in our case).\n\n\nHence, the trajectory is expressed by \n\n$$\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n$$\n\n\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\n\nThe first approach is via using vanilla Python\n\n```{python}\nimport math\nR = 10.0 #in metres\nomega = 2.0*2*math.pi/60. # in radians per second\nx0 = R # in metres\ny0 = 0 # in metres\ndt = 2.0 # in seconds\nduration = 20.0 #in seconds\nnum_iterations  = int(duration/dt)\nx, y = [], []\nt = 0\nfor _ in range(num_iterations):\n    x.append(R*math.cos(omega*t)+x0)\n    y.append(R*math.sin(omega*t)+y0)\n    t += dt \n\n# plotting, ignore the details for now sicne we will cover this in a later lecture\nimport matplotlib.pyplot as plt\nplt.scatter(x,y)\nplt.axis(\"equal\")\nplt.show()\n```\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on **avoiding for loops** and using NumPy's array operations instead.\n\n```{python}\n#| tags: [sol]\n# Your code here\n```\n\n\n"},"formats":{"live-html":{"identifier":{"display-name":"HTML","target-format":"live-html","base-format":"html","extension-name":"live"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":true,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["/Users/ft14968/Repos/intro-coding-data-analysis/quarto/_extensions/r-wasm/live/live.lua"],"include-in-header":{"text":"<meta name=\"robots\" content=\"noindex, nofollow\">\n"},"css":["../styles.css"],"toc":true,"toc-depth":3,"highlight-style":"github","number-sections":false,"output-file":"exercises_lecture_working_with_numpy.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","ojs-engine":true,"revealjs-plugins":[],"theme":"cosmo","toc-location":"right","code-copy":true,"grid":{"sidebar-width":"350px"},"title":"Exercises - Working with NumPy","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["live-html"]}