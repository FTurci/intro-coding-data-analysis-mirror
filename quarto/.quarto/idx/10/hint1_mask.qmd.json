{"title":"Hint 1 - creating a square mask","markdown":{"yaml":{"title":"Hint 1 - creating a square mask","jupyter":"python3"},"headingText":"Edge of square","containsRefs":false,"markdown":"\n\n\n\n**Example: Creating a 100 x 100 grid containing a square where the centre of that square is at (80, 40) and the width is 30.**\n\nTo check whether an (x, y) position is within the square we want to define, we want to evaluate if these two conditions are both satisfied:\n$$|x - x_0| = w/2$$\nand\n$$|y - y_0| = w/2$$\n\nwhere\n - $x$, $y$ are the x, y positions within the grid\n - $x_0$, $y_0$ are the centre of the square\n - $w$ - is both the full width and height of the square\n - $| |$ means the magnitude of the difference\n\nThis code will show one way to create a mask which contains a square. This will take the most direct approach and evaluate every index in the 2D array one at a time.\n\n```{python}\nimport numpy as np\n\nshape = (100, 100)\n```\n\nStart by creating an array of zeros for our overall grid:\n\n```{python}\nsquare_mask = np.zeros(shape)\nprint(square_mask)\n```\n\nNext we can define the parameters we need for the square:\n\n```{python}\ncentre = (80, 40) # Centre (x, y)\nwidth = 30 # Width of square\n```\n\nSo, to check whether a given position is within our mask (the square we are defining), we need to find a way to use our equations above and write them in code.\n\nWe've created a grid of size of 100 x 100 so, as an example, let's use the position (50, 50) for our grid:\n\n```{python}\nx = 50\ny = 50\n\nx0 = centre[0] # Define central x position for the square\ny0 = centre[1] # Define central y position for the square\n\n# |x - x0| = width/2\n# |y - y0| = width/2\n\ndistance_x = np.abs(x - x0) # Magnitude of distance - x-x0\ndistance_y = np.abs(y - y0) # Magnitude of distance - y-y0\n\n# Use our conditions to check whether this (y, x) position is inside the square\nif distance_x < width/2 and distance_y < width/2:\n    print(\"Position is inside the mask\")\n    square_mask[y, x] = 1 # Using our index values, set to value within our array to 1 if this is inside the square\nelse:\n    print(\"Position is not inside the mask\")\n```\n\nNow we can build this up to look at every element in the 2D array we have created and check whether this is inside the square (we will leave the value as 0) or outside the square (we will set the value to 1). To do this we can loop through every column and every row and check the result of our conditions:\n\n```{python}\nx0 = centre[0]\ny0 = centre[1]\n\nncol = shape[0]\nnrow = shape[1]\n\nfor y in range(nrow): # iterate over first dimension\n    for x in range(ncol): # iterate over second dimension\n        \n        distance_x = np.abs(x - x0) # Magnitude of distance\n        distance_y = np.abs(y - y0) # Magnitude of distance\n        \n        # Check whether each position is inside the square\n        if distance_x < width/2 and distance_y < width/2:\n            square_mask[y, x] = 1 # Set to 1 if inside the square\n```\n\nWe don't need an `else` block here because the array we have defined *already contains zeros*. This means if our conditin doesn't match we don't need to update the values within the array.\n\nWe could check where our mask has been set to 1 using the `np.where` function. For a two-dimensional array like `square_mask`, this will return two arrays containing the positions of the match - one for the first dimension and one for the second dimension.\n\nEach pair of values (one in the first array and one the second) represents a 2D position in our array:\n\n```{python}\n# Where have we created our mask in our overall grid\nnp.where(square_mask == 1)\n```\n\nWe can look at this mask using `matplotlib` and a plotting option called `imshow` ([documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html); [example from image gallery](https://matplotlib.org/stable/gallery/images_contours_and_fields/image_demo.html)):\n\n```{python}\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Square Mask')\nax.imshow(square_mask,cmap=\"bone\",origin=\"lower\")\n```\n\nIn this plot, the white represents the values in the mask (values of 1) and the black represents the values outside the mask (values of 0).\n\n---\n\n### Extended: Leveraging numpy functionality\n\nAn alternative and more efficient way to do this would be to leverage the properties of numpy arrays and the available numpy functions and indexing.\n\nWe can start in the same way and create our array of zeros of the right shape\n\n```{python}\nsquare_mask_2 = np.zeros(shape)\n```\n\nWe can represent the pixel position for our x and y dimensions using numbers for 0 to 99 (for x) and 0 to 99 (for y) since our shape is 100 x 100. \n\nWe can then create a pair of 2D grids, `X` and `Y`, to match to the shape of our mask using a [function called `np.meshgrid()`](https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html). This stretches our x and y coordinate values to create our 2D numpy arrays.\n\n```{python}\n# Create arrays matching to our size along our x and y axes\nx = np.arange(shape[1])\ny = np.arange(shape[0])\n\nX, Y = np.meshgrid(x, y)\n\nprint(f\"X array: {X.shape}\")\nprint(X)\nprint(f\"Y array: {Y.shape}\")\nprint(Y)\n```\n\nWe can find the positions where our conditions are met within our grid using the [`np.where()` function](https://numpy.org/doc/stable/reference/generated/numpy.where.html). From here we can filter our mask using [integer array indexing](https://numpy.org/doc/stable/user/basics.indexing.html#integer-array-indexing) and change these values from 0 to 1 within our mask.\n\n```{python}\n# We can calculate the x and y distances for each value in our 2D grids\ndistance_x = np.abs(X - x0) # Magnitude of distance\ndistance_y = np.abs(Y - y0) # Magnitude of distance\n\n# We can use the numpy where function to find the positions where our conditions are matched\n# - to include multiple conditions we have included an & (known as a bitwise operator)\nindices = np.where((distance_x < width/2) & (distance_y < width/2))\n\n# And using these indices change the values to 1\nsquare_mask_2[indices] = 1\n```\n\n```{python}\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Square Mask (alternative method)')\nax.imshow(square_mask_2,cmap=\"bone\",origin=\"lower\")\n```\n\n---\n\n","srcMarkdownNoYaml":"\n\n\n\n**Example: Creating a 100 x 100 grid containing a square where the centre of that square is at (80, 40) and the width is 30.**\n\nTo check whether an (x, y) position is within the square we want to define, we want to evaluate if these two conditions are both satisfied:\n$$|x - x_0| = w/2$$\nand\n$$|y - y_0| = w/2$$\n\nwhere\n - $x$, $y$ are the x, y positions within the grid\n - $x_0$, $y_0$ are the centre of the square\n - $w$ - is both the full width and height of the square\n - $| |$ means the magnitude of the difference\n\nThis code will show one way to create a mask which contains a square. This will take the most direct approach and evaluate every index in the 2D array one at a time.\n\n```{python}\nimport numpy as np\n\nshape = (100, 100)\n```\n\nStart by creating an array of zeros for our overall grid:\n\n```{python}\nsquare_mask = np.zeros(shape)\nprint(square_mask)\n```\n\nNext we can define the parameters we need for the square:\n\n```{python}\ncentre = (80, 40) # Centre (x, y)\nwidth = 30 # Width of square\n```\n\nSo, to check whether a given position is within our mask (the square we are defining), we need to find a way to use our equations above and write them in code.\n\nWe've created a grid of size of 100 x 100 so, as an example, let's use the position (50, 50) for our grid:\n\n```{python}\nx = 50\ny = 50\n\nx0 = centre[0] # Define central x position for the square\ny0 = centre[1] # Define central y position for the square\n\n# Edge of square\n# |x - x0| = width/2\n# |y - y0| = width/2\n\ndistance_x = np.abs(x - x0) # Magnitude of distance - x-x0\ndistance_y = np.abs(y - y0) # Magnitude of distance - y-y0\n\n# Use our conditions to check whether this (y, x) position is inside the square\nif distance_x < width/2 and distance_y < width/2:\n    print(\"Position is inside the mask\")\n    square_mask[y, x] = 1 # Using our index values, set to value within our array to 1 if this is inside the square\nelse:\n    print(\"Position is not inside the mask\")\n```\n\nNow we can build this up to look at every element in the 2D array we have created and check whether this is inside the square (we will leave the value as 0) or outside the square (we will set the value to 1). To do this we can loop through every column and every row and check the result of our conditions:\n\n```{python}\nx0 = centre[0]\ny0 = centre[1]\n\nncol = shape[0]\nnrow = shape[1]\n\nfor y in range(nrow): # iterate over first dimension\n    for x in range(ncol): # iterate over second dimension\n        \n        distance_x = np.abs(x - x0) # Magnitude of distance\n        distance_y = np.abs(y - y0) # Magnitude of distance\n        \n        # Check whether each position is inside the square\n        if distance_x < width/2 and distance_y < width/2:\n            square_mask[y, x] = 1 # Set to 1 if inside the square\n```\n\nWe don't need an `else` block here because the array we have defined *already contains zeros*. This means if our conditin doesn't match we don't need to update the values within the array.\n\nWe could check where our mask has been set to 1 using the `np.where` function. For a two-dimensional array like `square_mask`, this will return two arrays containing the positions of the match - one for the first dimension and one for the second dimension.\n\nEach pair of values (one in the first array and one the second) represents a 2D position in our array:\n\n```{python}\n# Where have we created our mask in our overall grid\nnp.where(square_mask == 1)\n```\n\nWe can look at this mask using `matplotlib` and a plotting option called `imshow` ([documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html); [example from image gallery](https://matplotlib.org/stable/gallery/images_contours_and_fields/image_demo.html)):\n\n```{python}\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Square Mask')\nax.imshow(square_mask,cmap=\"bone\",origin=\"lower\")\n```\n\nIn this plot, the white represents the values in the mask (values of 1) and the black represents the values outside the mask (values of 0).\n\n---\n\n### Extended: Leveraging numpy functionality\n\nAn alternative and more efficient way to do this would be to leverage the properties of numpy arrays and the available numpy functions and indexing.\n\nWe can start in the same way and create our array of zeros of the right shape\n\n```{python}\nsquare_mask_2 = np.zeros(shape)\n```\n\nWe can represent the pixel position for our x and y dimensions using numbers for 0 to 99 (for x) and 0 to 99 (for y) since our shape is 100 x 100. \n\nWe can then create a pair of 2D grids, `X` and `Y`, to match to the shape of our mask using a [function called `np.meshgrid()`](https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html). This stretches our x and y coordinate values to create our 2D numpy arrays.\n\n```{python}\n# Create arrays matching to our size along our x and y axes\nx = np.arange(shape[1])\ny = np.arange(shape[0])\n\nX, Y = np.meshgrid(x, y)\n\nprint(f\"X array: {X.shape}\")\nprint(X)\nprint(f\"Y array: {Y.shape}\")\nprint(Y)\n```\n\nWe can find the positions where our conditions are met within our grid using the [`np.where()` function](https://numpy.org/doc/stable/reference/generated/numpy.where.html). From here we can filter our mask using [integer array indexing](https://numpy.org/doc/stable/user/basics.indexing.html#integer-array-indexing) and change these values from 0 to 1 within our mask.\n\n```{python}\n# We can calculate the x and y distances for each value in our 2D grids\ndistance_x = np.abs(X - x0) # Magnitude of distance\ndistance_y = np.abs(Y - y0) # Magnitude of distance\n\n# We can use the numpy where function to find the positions where our conditions are matched\n# - to include multiple conditions we have included an & (known as a bitwise operator)\nindices = np.where((distance_x < width/2) & (distance_y < width/2))\n\n# And using these indices change the values to 1\nsquare_mask_2[indices] = 1\n```\n\n```{python}\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Square Mask (alternative method)')\nax.imshow(square_mask_2,cmap=\"bone\",origin=\"lower\")\n```\n\n---\n\n"},"formats":{"live-html":{"identifier":{"display-name":"HTML","target-format":"live-html","base-format":"html","extension-name":"live"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":true,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["/Users/ft14968/Repos/intro-coding-data-analysis/quarto/_extensions/r-wasm/live/live.lua"],"include-in-header":{"text":"<meta name=\"robots\" content=\"noindex, nofollow\">\n"},"css":["../styles.css"],"toc":true,"toc-depth":3,"highlight-style":"github","number-sections":false,"output-file":"hint1_mask.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","ojs-engine":true,"revealjs-plugins":[],"theme":"cosmo","toc-location":"right","code-copy":true,"grid":{"sidebar-width":"350px"},"title":"Hint 1 - creating a square mask","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["live-html"]}