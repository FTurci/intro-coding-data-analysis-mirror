{"title":"Multi-dimensional arrays","markdown":{"yaml":{"title":"Multi-dimensional arrays","jupyter":"python3"},"headingText":"Basic properties of multi-dimensional arrays","containsRefs":false,"markdown":"\n\n\n\nA `numpy.ndarray` is the more complete term for a `numpy` `array` object. Up until this point we have mainly been dealing with and using one dimensional arrays. Numpy arrays (unlike lists) have the concept of shape whicih means they can be multi-dimensional. This means they can represent a grid (2D), a cuboid (3D) and so forth.\n\nThe code below generates a `numpy.array` object containing random numbers. This is a 2D array with a 3 x 3 shape:\n\n```{python}\nfrom numpy import random\n\nrng = random.default_rng(seed=24)\n```\n\n```{python}\nimport numpy as np\n\nshape = (3,3)\narray1 = rng.random(shape)\nprint(array1.shape)\nprint(array1)\n```\n\nWe can select one element from this array using the following syntax. We still use square brackets and pass an index value but now we can pass values for each dimension seperated by a comma (`,`). This index is selecting the third column within the second row:\n\n```{python}\nprint(array1[1, 2])\n```\n\nUsing slicing (*Start:Stop*) syntax you can select an entire dimension at once by omitting both the Start and Stop values and just using `:`. You can see how this works if you try the slice with just the Start or just the Stop e.g.\n\n```{python}\nprint(array1[:2])\nprint(array1[2:])\n```\n\nNot including a Start index includes values from the beginning of the array/list etc. up to (but not including) the Stop.\n\nNot including a Stop index reads from the Start to the end of the array/list etc.\n\nSo just using `:` with no Start or Stop selects all elements for that dimension.\n\nThis following syntax returns first row (first row, every column):\n\n```{python}\nprint(array1[0,:])\n```\n\nAnd this would return the first column (every row, first column):\n\n```{python}\nprint(array1[:,0])\n```\n\n`numpy` `array` objects store data in **row-major** order. Essentially this means for a 2D index this would be the equivalent of [y, x] rather than [x, y].\n\n\n### Shape\n\nThe **shape** of a multi-dimensional array is a tuple that describes the size of each dimension. For example, a 2D array with 3 rows and 4 columns has a shape of `(3, 4)`. You can access the shape of an array using the `.shape` attribute.\n\nWe can use many of the array initialisation functions we haver seen for 1d arrays also to create multi-dimensional arrays. For example, we can use `np.zeros` to create a 2D array of zeros, or `np.ones` to create a 2D array of ones. We can also use `np.random.rand` to create a 2D array of random numbers.\n\n```{python}\narray_of_zeros = np.zeros(shape=(2, 3)) # 2 rows, 3 columns\n```\n\n```{python}\nnp.ones_like(array_of_zeros)\n```\n\n\n### Axis and Rank\n\nA multi-dimensional array has multiple dimensions, each of which can be thought of as an **axis**. The number of dimensions is called the **rank** of the array. For example, a 2D array has a rank of 2, while a 3D array has a rank of 3. It is accessible via the `.ndim` attribute.\n\nWe typically call a rank 2 array a **matrix**. A rank 3 array (or higher) is often called a **tensor**. \n\n```{python}\nrng = random.default_rng(seed=24)\nrandom_matrix = rng.uniform(-1,1,size=(2,5)) # random floats between -1 and 1, 2 rows, 5 columns\nrandom_matrix\n```\n\n```{python}\nrandom_matrix.ndim # two dimensions, rank 2, a matrix\n```\n\n```{python}\nrandom_tensor = rng.integers(0,3,size=(2,3,4)) # random integes in [0,3), 2x3x4 tensor\nrandom_tensor\n```\n\n```{python}\nrandom_tensor.ndim\n```\n\nWe can perform operations along specific axes of a multi-dimensional array. For example, we can sum all the elements along a specific axis using the `np.sum` function with the `axis` parameter.\n\n```{python}\nsmall_matrix = rng.integers(0,2,size=(3,2)) \nsmall_matrix\n```\n\n```{python}\nsmall_matrix.sum(axis=0) # sum along the first axis (rows)\n```\n\n```{python}\nsmall_matrix.sum(axis=1) # sum along the second axis (columns), can you explain the resulting shape?\n```\n\nOne can do the same also with useful statistical descriptors such as `np.mean`, `np.std`, etc.\n\n```{python}\nnp.mean(small_matrix, axis=0) # mean along the first axis (rows)\n```\n\n### Slicing\n\nSlicing works similarly to 1D arrays, but you can slice along multiple axes. For example, you can slice a 2D array to get a submatrix or a specific row or column.\n\n```{python}\nsmall_matrix[:, 0] # all rows, first column\n```\n\n```{python}\nsmall_matrix[:2,:] # first two rows, all columns\n```\n\n```{python}\nsmall_matrix[::-1,:1]\n```\n\n### Reshaping and flattening\n\nThe last example show an inetresting case: we extracted a single column from the matrix, but it is still a 2D array with shape `(3, 1)`.\n\n```{python}\nselection = small_matrix[::-1,:1]\n\nprint(\"shape\", selection.shape)\nprint(\"rank\", selection.ndim)\n```\n\nWhat if we wanted a truly 1d array (rank 1)? We need to **reshape** the array. \n\nWe can use the `np.reshape` function to change the shape of an array without changing its data. For example, we can reshape a 2D array into a 1D array or vice versa.\n\nReshape takes a tuple of the new shape as an argument. If you want to flatten an array (convert it to a 1D array), you can use `-1` as one of the dimensions, which tells NumPy to infer the size of that dimension based on the total number of elements.\n\n```{python}\nselection = small_matrix[::-1,:1]\nreshaped_selection = selection.reshape((3,))  # reshape to a 1D array excplicitly\nprint(\"reshaped shape\", reshaped_selection.shape)\nprint(\"reshaped rank\", reshaped_selection.ndim)\nprint(\"reshaped selection\", reshaped_selection)\n```\n\n```{python}\n#same code as above, but with inferred shape\nselection = small_matrix[::-1,:1]\nreshaped_selection = selection.reshape(-1)  # infererd shape\nprint(\"reshaped shape\", reshaped_selection.shape)\nprint(\"reshaped rank\", reshaped_selection.ndim)\nprint(\"reshaped selection\", reshaped_selection)\n```\n\nAnother way to cast a multi-dimensional array to a 1D array is to use the `np.ravel()` function, which returns a flattened view of the array (not a copy).\n\n```{python}\na_matrix = rng.integers(0,10,size=(2,3)) # random integers in [0,10), 2x3 matrix\nprint(\"Original matrix:\\n\", a_matrix)\nravelled_view = a_matrix.ravel()\nprint(\"Flattened view:\", ravelled_view)  # flatten the array to a 1D array\n```\n\nIf we modify the view, we modify the original array as well.\n\n```{python}\nravelled_view[0] = 100  # modify the view\nprint(\"Modified view:\", ravelled_view)  # the view is modified\nprint(\"Original array:\", a_matrix)  # the original array is modified as well\n```\n\nTo obtain a completely independent flattened copy of the array, you can use the `np.flatten()` method, which returns a copy of the array in a 1D format.\n\n```{python}\na_matrix = rng.integers(0,10,size=(2,3)) # random integers in [0,10), 2x3 matrix\nprint(\"The original:\\n\",a_matrix)\nflattened_copy = a_matrix.flatten()\nprint(\"Flattened:\",flattened_copy)  # flatten the array to a 1D array\nflattened_copy[0] = 100  # modify the copy\nprint(\"Flattened after modification:\",flattened_copy)  # the copy is modified\nprint(\"The original:\\n\",a_matrix)  # the original array is not modified\n```\n\nWe can also do the opposite and increase the rank of an array by reshaping it. For example, we can reshape a 1D array into a 2D array with one column or one row.\n\n```{python}\none_dimensional_array = rng.integers(0,10,size=(5,))  # random integers in [0,10), 1D array\nprint(\"One-dimensional array:\", one_dimensional_array)\nreshaped_array = one_dimensional_array.reshape((5,1))  # reshape to a  2D array with one column\nprint(\"Reshaped array:\\n\", reshaped_array)\n```\n\n### Broadcasting\n\nCombining arrays of different shapes is possible in NumPy using a feature called **broadcasting**. Broadcasting allows NumPy to perform operations on arrays of different shapes by automatically expanding the smaller array to match the shape of the larger one.\n\n```{python}\n# Minimal broadcasting example: rank 2 (matrix) with rank 1 (vector)\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6]])\nvector = np.array([10, 20, 30])\n\n# Broadcasting addition: vector is added to each row of the matrix\nresult = matrix + vector\nprint(\"Matrix:\\n\", matrix)\nprint(\"Vector:\", vector)\nprint(\"Result of broadcasting:\\n\", result)\n```\n\nYou can reshape a 1D array to a column or row vector and use broadcasting to expand it into a large table. For example, to create a table where each row is the original 1D array, or each column is the original array:\n\n```{python}\none_dimensional_array = np.linspace(1, 5, num=5)  # create a 1D array with 5 elements\nprint(\"One-dimensional array:\", one_dimensional_array)\n# Expand one_dimensional_array to a table with 5 rows and 5 columns\nrow_vector = one_dimensional_array.reshape(1, -1)  # shape (1, 5)\ncolumn_vector = one_dimensional_array.reshape(-1, 1)  # shape (5, 1)\n\n# Broadcasting to create a table\ntable = column_vector + row_vector\nprint(\"BroadcastedTable:\\n\",table)\n```\n\n## Two-dimensional arrays as matrices: some linear algebra\n\nTwo-dimensional arrays are often used to represent matrices or images. In a matrix, each element can be accessed using two indices: \n- one for the row \n- one for the column. \n\n\nA matrix is a rectangular array of numbers, symbols, or expressions arranged in rows and columns and is an essential concept in **linear algebra**.\n\nFor examplle, let's consider the simple system of simultaneous equations:\n\n$$ \\begin{align*}\n2x + 3y +z &= 5 \\\\\n4x - y &= 1 \\\\\n2y +z &= 3\n\\end{align*} $$\n\nThis can be represented in matrix form as:\n$$ \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n=\n\\begin{bmatrix}5 \\\\\n1\\\\\n3\n\\end{bmatrix} $$   \n\nAnd if we call $A$ the matrix of coefficients, $\\mathbf{x}$ the vector of variables, and $b$ the vector of constants, we can write this as:\n$$ A \\mathbf{x} = \\mathbf{b} $$\n\nwhere $$A = \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}, \\quad\n\\mathbf{x} = \\begin{bmatrix}\nx \\\\\ny\\\\\nz\n\\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix}\n5 \\\\\n1\\\\\n3\n\\end{bmatrix} $$            \n\nA key result of linear algebra is that if $A$ is invertible, we can solve for $\\mathbf{x}$ by multiplying both sides of the equation by the inverse of $A$:\n$$ \\mathbf{x} = A^{-1} \\mathbf{b} $$\n\nwhere $A^{-1}$ is the inverse of matrix $A$.\n\nNumPy has a dedicated linear algebra submodule called `numpy.linalg` that provides functions for performing various linear algebra operations, including matrix inversion, solving systems of equations, and computing eigenvalues and eigenvectors.\n\n\n```{python}\nA = np.array([[2, 3,1], [4, -1,0],[0,2,1]])\nb = np.array([[5], [1], [3]]) # we use double brackets to create a column vector\nprint(\"Matrix A:\\n\", A)\nprint(\"Vector b:\\n\", b)\n```\n\nThe linear algebra submodule has a function called `solve` which can be used to solve the above equation efficiently:\n\n```{python}\nx = np.linalg.solve(A, b)\n\nx\n```\n\nBut we can use numpy to verify that this is correct. We can use the symbol `@` to perform matrix multiplication in numpy. \n\n```{python}\nA @ x\n```\n\nWe can also directly calculate the inverse of a matrix using the `inv` function from the `numpy.linalg` and use it to solve the equation\n\n```{python}\nx = np.linalg.inv(A) @ b\n\nx\n```\n\nAll the most common linear algebra operations are available in the `numpy.linalg` submodule:\n\n- tranpose\n\n```{python}\nb.T\n```\n\n- scalar (dot) product (which takes two vectors and returns a scalar)\n\n```{python}\nnp.dot(b.T,b)\n```\n\n- cross product\n\n```{python}\nnp.cross(b.T, b.T) #takes row vectors and returns a row vector\n```\n\nLinear algebra applications are beyond the scope of this course (so, there will be **no assessment of these**), but they are widely used in various fields such as physics, computer science, and engineering. For example, they are essential in computer graphics for transformations, in machine learning for optimization, and in physics for solving systems of equations. So it is important for you to know that all these can be implemented efficiently using numpy.\n\n## Matrices as images\n\nA two-dimensional table of numbers can also be used to represent an image. Each number in the table corresponds to a pixel in the image, and the value of the number represents the color or intensity of that pixel.\n\n`matplotlib` provides a convenient way to visualize 2D arrays as images. The `matshow` function can be used to display a 2D matrix as an image, where the values in the array are mapped to colors.\n\n```{python}\nimport matplotlib.pyplot as plt\nplt.matshow(A)\nplt.colorbar()\nprint(A)\n```\n\nNotice that the indices of the y-axis increase as we go down. These are the indices of the rows in the matrix.\n\nFor a matrix of a given shape we can get the indices using the `np.indices` function, which returns a grid of indices for each dimension. This can be useful for creating masks or selecting specific regions of the matrix.\n\n```{python}\nrow_index, col_index = np.indices(A.shape)\nprint(\"Row indices:\\n\", row_index)\nprint(\"Column indices:\\n\", col_index)\n```\n\nAn alternative function is `imshow`, which is more general and can be used for both 2D arrays and images.\n\nHere we can set the origin of the axis:\n\n```{python}\nplt.imshow(A, origin='lower')  # origin='lower' to set the origin at the bottom left\n```\n\n```{python}\nplt.imshow(A, origin='upper')  # origin=\"upper\" to set the origin at the top left\n```\n\nThe main difference between `matshow` and `imshow` is that `matshow` is specifically designed for displaying matrices, while `imshow` is more general and can be used for both 2D arrays and images. `matshow` automatically adjusts the aspect ratio to make the matrix square, while `imshow` does not. Also the interpolation method used by `matshow` is different from that used by `imshow`, which can affect the appearance of the image.\n\nImages are represneted as 3d arays: every entry is a the intensity of a pixel (if the image is grayscale) or the intensity of a colour (e.g. red, green or blue) if the image is in colour.\n\n```{python}\nfrom skimage import data # importing images from a popular image library\n\nimage = data.camera() # a grayscale image\n\nplt.imshow(image, cmap='gray')  # display the image in grayscale\nplt.colorbar()\n```\n\nLet's take a colour image\n\n```{python}\ncolor_image = data.chelsea()\nplt.imshow(color_image)  # display the color image\n```\n\nThis is no longer just a 2d array, it has a third dimension for the colour channels (red, green, blue). We can access the individual colour channels by slicing the array along the third dimension.\n\n```{python}\ncolor_image.shape\n```\n\nWe can slice the array to get the various channels (notice that we specify the **colormap** `cmap` argument to display the channels in the appropriate colour):\n\n```{python}\nfig,ax = plt.subplots(1, 3, figsize=(15, 5))  # create a figure with 3 subplots\nax[0].imshow(color_image[:, :, 0], cmap='Reds')  # display the red channel\nax[0].set_title('Red Channel')\nax[1].imshow(color_image[:, :, 1], cmap='Greens')  # display the green channel\nax[1].set_title('Green Channel')\nax[2].imshow(color_image[:, :, 2], cmap='Blues')  # display the blue channel\nax[2].set_title('Blue Channel')\n```\n\n\nIf we want to subsample regions of an image, we can simply slice the array further in its rows and columns.\n\n```{python}\nplt.imshow(color_image[100:250, 100:, 1], cmap='Greens')  # display the green channel\n```\n\nWe can also use boolean indexing to filter the image based on conditions.\n\nFor example, we can binarise it by applying a threshold\n\n```{python}\ngreen = color_image[:,:,1]\n\nplt.imshow(green>100, cmap='gray')  # display a binary image where pixels with green channel value > 100 are white\n```\n\nWe can even perform logical operations using `numpy`\n\n- AND with `&`\n- OR with `|`\n- NOT with `~` or `np.logical_not`\n\n```{python}\ngreen = color_image[:,:,1]\nred = color_image[:,:,0]\nplt.imshow( (green>120) & (red>120) , cmap='gray')\n```\n\n```{python}\nplt.imshow(np.logical_not(green>100), cmap='gray')\n```\n\n## Pair programming\n\nThe following exercise will allow you explore multi-dimensional arrays by **working in pairs**. One person will write the code, while the other will explain what the code does. You can switch roles after each exercise.\n\nThere are two parts so, you can switch roles after each part.\n\n- [Part1](exercises_part1.qmd)\n- [Part2](exercises_part2.qmd)\n\n\n","srcMarkdownNoYaml":"\n\n\n\nA `numpy.ndarray` is the more complete term for a `numpy` `array` object. Up until this point we have mainly been dealing with and using one dimensional arrays. Numpy arrays (unlike lists) have the concept of shape whicih means they can be multi-dimensional. This means they can represent a grid (2D), a cuboid (3D) and so forth.\n\nThe code below generates a `numpy.array` object containing random numbers. This is a 2D array with a 3 x 3 shape:\n\n```{python}\nfrom numpy import random\n\nrng = random.default_rng(seed=24)\n```\n\n```{python}\nimport numpy as np\n\nshape = (3,3)\narray1 = rng.random(shape)\nprint(array1.shape)\nprint(array1)\n```\n\nWe can select one element from this array using the following syntax. We still use square brackets and pass an index value but now we can pass values for each dimension seperated by a comma (`,`). This index is selecting the third column within the second row:\n\n```{python}\nprint(array1[1, 2])\n```\n\nUsing slicing (*Start:Stop*) syntax you can select an entire dimension at once by omitting both the Start and Stop values and just using `:`. You can see how this works if you try the slice with just the Start or just the Stop e.g.\n\n```{python}\nprint(array1[:2])\nprint(array1[2:])\n```\n\nNot including a Start index includes values from the beginning of the array/list etc. up to (but not including) the Stop.\n\nNot including a Stop index reads from the Start to the end of the array/list etc.\n\nSo just using `:` with no Start or Stop selects all elements for that dimension.\n\nThis following syntax returns first row (first row, every column):\n\n```{python}\nprint(array1[0,:])\n```\n\nAnd this would return the first column (every row, first column):\n\n```{python}\nprint(array1[:,0])\n```\n\n`numpy` `array` objects store data in **row-major** order. Essentially this means for a 2D index this would be the equivalent of [y, x] rather than [x, y].\n\n## Basic properties of multi-dimensional arrays\n\n### Shape\n\nThe **shape** of a multi-dimensional array is a tuple that describes the size of each dimension. For example, a 2D array with 3 rows and 4 columns has a shape of `(3, 4)`. You can access the shape of an array using the `.shape` attribute.\n\nWe can use many of the array initialisation functions we haver seen for 1d arrays also to create multi-dimensional arrays. For example, we can use `np.zeros` to create a 2D array of zeros, or `np.ones` to create a 2D array of ones. We can also use `np.random.rand` to create a 2D array of random numbers.\n\n```{python}\narray_of_zeros = np.zeros(shape=(2, 3)) # 2 rows, 3 columns\n```\n\n```{python}\nnp.ones_like(array_of_zeros)\n```\n\n\n### Axis and Rank\n\nA multi-dimensional array has multiple dimensions, each of which can be thought of as an **axis**. The number of dimensions is called the **rank** of the array. For example, a 2D array has a rank of 2, while a 3D array has a rank of 3. It is accessible via the `.ndim` attribute.\n\nWe typically call a rank 2 array a **matrix**. A rank 3 array (or higher) is often called a **tensor**. \n\n```{python}\nrng = random.default_rng(seed=24)\nrandom_matrix = rng.uniform(-1,1,size=(2,5)) # random floats between -1 and 1, 2 rows, 5 columns\nrandom_matrix\n```\n\n```{python}\nrandom_matrix.ndim # two dimensions, rank 2, a matrix\n```\n\n```{python}\nrandom_tensor = rng.integers(0,3,size=(2,3,4)) # random integes in [0,3), 2x3x4 tensor\nrandom_tensor\n```\n\n```{python}\nrandom_tensor.ndim\n```\n\nWe can perform operations along specific axes of a multi-dimensional array. For example, we can sum all the elements along a specific axis using the `np.sum` function with the `axis` parameter.\n\n```{python}\nsmall_matrix = rng.integers(0,2,size=(3,2)) \nsmall_matrix\n```\n\n```{python}\nsmall_matrix.sum(axis=0) # sum along the first axis (rows)\n```\n\n```{python}\nsmall_matrix.sum(axis=1) # sum along the second axis (columns), can you explain the resulting shape?\n```\n\nOne can do the same also with useful statistical descriptors such as `np.mean`, `np.std`, etc.\n\n```{python}\nnp.mean(small_matrix, axis=0) # mean along the first axis (rows)\n```\n\n### Slicing\n\nSlicing works similarly to 1D arrays, but you can slice along multiple axes. For example, you can slice a 2D array to get a submatrix or a specific row or column.\n\n```{python}\nsmall_matrix[:, 0] # all rows, first column\n```\n\n```{python}\nsmall_matrix[:2,:] # first two rows, all columns\n```\n\n```{python}\nsmall_matrix[::-1,:1]\n```\n\n### Reshaping and flattening\n\nThe last example show an inetresting case: we extracted a single column from the matrix, but it is still a 2D array with shape `(3, 1)`.\n\n```{python}\nselection = small_matrix[::-1,:1]\n\nprint(\"shape\", selection.shape)\nprint(\"rank\", selection.ndim)\n```\n\nWhat if we wanted a truly 1d array (rank 1)? We need to **reshape** the array. \n\nWe can use the `np.reshape` function to change the shape of an array without changing its data. For example, we can reshape a 2D array into a 1D array or vice versa.\n\nReshape takes a tuple of the new shape as an argument. If you want to flatten an array (convert it to a 1D array), you can use `-1` as one of the dimensions, which tells NumPy to infer the size of that dimension based on the total number of elements.\n\n```{python}\nselection = small_matrix[::-1,:1]\nreshaped_selection = selection.reshape((3,))  # reshape to a 1D array excplicitly\nprint(\"reshaped shape\", reshaped_selection.shape)\nprint(\"reshaped rank\", reshaped_selection.ndim)\nprint(\"reshaped selection\", reshaped_selection)\n```\n\n```{python}\n#same code as above, but with inferred shape\nselection = small_matrix[::-1,:1]\nreshaped_selection = selection.reshape(-1)  # infererd shape\nprint(\"reshaped shape\", reshaped_selection.shape)\nprint(\"reshaped rank\", reshaped_selection.ndim)\nprint(\"reshaped selection\", reshaped_selection)\n```\n\nAnother way to cast a multi-dimensional array to a 1D array is to use the `np.ravel()` function, which returns a flattened view of the array (not a copy).\n\n```{python}\na_matrix = rng.integers(0,10,size=(2,3)) # random integers in [0,10), 2x3 matrix\nprint(\"Original matrix:\\n\", a_matrix)\nravelled_view = a_matrix.ravel()\nprint(\"Flattened view:\", ravelled_view)  # flatten the array to a 1D array\n```\n\nIf we modify the view, we modify the original array as well.\n\n```{python}\nravelled_view[0] = 100  # modify the view\nprint(\"Modified view:\", ravelled_view)  # the view is modified\nprint(\"Original array:\", a_matrix)  # the original array is modified as well\n```\n\nTo obtain a completely independent flattened copy of the array, you can use the `np.flatten()` method, which returns a copy of the array in a 1D format.\n\n```{python}\na_matrix = rng.integers(0,10,size=(2,3)) # random integers in [0,10), 2x3 matrix\nprint(\"The original:\\n\",a_matrix)\nflattened_copy = a_matrix.flatten()\nprint(\"Flattened:\",flattened_copy)  # flatten the array to a 1D array\nflattened_copy[0] = 100  # modify the copy\nprint(\"Flattened after modification:\",flattened_copy)  # the copy is modified\nprint(\"The original:\\n\",a_matrix)  # the original array is not modified\n```\n\nWe can also do the opposite and increase the rank of an array by reshaping it. For example, we can reshape a 1D array into a 2D array with one column or one row.\n\n```{python}\none_dimensional_array = rng.integers(0,10,size=(5,))  # random integers in [0,10), 1D array\nprint(\"One-dimensional array:\", one_dimensional_array)\nreshaped_array = one_dimensional_array.reshape((5,1))  # reshape to a  2D array with one column\nprint(\"Reshaped array:\\n\", reshaped_array)\n```\n\n### Broadcasting\n\nCombining arrays of different shapes is possible in NumPy using a feature called **broadcasting**. Broadcasting allows NumPy to perform operations on arrays of different shapes by automatically expanding the smaller array to match the shape of the larger one.\n\n```{python}\n# Minimal broadcasting example: rank 2 (matrix) with rank 1 (vector)\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6]])\nvector = np.array([10, 20, 30])\n\n# Broadcasting addition: vector is added to each row of the matrix\nresult = matrix + vector\nprint(\"Matrix:\\n\", matrix)\nprint(\"Vector:\", vector)\nprint(\"Result of broadcasting:\\n\", result)\n```\n\nYou can reshape a 1D array to a column or row vector and use broadcasting to expand it into a large table. For example, to create a table where each row is the original 1D array, or each column is the original array:\n\n```{python}\none_dimensional_array = np.linspace(1, 5, num=5)  # create a 1D array with 5 elements\nprint(\"One-dimensional array:\", one_dimensional_array)\n# Expand one_dimensional_array to a table with 5 rows and 5 columns\nrow_vector = one_dimensional_array.reshape(1, -1)  # shape (1, 5)\ncolumn_vector = one_dimensional_array.reshape(-1, 1)  # shape (5, 1)\n\n# Broadcasting to create a table\ntable = column_vector + row_vector\nprint(\"BroadcastedTable:\\n\",table)\n```\n\n## Two-dimensional arrays as matrices: some linear algebra\n\nTwo-dimensional arrays are often used to represent matrices or images. In a matrix, each element can be accessed using two indices: \n- one for the row \n- one for the column. \n\n\nA matrix is a rectangular array of numbers, symbols, or expressions arranged in rows and columns and is an essential concept in **linear algebra**.\n\nFor examplle, let's consider the simple system of simultaneous equations:\n\n$$ \\begin{align*}\n2x + 3y +z &= 5 \\\\\n4x - y &= 1 \\\\\n2y +z &= 3\n\\end{align*} $$\n\nThis can be represented in matrix form as:\n$$ \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n=\n\\begin{bmatrix}5 \\\\\n1\\\\\n3\n\\end{bmatrix} $$   \n\nAnd if we call $A$ the matrix of coefficients, $\\mathbf{x}$ the vector of variables, and $b$ the vector of constants, we can write this as:\n$$ A \\mathbf{x} = \\mathbf{b} $$\n\nwhere $$A = \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}, \\quad\n\\mathbf{x} = \\begin{bmatrix}\nx \\\\\ny\\\\\nz\n\\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix}\n5 \\\\\n1\\\\\n3\n\\end{bmatrix} $$            \n\nA key result of linear algebra is that if $A$ is invertible, we can solve for $\\mathbf{x}$ by multiplying both sides of the equation by the inverse of $A$:\n$$ \\mathbf{x} = A^{-1} \\mathbf{b} $$\n\nwhere $A^{-1}$ is the inverse of matrix $A$.\n\nNumPy has a dedicated linear algebra submodule called `numpy.linalg` that provides functions for performing various linear algebra operations, including matrix inversion, solving systems of equations, and computing eigenvalues and eigenvectors.\n\n\n```{python}\nA = np.array([[2, 3,1], [4, -1,0],[0,2,1]])\nb = np.array([[5], [1], [3]]) # we use double brackets to create a column vector\nprint(\"Matrix A:\\n\", A)\nprint(\"Vector b:\\n\", b)\n```\n\nThe linear algebra submodule has a function called `solve` which can be used to solve the above equation efficiently:\n\n```{python}\nx = np.linalg.solve(A, b)\n\nx\n```\n\nBut we can use numpy to verify that this is correct. We can use the symbol `@` to perform matrix multiplication in numpy. \n\n```{python}\nA @ x\n```\n\nWe can also directly calculate the inverse of a matrix using the `inv` function from the `numpy.linalg` and use it to solve the equation\n\n```{python}\nx = np.linalg.inv(A) @ b\n\nx\n```\n\nAll the most common linear algebra operations are available in the `numpy.linalg` submodule:\n\n- tranpose\n\n```{python}\nb.T\n```\n\n- scalar (dot) product (which takes two vectors and returns a scalar)\n\n```{python}\nnp.dot(b.T,b)\n```\n\n- cross product\n\n```{python}\nnp.cross(b.T, b.T) #takes row vectors and returns a row vector\n```\n\nLinear algebra applications are beyond the scope of this course (so, there will be **no assessment of these**), but they are widely used in various fields such as physics, computer science, and engineering. For example, they are essential in computer graphics for transformations, in machine learning for optimization, and in physics for solving systems of equations. So it is important for you to know that all these can be implemented efficiently using numpy.\n\n## Matrices as images\n\nA two-dimensional table of numbers can also be used to represent an image. Each number in the table corresponds to a pixel in the image, and the value of the number represents the color or intensity of that pixel.\n\n`matplotlib` provides a convenient way to visualize 2D arrays as images. The `matshow` function can be used to display a 2D matrix as an image, where the values in the array are mapped to colors.\n\n```{python}\nimport matplotlib.pyplot as plt\nplt.matshow(A)\nplt.colorbar()\nprint(A)\n```\n\nNotice that the indices of the y-axis increase as we go down. These are the indices of the rows in the matrix.\n\nFor a matrix of a given shape we can get the indices using the `np.indices` function, which returns a grid of indices for each dimension. This can be useful for creating masks or selecting specific regions of the matrix.\n\n```{python}\nrow_index, col_index = np.indices(A.shape)\nprint(\"Row indices:\\n\", row_index)\nprint(\"Column indices:\\n\", col_index)\n```\n\nAn alternative function is `imshow`, which is more general and can be used for both 2D arrays and images.\n\nHere we can set the origin of the axis:\n\n```{python}\nplt.imshow(A, origin='lower')  # origin='lower' to set the origin at the bottom left\n```\n\n```{python}\nplt.imshow(A, origin='upper')  # origin=\"upper\" to set the origin at the top left\n```\n\nThe main difference between `matshow` and `imshow` is that `matshow` is specifically designed for displaying matrices, while `imshow` is more general and can be used for both 2D arrays and images. `matshow` automatically adjusts the aspect ratio to make the matrix square, while `imshow` does not. Also the interpolation method used by `matshow` is different from that used by `imshow`, which can affect the appearance of the image.\n\nImages are represneted as 3d arays: every entry is a the intensity of a pixel (if the image is grayscale) or the intensity of a colour (e.g. red, green or blue) if the image is in colour.\n\n```{python}\nfrom skimage import data # importing images from a popular image library\n\nimage = data.camera() # a grayscale image\n\nplt.imshow(image, cmap='gray')  # display the image in grayscale\nplt.colorbar()\n```\n\nLet's take a colour image\n\n```{python}\ncolor_image = data.chelsea()\nplt.imshow(color_image)  # display the color image\n```\n\nThis is no longer just a 2d array, it has a third dimension for the colour channels (red, green, blue). We can access the individual colour channels by slicing the array along the third dimension.\n\n```{python}\ncolor_image.shape\n```\n\nWe can slice the array to get the various channels (notice that we specify the **colormap** `cmap` argument to display the channels in the appropriate colour):\n\n```{python}\nfig,ax = plt.subplots(1, 3, figsize=(15, 5))  # create a figure with 3 subplots\nax[0].imshow(color_image[:, :, 0], cmap='Reds')  # display the red channel\nax[0].set_title('Red Channel')\nax[1].imshow(color_image[:, :, 1], cmap='Greens')  # display the green channel\nax[1].set_title('Green Channel')\nax[2].imshow(color_image[:, :, 2], cmap='Blues')  # display the blue channel\nax[2].set_title('Blue Channel')\n```\n\n\nIf we want to subsample regions of an image, we can simply slice the array further in its rows and columns.\n\n```{python}\nplt.imshow(color_image[100:250, 100:, 1], cmap='Greens')  # display the green channel\n```\n\nWe can also use boolean indexing to filter the image based on conditions.\n\nFor example, we can binarise it by applying a threshold\n\n```{python}\ngreen = color_image[:,:,1]\n\nplt.imshow(green>100, cmap='gray')  # display a binary image where pixels with green channel value > 100 are white\n```\n\nWe can even perform logical operations using `numpy`\n\n- AND with `&`\n- OR with `|`\n- NOT with `~` or `np.logical_not`\n\n```{python}\ngreen = color_image[:,:,1]\nred = color_image[:,:,0]\nplt.imshow( (green>120) & (red>120) , cmap='gray')\n```\n\n```{python}\nplt.imshow(np.logical_not(green>100), cmap='gray')\n```\n\n## Pair programming\n\nThe following exercise will allow you explore multi-dimensional arrays by **working in pairs**. One person will write the code, while the other will explain what the code does. You can switch roles after each exercise.\n\nThere are two parts so, you can switch roles after each part.\n\n- [Part1](exercises_part1.qmd)\n- [Part2](exercises_part2.qmd)\n\n\n"},"formats":{"live-html":{"identifier":{"display-name":"HTML","target-format":"live-html","base-format":"html","extension-name":"live"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":true,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true,"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["/Users/ft14968/Repos/intro-coding-data-analysis/quarto/_extensions/r-wasm/live/live.lua"],"include-in-header":{"text":"<meta name=\"robots\" content=\"noindex, nofollow\">\n"},"css":["../styles.css"],"toc":true,"toc-depth":3,"highlight-style":"github","number-sections":false,"output-file":"lecture_multidimensionalArrays.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","ojs-engine":true,"revealjs-plugins":[],"theme":"cosmo","toc-location":"right","code-copy":true,"grid":{"sidebar-width":"350px"},"title":"Multi-dimensional arrays","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["live-html"]}