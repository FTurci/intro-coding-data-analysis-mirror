{
  "hash": "66c7c6c3efa5173544d99254b70d7eba",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Working with NumPy: Indexing and Random Data'\nformat: \n  revealjs:\n    theme: default\n    highlight-style: github\n    code-block-bg: true\n    code-block-border-left: \"#31BAE9\"\n    code-copy: true\n    code-overflow: wrap\nexecute:\n  echo: true\n  eval: true\n  warning: false\n---\n\n## Array Indexing & Slicing\n\n::: {#17366494 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\narr = np.array([10, 20, 30, 40, 50])\n\n# Integer indexing\nprint(\"Element at index 1:\", arr[1])\n\n# Basic slicing\nprint(\"Slice [1:4]:\", arr[1:4])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nElement at index 1: 20\nSlice [1:4]: [20 30 40]\n```\n:::\n:::\n\n\n**Advanced slicing:**\n\n::: {#ed25d4b5 .cell execution_count=2}\n``` {.python .cell-code}\nprint(\"Every other element:\", arr[::2])\nprint(\"Last three elements:\", arr[-3:])\nprint(\"Reversed array:\", arr[::-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEvery other element: [10 30 50]\nLast three elements: [30 40 50]\nReversed array: [50 40 30 20 10]\n```\n:::\n:::\n\n\n---\n\n## Views vs Copies\n\n**Slicing creates views (shared data):**\n\n::: {#4fb66614 .cell execution_count=3}\n``` {.python .cell-code}\nslice_view = arr[2:5]\nslice_view[0] = 99\nprint(\"Original after view modification:\", arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal after view modification: [10 20 99 40 50]\n```\n:::\n:::\n\n\n**Creating independent copies:**\n\n::: {#d94376f1 .cell execution_count=4}\n``` {.python .cell-code}\narr = np.array([10, 20, 30, 40, 50])  # Reset\narr_copy = arr[2:5].copy()\narr_copy[0] = 100\nprint(\"Copy:\", arr_copy)\nprint(\"Original unchanged:\", arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCopy: [100  40  50]\nOriginal unchanged: [10 20 30 40 50]\n```\n:::\n:::\n\n\n---\n\n## Boolean Indexing\n\n**Filter data with conditions:**\n\n::: {#d72e9356 .cell execution_count=5}\n``` {.python .cell-code}\narr = np.array([1, 2, 3, 4, 5, 6])\nthreshold = 3\n\nbool_mask = arr > threshold\nprint(\"Boolean mask:\", bool_mask)\nprint(\"Filtered values:\", arr[bool_mask])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBoolean mask: [False False False  True  True  True]\nFiltered values: [4 5 6]\n```\n:::\n:::\n\n\n**Using `np.where`:**\n\n::: {#655453df .cell execution_count=6}\n``` {.python .cell-code}\n# Get indices where condition is True\nindices = np.where(arr > threshold)[0]\nprint(\"Indices:\", indices)\n\n# Conditional selection\nresult = np.where(arr > 3, arr, 0)\nprint(\"Conditional result:\", result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndices: [3 4 5]\nConditional result: [0 0 0 4 5 6]\n```\n:::\n:::\n\n\n---\n\n## Generating Sequences\n\n**`np.arange` - step-based:**\n\n::: {#f137ee97 .cell execution_count=7}\n``` {.python .cell-code}\nprint(\"Integers:\", np.arange(0, 10, 2))\nprint(\"Floats:\", np.arange(0.0, 1.0, 0.2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIntegers: [0 2 4 6 8]\nFloats: [0.  0.2 0.4 0.6 0.8]\n```\n:::\n:::\n\n\n**`np.linspace` - count-based:**\n\n::: {#bb5dacb4 .cell execution_count=8}\n``` {.python .cell-code}\nprint(\"5 points from 0 to 1:\", np.linspace(0, 1, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 points from 0 to 1: [0.   0.25 0.5  0.75 1.  ]\n```\n:::\n:::\n\n\n- **`arange`**: Use when you know the step size\n- **`linspace`**: Use when you know the number of points\n\n---\n\n## Filled Arrays\n\n::: {#a8d893b2 .cell execution_count=9}\n``` {.python .cell-code}\n# Create arrays with specific values\nzeros_arr = np.zeros(5)\nones_arr = np.ones(4)\nfull_arr = np.full(3, 7)\n\nprint(\"Zeros:\", zeros_arr)\nprint(\"Ones:\", ones_arr)\nprint(\"Full:\", full_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nZeros: [0. 0. 0. 0. 0.]\nOnes: [1. 1. 1. 1.]\nFull: [7 7 7]\n```\n:::\n:::\n\n\n**Same shape as existing array:**\n\n::: {#8bcb013b .cell execution_count=10}\n``` {.python .cell-code}\ntemplate = np.array([1, 2, 3])\nprint(\"Zeros like:\", np.zeros_like(template))\nprint(\"Ones like:\", np.ones_like(template))\nprint(\"Full like:\", np.full_like(template, 9))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nZeros like: [0 0 0]\nOnes like: [1 1 1]\nFull like: [9 9 9]\n```\n:::\n:::\n\n\n---\n\n## Random Number Generation\n\n**Initialize generator (for reproducibility):**\n\n::: {#f237fc9c .cell execution_count=11}\n``` {.python .cell-code}\nrng = np.random.default_rng(seed=123)\n```\n:::\n\n\n**Different distributions:**\n\n::: {#933a2238 .cell execution_count=12}\n``` {.python .cell-code}\n# Random integers\nprint(\"Random integers:\", rng.integers(0, 100, size=5))\n\n# Uniform floats [0, 1)\nprint(\"Uniform [0,1):\", rng.random(5))\n\n# Normal distribution\nnormal_samples = rng.normal(loc=0, scale=1, size=5)\nprint(\"Normal samples:\", normal_samples)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRandom integers: [ 1 68 59  5 90]\nUniform [0,1): [0.18437181 0.1759059  0.81209451 0.923345   0.2765744 ]\nNormal samples: [-0.31659545 -0.32238912  0.09716732 -1.52593041  1.1921661 ]\n```\n:::\n:::\n\n\n---\n\n## Pseudo-Random Numbers\n\n**Computers are deterministic** - they use algorithms to generate \"pseudo-random\" sequences\n\n**Linear Congruential Generator example:**\n$$x_{n+1} = (a \\times x_n + c) \\bmod m$$\n\n**Key concept: Seeds enable reproducibility**\n\n::: {#c06e4fb9 .cell execution_count=13}\n``` {.python .cell-code}\n# Same seed = same sequence\nrng1 = np.random.default_rng(seed=42)\nrng2 = np.random.default_rng(seed=42)\n\nprint(\"RNG1:\", rng1.integers(0, 10, size=3))\nprint(\"RNG2:\", rng2.integers(0, 10, size=3))  # Same output!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRNG1: [0 7 6]\nRNG2: [0 7 6]\n```\n:::\n:::\n\n\n---\n\n## Performance Tips\n\n**Preallocate for efficiency:**\n\n::: {#f2ec43f7 .cell execution_count=14}\n``` {.python .cell-code}\n# Less efficient: generate one at a time\n# for _ in range(1000):\n#     val = rng.integers(0, 100)\n\n# More efficient: preallocate\nprealloc = rng.integers(0, 100, size=1000)\n# Then use values from prealloc array\n```\n:::\n\n\n**Memory vs Speed tradeoff:**\n- Small tasks: 100-1,000 elements\n- Medium tasks: 10,000-100,000 elements  \n- Large tasks: 1,000,000+ elements\n\n---\n\n## Key Takeaways\n\n- **Views** share data, **copies** are independent\n- **Boolean indexing** enables powerful data filtering\n- **`arange` vs `linspace`** serve different use cases\n- **Random generators** need seeds for reproducibility\n- **Preallocating** arrays improves performance\n- Choose **array generation method** based on your needs\n\n",
    "supporting": [
      "08_working_numpy_slides_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}