{
  "hash": "b474d4f763670991987165608933083b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Multi-dimensional Arrays'\nformat: \n  revealjs:\n    theme: default\n    highlight-style: github\n    code-block-bg: true\n    code-block-border-left: \"#31BAE9\"\n    code-copy: true\n    code-overflow: wrap\nexecute:\n  echo: true\n  eval: true\n  warning: false\n  fig-width: 8\n  fig-height: 5\n---\n\n## NumPy Arrays Beyond 1D\n\n**Multi-dimensional arrays** enable representation of:\n- **2D**: Grid/Matrix (rows × columns)\n- **3D**: Cuboid/Tensor (depth × rows × columns)\n- **nD**: Higher dimensions\n\n::: {#1d549275 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nfrom numpy import random\nrng = random.default_rng(seed=24)\n\n# 2D array (3×3 matrix)\narray_2d = rng.random((3, 3))\nprint(f\"Shape: {array_2d.shape}\")\nprint(array_2d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nShape: (3, 3)\n[[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]\n [0.87411653 0.08643046 0.74247527]]\n```\n:::\n:::\n\n\n---\n\n## Indexing Multi-dimensional Arrays\n\n**Row-major order**: `[row, column]` (like `[y, x]`)\n\n::: {#b1476cdc .cell execution_count=2}\n``` {.python .cell-code}\n# Access single element\nprint(\"Element at [1,2]:\", array_2d[1, 2])\n\n# Access entire row\nprint(\"First row:\", array_2d[0, :])\n\n# Access entire column  \nprint(\"First column:\", array_2d[:, 0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nElement at [1,2]: 0.5696873105084019\nFirst row: [0.33026884 0.40517732 0.57473782]\nFirst column: [0.33026884 0.50639977 0.87411653]\n```\n:::\n:::\n\n\n**Slicing works with multiple dimensions:**\n\n::: {#39a8e651 .cell execution_count=3}\n``` {.python .cell-code}\nprint(\"First 2 rows:\\n\", array_2d[:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFirst 2 rows:\n [[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]]\n```\n:::\n:::\n\n\n---\n\n## Array Properties\n\n::: {#d4ed08a5 .cell execution_count=4}\n``` {.python .cell-code}\n# Creating arrays with different shapes\nzeros_2d = np.zeros((2, 3))  # 2 rows, 3 columns\nrandom_3d = rng.integers(0, 3, size=(2, 3, 4))  # 2×3×4 tensor\n\nprint(\"2D shape:\", zeros_2d.shape)\nprint(\"3D shape:\", random_3d.shape)\nprint(\"3D rank/dimensions:\", random_3d.ndim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2D shape: (2, 3)\n3D shape: (2, 3, 4)\n3D rank/dimensions: 3\n```\n:::\n:::\n\n\n**Terminology:**\n- **Rank/ndim**: Number of dimensions\n- **Matrix**: Rank 2 array\n- **Tensor**: Rank 3+ array\n\n---\n\n## Operations Along Axes\n\n**Axis-specific operations:**\n\n::: {#05e9a32b .cell execution_count=5}\n``` {.python .cell-code}\nmatrix = rng.integers(0, 5, size=(3, 4))\nprint(\"Original matrix:\\n\", matrix)\n\nprint(\"Sum along axis 0 (columns):\", matrix.sum(axis=0))\nprint(\"Sum along axis 1 (rows):\", matrix.sum(axis=1))\nprint(\"Mean along axis 0:\", np.mean(matrix, axis=0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal matrix:\n [[0 2 4 3]\n [4 1 4 0]\n [2 3 4 3]]\nSum along axis 0 (columns): [ 6  6 12  6]\nSum along axis 1 (rows): [ 9  9 12]\nMean along axis 0: [2. 2. 4. 2.]\n```\n:::\n:::\n\n\n**Axis 0**: Operations across rows (result has column shape)  \n**Axis 1**: Operations across columns (result has row shape)\n\n---\n\n## Reshaping and Flattening\n\n**Reshape without changing data:**\n\n::: {#acc989d2 .cell execution_count=6}\n``` {.python .cell-code}\narr_1d = np.arange(12)\narr_2d = arr_1d.reshape((3, 4))\narr_3d = arr_1d.reshape((2, 2, 3))\n\nprint(\"1D:\", arr_1d)\nprint(\"2D (3×4):\\n\", arr_2d)\nprint(\"3D shape:\", arr_3d.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1D: [ 0  1  2  3  4  5  6  7  8  9 10 11]\n2D (3×4):\n [[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n3D shape: (2, 2, 3)\n```\n:::\n:::\n\n\n**Using `-1` for automatic dimension:**\n\n::: {#895e26df .cell execution_count=7}\n``` {.python .cell-code}\n# -1 means \"figure out this dimension\"\nauto_reshape = arr_1d.reshape(-1, 4)  # ? rows, 4 columns\nprint(\"Auto-reshaped:\\n\", auto_reshape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAuto-reshaped:\n [[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n```\n:::\n:::\n\n\n---\n\n## Flattening Arrays\n\n**`ravel()` - returns view (shares data):**\n\n::: {#32f323a0 .cell execution_count=8}\n``` {.python .cell-code}\nmatrix = rng.integers(0, 10, (2, 3))\nprint(\"Original:\\n\", matrix)\n\nview = matrix.ravel()\nview[0] = 99  # Changes original!\nprint(\"After modifying view:\\n\", matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal:\n [[7 0 4]\n [4 7 4]]\nAfter modifying view:\n [[99  0  4]\n [ 4  7  4]]\n```\n:::\n:::\n\n\n**`flatten()` - returns copy:**\n\n::: {#dc622313 .cell execution_count=9}\n``` {.python .cell-code}\nmatrix = rng.integers(0, 10, (2, 3))\ncopy = matrix.flatten()\ncopy[0] = 99  # Original unchanged\nprint(\"Original unchanged:\\n\", matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal unchanged:\n [[6 9 5]\n [5 5 3]]\n```\n:::\n:::\n\n\n---\n\n## Broadcasting\n\n**Combine arrays of different shapes automatically:**\n\n::: {#ac6a685d .cell execution_count=10}\n``` {.python .cell-code}\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6]])\nvector = np.array([10, 20, 30])\n\n# Vector is broadcast to each row\nresult = matrix + vector\nprint(\"Matrix + Vector:\\n\", result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMatrix + Vector:\n [[11 22 33]\n [14 25 36]]\n```\n:::\n:::\n\n\n**Create grids with broadcasting:**\n\n::: {#8d596a10 .cell execution_count=11}\n``` {.python .cell-code}\nrow_vec = np.arange(3).reshape(1, -1)    # Shape: (1, 3)\ncol_vec = np.arange(3).reshape(-1, 1)    # Shape: (3, 1)\ngrid = row_vec + col_vec                 # Shape: (3, 3)\nprint(\"Broadcast grid:\\n\", grid)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBroadcast grid:\n [[0 1 2]\n [1 2 3]\n [2 3 4]]\n```\n:::\n:::\n\n\n---\n\n## Linear Algebra with NumPy\n\n**Matrix operations for solving systems:**\n$$A\\mathbf{x} = \\mathbf{b}$$\n\n::: {#e4fd162a .cell execution_count=12}\n``` {.python .cell-code}\n# System: 2x + 3y + z = 5, 4x - y = 1, 2y + z = 3\nA = np.array([[2, 3, 1], \n              [4, -1, 0], \n              [0, 2, 1]])\nb = np.array([[5], [1], [3]])\n\n# Solve the system\nx = np.linalg.solve(A, b)\nprint(\"Solution:\", x.flatten())\n\n# Verify: A @ x should equal b\nprint(\"Verification:\\n\", A @ x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSolution: [0.5 1.  1. ]\nVerification:\n [[5.]\n [1.]\n [3.]]\n```\n:::\n:::\n\n\n---\n\n## Linear Algebra Operations\n\n::: {#54b5ff51 .cell execution_count=13}\n``` {.python .cell-code}\n# Matrix multiplication with @\nresult = A @ x\n\n# Transpose with .T\nprint(\"b transpose:\", b.T)\n\n# Dot product\ndot_product = np.dot(b.T, b)\nprint(\"Dot product:\", dot_product)\n\n# Matrix inverse\nA_inv = np.linalg.inv(A)\nx_alt = A_inv @ b  # Alternative solution method\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nb transpose: [[5 1 3]]\nDot product: [[35]]\n```\n:::\n:::\n\n\n**NumPy.linalg provides:** inverse, solve, eigenvalues, SVD, etc.\n\n---\n\n## Arrays as Images\n\n**Visualize 2D arrays as images:**\n\n::: {#1e542d43 .cell execution_count=14}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# Simple matrix visualization\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\n\nax1.matshow(matrix)\nax1.set_title('matshow')\n\nax2.imshow(matrix, origin='lower')\nax2.set_title('imshow (origin=lower)')\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nText(0.5, 1.0, 'imshow (origin=lower)')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](10_multidimensional_arrays_slides_files/figure-revealjs/cell-15-output-2.png){}\n:::\n:::\n\n\n---\n\n## Working with Real Images\n\n::: {#3bf3b7e9 .cell execution_count=15}\n``` {.python .cell-code}\nfrom skimage import data\n\n# Grayscale image\ngray_image = data.camera()\nprint(\"Image shape:\", gray_image.shape)\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(gray_image, cmap='gray')\nax.set_title('Grayscale Image')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nImage shape: (512, 512)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nText(0.5, 1.0, 'Grayscale Image')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](10_multidimensional_arrays_slides_files/figure-revealjs/cell-16-output-3.png){}\n:::\n:::\n\n\n**Images are arrays:** Each pixel is a number (intensity)\n\n---\n\n## Color Images (3D Arrays)\n\n::: {#d519621a .cell execution_count=16}\n``` {.python .cell-code}\n# Color image has 3 channels: RGB\ncolor_image = data.chelsea()\nprint(\"Color image shape:\", color_image.shape)\n\nfig, axes = plt.subplots(1, 4, figsize=(15, 4))\n\naxes[0].imshow(color_image)\naxes[0].set_title('Full Color')\n\n# Individual color channels\nchannels = ['Reds', 'Greens', 'Blues']\ntitles = ['Red Channel', 'Green Channel', 'Blue Channel']\n\nfor i, (cmap, title) in enumerate(zip(channels, titles)):\n    axes[i+1].imshow(color_image[:, :, i], cmap=cmap)\n    axes[i+1].set_title(title)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nColor image shape: (300, 451, 3)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](10_multidimensional_arrays_slides_files/figure-revealjs/cell-17-output-2.png){}\n:::\n:::\n\n\n---\n\n## Boolean Operations on Images\n\n::: {#d793a03b .cell execution_count=17}\n``` {.python .cell-code}\n# Extract green channel\ngreen = color_image[:, :, 1]\n\n# Create binary mask\nthreshold_mask = green > 120\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n\nax1.imshow(green, cmap='Greens')\nax1.set_title('Green Channel')\n\nax2.imshow(threshold_mask, cmap='gray')\nax2.set_title('Thresholded (>120)')\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nText(0.5, 1.0, 'Thresholded (>120)')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](10_multidimensional_arrays_slides_files/figure-revealjs/cell-18-output-2.png){}\n:::\n:::\n\n\n**Logical operations:** `&` (AND), `|` (OR), `~` (NOT)\n\n---\n\n## Key Takeaways\n\n- **Multi-dimensional arrays** represent grids, images, tensors\n- **Indexing**: `[row, col]` for 2D arrays\n- **Axis operations** reduce along specific dimensions\n- **Reshaping** changes shape without changing data\n- **Broadcasting** enables operations on different shapes\n- **Linear algebra** operations available in `np.linalg`\n- **Images** are just arrays of pixel values\n- **Boolean indexing** works on multi-dimensional arrays\n\n",
    "supporting": [
      "10_multidimensional_arrays_slides_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}