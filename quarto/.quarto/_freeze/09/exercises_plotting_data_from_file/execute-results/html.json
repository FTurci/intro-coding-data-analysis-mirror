{
  "hash": "ea578ec5512b49692459c1925d0cc216",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Plotting data from file\njupyter: python3\n---\n\n\n\nHow can we use what we have learnt in the past few workshops to read data from a file? And how can we plot this?\n\nOne way to then plot this data would be to extract the index and/or multiple columns we are interested in plotting and use `matplotlib` as we have done before.\n\nAs an example, we'll look at a new data file. This contains a simulation of the (fractional) concentration change for two species in a reaction, \"A\" and \"B\" where $A \\rightarrow B$.\n\n::: {#7fef35d8 .cell execution_count=1}\n``` {.python .cell-code}\ndata_filename = \"data/FIRST ORDER_k=0.0005.txt\"\n```\n:::\n\n\nIf we open this file more directly in Python when we looked at a text file) we can take quick look at the contents to see what this looks like:\n\n::: {#034e4ccb .cell execution_count=2}\n``` {.python .cell-code}\nopen_file = open(data_filename)\ndata_from_file = open_file.read()\nprint(data_from_file[0:200])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime\tA\tB\t\n0\t1\t0\t\n100\t0.950565\t0.0494353\t\n200\t0.903573\t0.0964268\t\n300\t0.858905\t0.141095\t\n400\t0.816445\t0.183555\t\n500\t0.776083\t0.223917\t\n600\t0.737717\t0.262283\t\n700\t0.701248\t0.298752\t\n800\t0.666582\t0.33341\n```\n:::\n:::\n\n\nFrom printing out the first 200 characters, we can see this looks like a table of data with each column separated by spaces. This looks nicely formatted with a title row including the column names and no extra header rows.\n\nWe will see in the next year that there are dedicate packages to manipulate large tabulated files. However, for now we can exploit `numpy` as a quick and effective way to read such input.\n\n::: {#90e80f23 .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\n\ndata_kinetic_k0005 = np.genfromtxt(\"data/FIRST ORDER_k=0.0005.txt\", names=True)\n```\n:::\n\n\nThis is a special kind of array called a **structured** array, because it has **named fields**. You can check this by querying the subproperties of the array:\n\n::: {#f4a6247b .cell execution_count=4}\n``` {.python .cell-code}\ndata_kinetic_k0005.dtype.names\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n('Time', 'A', 'B')\n```\n:::\n:::\n\n\nThese various **names are the fields** of the array, corresponding to the columns in the file. This syntax is reminiscent of what we have seen in the case of **dictionaries**, where **keys** are used to specific other objects stored in the dictionary.\n\n::: {#699230ac .cell execution_count=5}\n``` {.python .cell-code}\ndata_kinetic_k0005['A']\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\narray([1.        , 0.950565  , 0.903573  , 0.858905  , 0.816445  ,\n       0.776083  , 0.737717  , 0.701248  , 0.666582  , 0.633629  ,\n       0.602305  , 0.57253   , 0.544227  , 0.517323  , 0.491749  ,\n       0.467439  , 0.444331  , 0.422365  , 0.401486  , 0.381638  ,\n       0.362772  , 0.344838  , 0.327791  , 0.311586  , 0.296183  ,\n       0.281541  , 0.267623  , 0.254393  , 0.241817  , 0.229863  ,\n       0.218499  , 0.207698  , 0.19743   , 0.18767   , 0.178393  ,\n       0.169574  , 0.161191  , 0.153222  , 0.145648  , 0.138447  ,\n       0.131603  , 0.125097  , 0.118913  , 0.113035  , 0.107447  ,\n       0.102135  , 0.097086  , 0.0922865 , 0.0877243 , 0.0833876 ,\n       0.0792653 , 0.0753468 , 0.071622  , 0.0680813 , 0.0647157 ,\n       0.0615165 , 0.0584754 , 0.0555846 , 0.0528368 , 0.0502248 ,\n       0.0477419 , 0.0453818 , 0.0431383 , 0.0410057 , 0.0389786 ,\n       0.0370517 , 0.03522   , 0.0334789 , 0.0318239 , 0.0302506 ,\n       0.0287552 , 0.0273337 , 0.0259824 , 0.024698  , 0.023477  ,\n       0.0223164 , 0.0212132 , 0.0201645 , 0.0191677 , 0.0182201 ,\n       0.0173194 , 0.0164632 , 0.0156493 , 0.0148757 , 0.0141403 ,\n       0.0134413 , 0.0127768 , 0.0121452 , 0.0115448 , 0.0109741 ,\n       0.0104316 , 0.00991587, 0.00942568, 0.00895972, 0.00851679,\n       0.00809576, 0.00769554, 0.00731511, 0.00695349, 0.00660974,\n       0.00628298])\n```\n:::\n:::\n\n\nThis data also has a column for \"Time\" as the number of seconds elapsed.\n\n::: {#8a1b37a8 .cell execution_count=6}\n``` {.python .cell-code}\ndata_kinetic_k0005 ['Time']\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([    0.,   100.,   200.,   300.,   400.,   500.,   600.,   700.,\n         800.,   900.,  1000.,  1100.,  1200.,  1300.,  1400.,  1500.,\n        1600.,  1700.,  1800.,  1900.,  2000.,  2100.,  2200.,  2300.,\n        2400.,  2500.,  2600.,  2700.,  2800.,  2900.,  3000.,  3100.,\n        3200.,  3300.,  3400.,  3500.,  3600.,  3700.,  3800.,  3900.,\n        4000.,  4100.,  4200.,  4300.,  4400.,  4500.,  4600.,  4700.,\n        4800.,  4900.,  5000.,  5100.,  5200.,  5300.,  5400.,  5500.,\n        5600.,  5700.,  5800.,  5900.,  6000.,  6100.,  6200.,  6300.,\n        6400.,  6500.,  6600.,  6700.,  6800.,  6900.,  7000.,  7100.,\n        7200.,  7300.,  7400.,  7500.,  7600.,  7700.,  7800.,  7900.,\n        8000.,  8100.,  8200.,  8300.,  8400.,  8500.,  8600.,  8700.,\n        8800.,  8900.,  9000.,  9100.,  9200.,  9300.,  9400.,  9500.,\n        9600.,  9700.,  9800.,  9900., 10000.])\n```\n:::\n:::\n\n\nTo create a plot for **time** vs **concentration of A**, we can extract this data from our array\n\n::: {#4b9e419d .cell execution_count=7}\n``` {.python .cell-code}\n# Extract time and concentration of A from our array\ntime = data_kinetic_k0005['Time']\nconcentration_A = data_kinetic_k0005[\"A\"]\n```\n:::\n\n\nWe could then use matplotlib to plot this:\n\n::: {#de844d6e .cell execution_count=8}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# Create our Figure and Axes objects for plotting\nfig, ax = plt.subplots()\n\n# Plot our data - time vs concentration of A\nax.plot(time, concentration_A)\n\n# Add x and y labels for this data\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Concentration\")\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nText(0, 0.5, 'Concentration')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](exercises_plotting_data_from_file_files/figure-html/cell-9-output-2.png){}\n:::\n:::\n\n\nThis simulation shows a clean relationship as concentration decreases over time (in an exponential way).\n\nSuppose we want to filter our data and plot only concentrations less than 0.5. We can simply create a **boolean** array that masks the invalid data.\n\n::: {#34d033f5 .cell execution_count=9}\n``` {.python .cell-code}\nmask = concentration_A <= 0.5\nconcentration_A_low = concentration_A[mask]\n# Make sure to match the time values (index) to our filtered data\ntime_low = time[mask]\n```\n:::\n\n\nHere we have filtered our data to include all fractional concentrations less than (or equal to) 0.5. Notice we have also matched our time values to plot to these concentrations by extracting the index from our new array `concentration_A_low`.\n\n::: {#e932ca6d .cell execution_count=10}\n``` {.python .cell-code}\n# Create our Figure and Axes objects for plotting\nfig, ax = plt.subplots()\n\n# Plot our data - time vs concentration of A\nax.plot(time_low, concentration_A_low)\n\n# Note: Alternative syntax! we can set multiple properties at once\nax.set(xlabel = \"Time (s)\",  ylabel=\"Concentration\")\n```\n\n::: {.cell-output .cell-output-display}\n![](exercises_plotting_data_from_file_files/figure-html/cell-11-output-1.png){}\n:::\n:::\n\n\nYou can also see the slope is similiar (in fact it is the same) between our unfiltered and filtered data (this is due to the exponential relationship).\n\n---\n\n### Exercise \n\n 1. Re-plot the un-filtered graph created above and add another line to show **concentration of B** vs **time**  from the `data_kinetic_k0005` array on the same plot. \n  - Can you include a label for A and B?\n\n\n2. Calculate the the sum of the concentrations for these two columns (A and B).\n\n\n3. Re-plot the graph created in the previous question and add this sum as a third line.\n\n - Consider: What does this sum tell us about \"A\" is decaying into \"B\"?\n\n",
    "supporting": [
      "exercises_plotting_data_from_file_files"
    ],
    "filters": [],
    "includes": {}
  }
}