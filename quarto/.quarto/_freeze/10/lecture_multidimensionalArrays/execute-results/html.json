{
  "hash": "4fe9f9e17224820b4dc38c4221f82efc",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Multi-dimensional arrays\njupyter: python3\n---\n\n\n\nA `numpy.ndarray` is the more complete term for a `numpy` `array` object. Up until this point we have mainly been dealing with and using one dimensional arrays. Numpy arrays (unlike lists) have the concept of shape whicih means they can be multi-dimensional. This means they can represent a grid (2D), a cuboid (3D) and so forth.\n\nThe code below generates a `numpy.array` object containing random numbers. This is a 2D array with a 3 x 3 shape:\n\n::: {#d13ac5f1 .cell execution_count=2}\n``` {.python .cell-code}\nfrom numpy import random\n\nrng = random.default_rng(seed=24)\n```\n:::\n\n\n::: {#6175dd38 .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\n\nshape = (3,3)\narray1 = rng.random(shape)\nprint(array1.shape)\nprint(array1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(3, 3)\n[[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]\n [0.87411653 0.08643046 0.74247527]]\n```\n:::\n:::\n\n\nWe can select one element from this array using the following syntax. We still use square brackets and pass an index value but now we can pass values for each dimension seperated by a comma (`,`). This index is selecting the third column within the second row:\n\n::: {#6f7604f0 .cell execution_count=4}\n``` {.python .cell-code}\nprint(array1[1, 2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.5696873105084019\n```\n:::\n:::\n\n\nUsing slicing (*Start:Stop*) syntax you can select an entire dimension at once by omitting both the Start and Stop values and just using `:`. You can see how this works if you try the slice with just the Start or just the Stop e.g.\n\n::: {#86da96e6 .cell execution_count=5}\n``` {.python .cell-code}\nprint(array1[:2])\nprint(array1[2:])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]]\n[[0.87411653 0.08643046 0.74247527]]\n```\n:::\n:::\n\n\nNot including a Start index includes values from the beginning of the array/list etc. up to (but not including) the Stop.\n\nNot including a Stop index reads from the Start to the end of the array/list etc.\n\nSo just using `:` with no Start or Stop selects all elements for that dimension.\n\nThis following syntax returns first row (first row, every column):\n\n::: {#0ad205a7 .cell execution_count=6}\n``` {.python .cell-code}\nprint(array1[0,:])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.33026884 0.40517732 0.57473782]\n```\n:::\n:::\n\n\nAnd this would return the first column (every row, first column):\n\n::: {#40fc9c44 .cell execution_count=7}\n``` {.python .cell-code}\nprint(array1[:,0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.33026884 0.50639977 0.87411653]\n```\n:::\n:::\n\n\n`numpy` `array` objects store data in **row-major** order. Essentially this means for a 2D index this would be the equivalent of [y, x] rather than [x, y].\n\n## Basic properties of multi-dimensional arrays\n\n### Shape\n\nThe **shape** of a multi-dimensional array is a tuple that describes the size of each dimension. For example, a 2D array with 3 rows and 4 columns has a shape of `(3, 4)`. You can access the shape of an array using the `.shape` attribute.\n\nWe can use many of the array initialisation functions we haver seen for 1d arrays also to create multi-dimensional arrays. For example, we can use `np.zeros` to create a 2D array of zeros, or `np.ones` to create a 2D array of ones. We can also use `np.random.rand` to create a 2D array of random numbers.\n\n::: {#77b5c097 .cell execution_count=8}\n``` {.python .cell-code}\narray_of_zeros = np.zeros(shape=(2, 3)) # 2 rows, 3 columns\n```\n:::\n\n\n::: {#da9feee4 .cell execution_count=9}\n``` {.python .cell-code}\nnp.ones_like(array_of_zeros)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([[1., 1., 1.],\n       [1., 1., 1.]])\n```\n:::\n:::\n\n\n### Axis and Rank\n\nA multi-dimensional array has multiple dimensions, each of which can be thought of as an **axis**. The number of dimensions is called the **rank** of the array. For example, a 2D array has a rank of 2, while a 3D array has a rank of 3. It is accessible via the `.ndim` attribute.\n\nWe typically call a rank 2 array a **matrix**. A rank 3 array (or higher) is often called a **tensor**. \n\n::: {#c0c3276a .cell execution_count=10}\n``` {.python .cell-code}\nrng = random.default_rng(seed=24)\nrandom_matrix = rng.uniform(-1,1,size=(2,5)) # random floats between -1 and 1, 2 rows, 5 columns\nrandom_matrix\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\narray([[-0.33946233, -0.18964537,  0.14947564,  0.01279953,  0.12842501],\n       [ 0.13937462,  0.74823306, -0.82713908,  0.48495054,  0.64073453]])\n```\n:::\n:::\n\n\n::: {#becd812e .cell execution_count=11}\n``` {.python .cell-code}\nrandom_matrix.ndim # two dimensions, rank 2, a matrix\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n2\n```\n:::\n:::\n\n\n::: {#a20ef71a .cell execution_count=12}\n``` {.python .cell-code}\nrandom_tensor = rng.integers(0,3,size=(2,3,4)) # random integes in [0,3), 2x3x4 tensor\nrandom_tensor\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\narray([[[0, 2, 1, 1],\n        [2, 2, 0, 0],\n        [1, 2, 0, 1]],\n\n       [[2, 0, 1, 0],\n        [0, 1, 1, 0],\n        [0, 1, 0, 1]]])\n```\n:::\n:::\n\n\n::: {#e5bba87c .cell execution_count=13}\n``` {.python .cell-code}\nrandom_tensor.ndim\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n3\n```\n:::\n:::\n\n\nWe can perform operations along specific axes of a multi-dimensional array. For example, we can sum all the elements along a specific axis using the `np.sum` function with the `axis` parameter.\n\n::: {#df43c272 .cell execution_count=14}\n``` {.python .cell-code}\nsmall_matrix = rng.integers(0,2,size=(3,2)) \nsmall_matrix\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\narray([[1, 1],\n       [1, 0],\n       [1, 0]])\n```\n:::\n:::\n\n\n::: {#1638a90f .cell execution_count=15}\n``` {.python .cell-code}\nsmall_matrix.sum(axis=0) # sum along the first axis (rows)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\narray([3, 1])\n```\n:::\n:::\n\n\n::: {#d21cc641 .cell execution_count=16}\n``` {.python .cell-code}\nsmall_matrix.sum(axis=1) # sum along the second axis (columns), can you explain the resulting shape?\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\narray([2, 1, 1])\n```\n:::\n:::\n\n\nOne can do the same also with useful statistical descriptors such as `np.mean`, `np.std`, etc.\n\n::: {#b4d9f9a8 .cell execution_count=17}\n``` {.python .cell-code}\nnp.mean(small_matrix, axis=0) # mean along the first axis (rows)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\narray([1.        , 0.33333333])\n```\n:::\n:::\n\n\n### Slicing\n\nSlicing works similarly to 1D arrays, but you can slice along multiple axes. For example, you can slice a 2D array to get a submatrix or a specific row or column.\n\n::: {#e21cfe43 .cell execution_count=18}\n``` {.python .cell-code}\nsmall_matrix[:, 0] # all rows, first column\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([1, 1, 1])\n```\n:::\n:::\n\n\n::: {#911637f4 .cell execution_count=19}\n``` {.python .cell-code}\nsmall_matrix[:2,:] # first two rows, all columns\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\narray([[1, 1],\n       [1, 0]])\n```\n:::\n:::\n\n\n::: {#55090551 .cell execution_count=20}\n``` {.python .cell-code}\nsmall_matrix[::-1,:1]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\narray([[1],\n       [1],\n       [1]])\n```\n:::\n:::\n\n\n### Reshaping and flattening\n\nThe last example show an inetresting case: we extracted a single column from the matrix, but it is still a 2D array with shape `(3, 1)`.\n\n::: {#1cbc7b26 .cell execution_count=21}\n``` {.python .cell-code}\nselection = small_matrix[::-1,:1]\n\nprint(\"shape\", selection.shape)\nprint(\"rank\", selection.ndim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nshape (3, 1)\nrank 2\n```\n:::\n:::\n\n\nWhat if we wanted a truly 1d array (rank 1)? We need to **reshape** the array. \n\nWe can use the `np.reshape` function to change the shape of an array without changing its data. For example, we can reshape a 2D array into a 1D array or vice versa.\n\nReshape takes a tuple of the new shape as an argument. If you want to flatten an array (convert it to a 1D array), you can use `-1` as one of the dimensions, which tells NumPy to infer the size of that dimension based on the total number of elements.\n\n::: {#61e0a6e9 .cell execution_count=22}\n``` {.python .cell-code}\nselection = small_matrix[::-1,:1]\nreshaped_selection = selection.reshape((3,))  # reshape to a 1D array excplicitly\nprint(\"reshaped shape\", reshaped_selection.shape)\nprint(\"reshaped rank\", reshaped_selection.ndim)\nprint(\"reshaped selection\", reshaped_selection)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nreshaped shape (3,)\nreshaped rank 1\nreshaped selection [1 1 1]\n```\n:::\n:::\n\n\n::: {#110b50db .cell execution_count=23}\n``` {.python .cell-code}\n#same code as above, but with inferred shape\nselection = small_matrix[::-1,:1]\nreshaped_selection = selection.reshape(-1)  # infererd shape\nprint(\"reshaped shape\", reshaped_selection.shape)\nprint(\"reshaped rank\", reshaped_selection.ndim)\nprint(\"reshaped selection\", reshaped_selection)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nreshaped shape (3,)\nreshaped rank 1\nreshaped selection [1 1 1]\n```\n:::\n:::\n\n\nAnother way to cast a multi-dimensional array to a 1D array is to use the `np.ravel()` function, which returns a flattened view of the array (not a copy).\n\n::: {#88eeeb8c .cell execution_count=24}\n``` {.python .cell-code}\na_matrix = rng.integers(0,10,size=(2,3)) # random integers in [0,10), 2x3 matrix\nprint(\"Original matrix:\\n\", a_matrix)\nravelled_view = a_matrix.ravel()\nprint(\"Flattened view:\", ravelled_view)  # flatten the array to a 1D array\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal matrix:\n [[4 7 8]\n [7 7 0]]\nFlattened view: [4 7 8 7 7 0]\n```\n:::\n:::\n\n\nIf we modify the view, we modify the original array as well.\n\n::: {#d60027af .cell execution_count=25}\n``` {.python .cell-code}\nravelled_view[0] = 100  # modify the view\nprint(\"Modified view:\", ravelled_view)  # the view is modified\nprint(\"Original array:\", a_matrix)  # the original array is modified as well\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModified view: [100   7   8   7   7   0]\nOriginal array: [[100   7   8]\n [  7   7   0]]\n```\n:::\n:::\n\n\nTo obtain a completely independent flattened copy of the array, you can use the `np.flatten()` method, which returns a copy of the array in a 1D format.\n\n::: {#184c5176 .cell execution_count=26}\n``` {.python .cell-code}\na_matrix = rng.integers(0,10,size=(2,3)) # random integers in [0,10), 2x3 matrix\nprint(\"The original:\\n\",a_matrix)\nflattened_copy = a_matrix.flatten()\nprint(\"Flattened:\",flattened_copy)  # flatten the array to a 1D array\nflattened_copy[0] = 100  # modify the copy\nprint(\"Flattened after modification:\",flattened_copy)  # the copy is modified\nprint(\"The original:\\n\",a_matrix)  # the original array is not modified\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe original:\n [[4 4 7]\n [4 6 9]]\nFlattened: [4 4 7 4 6 9]\nFlattened after modification: [100   4   7   4   6   9]\nThe original:\n [[4 4 7]\n [4 6 9]]\n```\n:::\n:::\n\n\nWe can also do the opposite and increase the rank of an array by reshaping it. For example, we can reshape a 1D array into a 2D array with one column or one row.\n\n::: {#60740977 .cell execution_count=27}\n``` {.python .cell-code}\none_dimensional_array = rng.integers(0,10,size=(5,))  # random integers in [0,10), 1D array\nprint(\"One-dimensional array:\", one_dimensional_array)\nreshaped_array = one_dimensional_array.reshape((5,1))  # reshape to a  2D array with one column\nprint(\"Reshaped array:\\n\", reshaped_array)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOne-dimensional array: [5 5 5 3 2]\nReshaped array:\n [[5]\n [5]\n [5]\n [3]\n [2]]\n```\n:::\n:::\n\n\n### Broadcasting\n\nCombining arrays of different shapes is possible in NumPy using a feature called **broadcasting**. Broadcasting allows NumPy to perform operations on arrays of different shapes by automatically expanding the smaller array to match the shape of the larger one.\n\n::: {#32bffd05 .cell execution_count=28}\n``` {.python .cell-code}\n# Minimal broadcasting example: rank 2 (matrix) with rank 1 (vector)\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6]])\nvector = np.array([10, 20, 30])\n\n# Broadcasting addition: vector is added to each row of the matrix\nresult = matrix + vector\nprint(\"Matrix:\\n\", matrix)\nprint(\"Vector:\", vector)\nprint(\"Result of broadcasting:\\n\", result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMatrix:\n [[1 2 3]\n [4 5 6]]\nVector: [10 20 30]\nResult of broadcasting:\n [[11 22 33]\n [14 25 36]]\n```\n:::\n:::\n\n\nYou can reshape a 1D array to a column or row vector and use broadcasting to expand it into a large table. For example, to create a table where each row is the original 1D array, or each column is the original array:\n\n::: {#cea8ff42 .cell execution_count=29}\n``` {.python .cell-code}\none_dimensional_array = np.linspace(1, 5, num=5)  # create a 1D array with 5 elements\nprint(\"One-dimensional array:\", one_dimensional_array)\n# Expand one_dimensional_array to a table with 5 rows and 5 columns\nrow_vector = one_dimensional_array.reshape(1, -1)  # shape (1, 5)\ncolumn_vector = one_dimensional_array.reshape(-1, 1)  # shape (5, 1)\n\n# Broadcasting to create a table\ntable = column_vector + row_vector\nprint(\"BroadcastedTable:\\n\",table)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOne-dimensional array: [1. 2. 3. 4. 5.]\nBroadcastedTable:\n [[ 2.  3.  4.  5.  6.]\n [ 3.  4.  5.  6.  7.]\n [ 4.  5.  6.  7.  8.]\n [ 5.  6.  7.  8.  9.]\n [ 6.  7.  8.  9. 10.]]\n```\n:::\n:::\n\n\n## Two-dimensional arrays as matrices: some linear algebra\n\nTwo-dimensional arrays are often used to represent matrices or images. In a matrix, each element can be accessed using two indices: \n- one for the row \n- one for the column. \n\n\nA matrix is a rectangular array of numbers, symbols, or expressions arranged in rows and columns and is an essential concept in **linear algebra**.\n\nFor examplle, let's consider the simple system of simultaneous equations:\n\n$$ \\begin{align*}\n2x + 3y +z &= 5 \\\\\n4x - y &= 1 \\\\\n2y +z &= 3\n\\end{align*} $$\n\nThis can be represented in matrix form as:\n$$ \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n=\n\\begin{bmatrix}5 \\\\\n1\\\\\n3\n\\end{bmatrix} $$   \n\nAnd if we call $A$ the matrix of coefficients, $\\mathbf{x}$ the vector of variables, and $b$ the vector of constants, we can write this as:\n$$ A \\mathbf{x} = \\mathbf{b} $$\n\nwhere $$A = \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}, \\quad\n\\mathbf{x} = \\begin{bmatrix}\nx \\\\\ny\\\\\nz\n\\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix}\n5 \\\\\n1\\\\\n3\n\\end{bmatrix} $$            \n\nA key result of linear algebra is that if $A$ is invertible, we can solve for $\\mathbf{x}$ by multiplying both sides of the equation by the inverse of $A$:\n$$ \\mathbf{x} = A^{-1} \\mathbf{b} $$\n\nwhere $A^{-1}$ is the inverse of matrix $A$.\n\nNumPy has a dedicated linear algebra submodule called `numpy.linalg` that provides functions for performing various linear algebra operations, including matrix inversion, solving systems of equations, and computing eigenvalues and eigenvectors.\n\n::: {#fd87dc92 .cell execution_count=30}\n``` {.python .cell-code}\nA = np.array([[2, 3,1], [4, -1,0],[0,2,1]])\nb = np.array([[5], [1], [3]]) # we use double brackets to create a column vector\nprint(\"Matrix A:\\n\", A)\nprint(\"Vector b:\\n\", b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMatrix A:\n [[ 2  3  1]\n [ 4 -1  0]\n [ 0  2  1]]\nVector b:\n [[5]\n [1]\n [3]]\n```\n:::\n:::\n\n\nThe linear algebra submodule has a function called `solve` which can be used to solve the above equation efficiently:\n\n::: {#69427cf2 .cell execution_count=31}\n``` {.python .cell-code}\nx = np.linalg.solve(A, b)\n\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\narray([[0.5],\n       [1. ],\n       [1. ]])\n```\n:::\n:::\n\n\nBut we can use numpy to verify that this is correct. We can use the symbol `@` to perform matrix multiplication in numpy. \n\n::: {#51b4bcbe .cell execution_count=32}\n``` {.python .cell-code}\nA @ x\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\narray([[5.],\n       [1.],\n       [3.]])\n```\n:::\n:::\n\n\nWe can also directly calculate the inverse of a matrix using the `inv` function from the `numpy.linalg` and use it to solve the equation\n\n::: {#c36fdda6 .cell execution_count=33}\n``` {.python .cell-code}\nx = np.linalg.inv(A) @ b\n\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\narray([[0.5],\n       [1. ],\n       [1. ]])\n```\n:::\n:::\n\n\nAll the most common linear algebra operations are available in the `numpy.linalg` submodule:\n\n- tranpose\n\n::: {#87c58a63 .cell execution_count=34}\n``` {.python .cell-code}\nb.T\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\narray([[5, 1, 3]])\n```\n:::\n:::\n\n\n- scalar (dot) product (which takes two vectors and returns a scalar)\n\n::: {#fc2c776d .cell execution_count=35}\n``` {.python .cell-code}\nnp.dot(b.T,b)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\narray([[35]])\n```\n:::\n:::\n\n\n- cross product\n\n::: {#24d727f6 .cell execution_count=36}\n``` {.python .cell-code}\nnp.cross(b.T, b.T) #takes row vectors and returns a row vector\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\narray([[0, 0, 0]])\n```\n:::\n:::\n\n\nLinear algebra applications are beyond the scope of this course (so, there will be **no assessment of these**), but they are widely used in various fields such as physics, computer science, and engineering. For example, they are essential in computer graphics for transformations, in machine learning for optimization, and in physics for solving systems of equations. So it is important for you to know that all these can be implemented efficiently using numpy.\n\n## Matrices as images\n\nA two-dimensional table of numbers can also be used to represent an image. Each number in the table corresponds to a pixel in the image, and the value of the number represents the color or intensity of that pixel.\n\n`matplotlib` provides a convenient way to visualize 2D arrays as images. The `matshow` function can be used to display a 2D matrix as an image, where the values in the array are mapped to colors.\n\n::: {#7efce5f1 .cell execution_count=37}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nplt.matshow(A)\nplt.colorbar()\nprint(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 2  3  1]\n [ 4 -1  0]\n [ 0  2  1]]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](lecture_multidimensionalArrays_files/figure-html/cell-37-output-2.png){}\n:::\n:::\n\n\nNotice that the indices of the y-axis increase as we go down. These are the indices of the rows in the matrix.\n\nFor a matrix of a given shape we can get the indices using the `np.indices` function, which returns a grid of indices for each dimension. This can be useful for creating masks or selecting specific regions of the matrix.\n\n::: {#acb9d9ac .cell execution_count=38}\n``` {.python .cell-code}\nrow_index, col_index = np.indices(A.shape)\nprint(\"Row indices:\\n\", row_index)\nprint(\"Column indices:\\n\", col_index)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRow indices:\n [[0 0 0]\n [1 1 1]\n [2 2 2]]\nColumn indices:\n [[0 1 2]\n [0 1 2]\n [0 1 2]]\n```\n:::\n:::\n\n\nAn alternative function is `imshow`, which is more general and can be used for both 2D arrays and images.\n\nHere we can set the origin of the axis:\n\n::: {#c0143148 .cell execution_count=39}\n``` {.python .cell-code}\nplt.imshow(A, origin='lower')  # origin='lower' to set the origin at the bottom left\n```\n\n::: {.cell-output .cell-output-display}\n![](lecture_multidimensionalArrays_files/figure-html/cell-39-output-1.png){}\n:::\n:::\n\n\n::: {#f8bb0d2b .cell execution_count=40}\n``` {.python .cell-code}\nplt.imshow(A, origin='upper')  # origin=\"upper\" to set the origin at the top left\n```\n\n::: {.cell-output .cell-output-display}\n![](lecture_multidimensionalArrays_files/figure-html/cell-40-output-1.png){}\n:::\n:::\n\n\nThe main difference between `matshow` and `imshow` is that `matshow` is specifically designed for displaying matrices, while `imshow` is more general and can be used for both 2D arrays and images. `matshow` automatically adjusts the aspect ratio to make the matrix square, while `imshow` does not. Also the interpolation method used by `matshow` is different from that used by `imshow`, which can affect the appearance of the image.\n\nImages are represneted as 3d arays: every entry is a the intensity of a pixel (if the image is grayscale) or the intensity of a colour (e.g. red, green or blue) if the image is in colour.\n\n::: {#dfc2dae5 .cell execution_count=41}\n``` {.python .cell-code}\nfrom skimage import data # importing images from a popular image library\n\nimage = data.camera() # a grayscale image\n\nplt.imshow(image, cmap='gray')  # display the image in grayscale\nplt.colorbar()\n```\n\n::: {.cell-output .cell-output-display}\n![](lecture_multidimensionalArrays_files/figure-html/cell-41-output-1.png){}\n:::\n:::\n\n\nLet's take a colour image\n\n::: {#bb663748 .cell execution_count=42}\n``` {.python .cell-code}\ncolor_image = data.chelsea()\nplt.imshow(color_image)  # display the color image\n```\n\n::: {.cell-output .cell-output-display}\n![](lecture_multidimensionalArrays_files/figure-html/cell-42-output-1.png){}\n:::\n:::\n\n\nThis is no longer just a 2d array, it has a third dimension for the colour channels (red, green, blue). We can access the individual colour channels by slicing the array along the third dimension.\n\n::: {#deb9899a .cell execution_count=43}\n``` {.python .cell-code}\ncolor_image.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n(300, 451, 3)\n```\n:::\n:::\n\n\nWe can slice the array to get the various channels (notice that we specify the **colormap** `cmap` argument to display the channels in the appropriate colour):\n\n::: {#9ba44892 .cell execution_count=44}\n``` {.python .cell-code}\nfig,ax = plt.subplots(1, 3, figsize=(15, 5))  # create a figure with 3 subplots\nax[0].imshow(color_image[:, :, 0], cmap='Reds')  # display the red channel\nax[0].set_title('Red Channel')\nax[1].imshow(color_image[:, :, 1], cmap='Greens')  # display the green channel\nax[1].set_title('Green Channel')\nax[2].imshow(color_image[:, :, 2], cmap='Blues')  # display the blue channel\nax[2].set_title('Blue Channel')\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\nText(0.5, 1.0, 'Blue Channel')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](lecture_multidimensionalArrays_files/figure-html/cell-44-output-2.png){}\n:::\n:::\n\n\nIf we want to subsample regions of an image, we can simply slice the array further in its rows and columns.\n\n::: {#8c418abf .cell execution_count=45}\n``` {.python .cell-code}\nplt.imshow(color_image[100:250, 100:, 1], cmap='Greens')  # display the green channel\n```\n\n::: {.cell-output .cell-output-display}\n![](lecture_multidimensionalArrays_files/figure-html/cell-45-output-1.png){}\n:::\n:::\n\n\nWe can also use boolean indexing to filter the image based on conditions.\n\nFor example, we can binarise it by applying a threshold\n\n::: {#5cb6adbd .cell execution_count=46}\n``` {.python .cell-code}\ngreen = color_image[:,:,1]\n\nplt.imshow(green>100, cmap='gray')  # display a binary image where pixels with green channel value > 100 are white\n```\n\n::: {.cell-output .cell-output-display}\n![](lecture_multidimensionalArrays_files/figure-html/cell-46-output-1.png){}\n:::\n:::\n\n\nWe can even perform logical operations using `numpy`\n\n- AND with `&`\n- OR with `|`\n- NOT with `~` or `np.logical_not`\n\n::: {#8f616961 .cell execution_count=47}\n``` {.python .cell-code}\ngreen = color_image[:,:,1]\nred = color_image[:,:,0]\nplt.imshow( (green>120) & (red>120) , cmap='gray')\n```\n\n::: {.cell-output .cell-output-display}\n![](lecture_multidimensionalArrays_files/figure-html/cell-47-output-1.png){}\n:::\n:::\n\n\n::: {#70ea3c41 .cell execution_count=48}\n``` {.python .cell-code}\nplt.imshow(np.logical_not(green>100), cmap='gray')\n```\n\n::: {.cell-output .cell-output-display}\n![](lecture_multidimensionalArrays_files/figure-html/cell-48-output-1.png){}\n:::\n:::\n\n\n## Pair programming\n\nThe following exercise will allow you explore multi-dimensional arrays by **working in pairs**. One person will write the code, while the other will explain what the code does. You can switch roles after each exercise.\n\nThere are two parts so, you can switch roles after each part.\n\n- [Part1](exercises_part1.qmd)\n- [Part2](exercises_part2.qmd)\n\n",
    "supporting": [
      "lecture_multidimensionalArrays_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}