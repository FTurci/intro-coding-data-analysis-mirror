{
  "hash": "98bd771e8c3b3b12b74accddf66aa47f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Answers\njupyter: python3\n---\n\n# Using a mask\n\n## Pair programming: part 2\n\n\n## Masking a galaxy\n\nOne application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\n\nWe can open the image of the galaxy using the following code. This uses a module called `pillow` (imported as `PIL`) which understands how to read image files and we can import the `Image` sub-module to open this file. We can convert that image into a `numpy` `array` object.\n\n::: {#cf4fccae .cell execution_count=1}\n``` {.python .cell-code}\nfrom PIL import Image\nimport numpy as np\n\nim_filename = \"ngc253_small.png\"\nim = np.array(Image.open(im_filename))\n```\n:::\n\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\n::: {#6c7d775f .cell execution_count=2}\n``` {.python .cell-code}\nprint(im.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(907, 1000, 3)\n```\n:::\n:::\n\n\nAs we did when plotting the mask, we can use a `matplotlib` function called `imshow()` to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\n::: {#23fba48e .cell execution_count=3}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im, origin=\"lower\")\n```\n\n::: {.cell-output .cell-output-display}\n![](exercises_part2_solutions_files/figure-html/cell-4-output-1.png){}\n:::\n:::\n\n\nThis is sprial galaxy [NGC 253](https://www.eso.org/public/images/eso0902a/), also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed.\n\n## Creating an elliptical mask\n\nThe `inside_ellipse` function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we've seen in previous weeks, functions can be used to avoid having to repeat code. \n\n::: {#ee21b1fe .cell execution_count=4}\n``` {.python .cell-code}\ndef inside_ellipse(x, y, centre=(0,0), a=2, b=1, alpha=0):\n    \n    x0,y0 = centre\n    \n    # Convert alpha in degrees to radians for use with cos/sin function\n    alpha_rad = np.radians(alpha)\n    \n    term1 = ((x-x0)*np.cos(alpha_rad) + (y-y0)*np.sin(alpha_rad))**2 / a**2\n    term2 = ((x-x0)*np.sin(alpha_rad) - (y-y0)*np.cos(alpha_rad))**2 / b**2\n    \n    total = term1 + term2\n\n    return total<1\n```\n:::\n\n\n### Equations for an ellipse\n\nTo understand the parameters that can be passed to the `inside_ellipse()` function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, $r$, there are now two parameters $a$ and $b$ defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\n\nFor an ellipse centred at ($x_{0}$, $y_{0}$) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\n$$ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 $$\n\nThis would look something like:\n\n<img src=\"images/Ellipse_illustration_no-angle.png\" alt=\"Ellipse\" style=\"width:30%\"/>\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha ($\\alpha$). The edge for this ellipse can be calculated using the full equation:\n\n$$ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 $$\n\nThis would look like:\n\n<img src=\"images/Ellipse_illustration_with-angle.png\" alt=\"Ellipse at an angle\" style=\"width:30%\"/>\n\nThe parameters needed to use `inside_ellipse` function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, $\\alpha$. For example:\n\n::: {#5c7c77b4 .cell execution_count=5}\n``` {.python .cell-code}\nx1 = 0\ny1 = 0\nposition_is_in_ellipse1 = inside_ellipse(x1, y1, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x1}, {y1}) inside the ellipse? {position_is_in_ellipse1}\")\n\nx2 = 0\ny2 = 4\nposition_is_in_ellipse2 = inside_ellipse(x2, y2, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x2}, {y2}) inside the ellipse? {position_is_in_ellipse2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIs position (0, 0) inside the ellipse? True\nIs position (0, 4) inside the ellipse? False\n```\n:::\n:::\n\n\n---\n\n### Exercise B\n\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\n - centre position $x_0$, $y_0$ at (500, 470)\n - semi-major axis, $a$, of 365\n - semi-minor axis, $b$, of 70\n - angle alpha, $\\alpha$, of 38 degrees\n\n1. Use the `inside_ellipse` function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\n2. Apply this mask to each of the (R, G, B) channels of the image `im` (recall this is a 3D `np.array` object). Call the masked image `im_masked`.\n\nAs above, you can use the plotting code below which uses the `matplotlib` function `imshow()` to plot the 3D `im_masked` object as a colour image (or to plot a 2D image for one colour channel).\n\n::: {#1e20fec9 .cell execution_count=6}\n``` {.python .cell-code}\n# ADD CODE HERE\nrows, cols = np.indices((im.shape[0], im.shape[1]))\ncentre = (500,470)\na = 365\nb = 70\nalpha = 33\nmask = inside_ellipse (cols, rows, centre, a, b , alpha)\n\nim_masked = im.copy()\nim_masked[np.logical_not(mask),:] = 0 # you can use ~ instead of the logical_not function\n```\n:::\n\n\n::: {#7253c602 .cell execution_count=7}\n``` {.python .cell-code}\n# UNCOMMENT THIS CODE TO PLOT YOUR MASKED IMAGE\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im_masked.astype(int),origin=\"lower\")\n```\n\n::: {.cell-output .cell-output-display}\n![](exercises_part2_solutions_files/figure-html/cell-8-output-1.png){}\n:::\n:::\n\n\n## Calculating the magnitude\n\nNow that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\n\nThe magnitude of an object is given by the equation:\n\n$$ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 $$\n\nwhere:\n - $m_{AB}$ is the magnitude (on the AB scale)\n - $f_v$ is the spectral flux density (in units of Jansky, $Jy$)\n\n---\n\n### Exercise C\n\nWe can calculate an approximation of the spectral flux density, $f_{v}$, by **summing the pixel values** from our image and by applying a scale factor of $2.8\\times10^{-7}$.\n\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\n\nHow does this compare to the true value for \"B (AB)\"? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\n\nHint:\n  - Additional `numpy` functions which will be useful:\n    - `sum()` - https://numpy.org/doc/stable/reference/generated/numpy.sum.html\n    - `log10()` - https://numpy.org/doc/stable/reference/generated/numpy.log10.html     \n\n::: {#7b6a043e .cell execution_count=8}\n``` {.python .cell-code}\n# ADD CODE HERE\n\n# Select the third channel (B) and calculate the sum\nim_B_channel = im_masked[:, :, 2]\nsummed_B = np.sum(im_B_channel)\n\n# Apply the scale factor to get approximated flux value\nscale_factor = 2.8e-7\nflux_scaled_B = summed_B*scale_factor\n\n# Calculate the magnitude using the np.log10 function\nmagnitude_B = -2.5*np.log10(flux_scaled_B) + 8.90\nprint(magnitude_B)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8.070961081466722\n```\n:::\n:::\n\n\n---\n\n",
    "supporting": [
      "exercises_part2_solutions_files"
    ],
    "filters": [],
    "includes": {}
  }
}