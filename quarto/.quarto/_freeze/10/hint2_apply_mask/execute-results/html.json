{
  "hash": "2c3f75fda8b0a1da36de45759599b576",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Hint 2 - applying a rectangular mask\njupyter: python3\n---\n\n\n\n**Example: Applying a mask containing a rectangle to an image**\n\nI have downloaded an online image of a house for this example (from [Vector Stock](https://www.vectorstock.com/royalty-free-vector/view-of-the-house-from-the-inside-vector-19801844)). This image contains four different rooms and I want to use a rectangular mask so that only the office room is displayed. As described previously, we can open this image using a the `Image` sub-module of a module called `pillow` (imported as `PIL`) which understands how to read image files. We can then convert this input into a `numpy` `array` object.\n\n::: {#8b9fe16e .cell execution_count=2}\n``` {.python .cell-code}\nfrom PIL import Image\nimport numpy as np\n\nim_filename = \"images/image-house-vector-stock.jpg\"\nim = np.array(Image.open(im_filename))\n```\n:::\n\n\n`im` is a three dimensional `numpy` `array` object - includes height, width and colour channel (R, G, B).\n\n::: {#8c07c0ee .cell execution_count=3}\n``` {.python .cell-code}\nshape = im.shape\nprint(shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(780, 1000, 3)\n```\n:::\n:::\n\n\n::: {#7fe50eff .cell execution_count=4}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im)\n```\n\n::: {.cell-output .cell-output-display}\n![](hint2_apply_mask_files/figure-html/cell-4-output-1.png){}\n:::\n:::\n\n\nThe `imshow` function knows how to interpret this 3D shape to show a colour image.\n\n## Create a rectanglar mask using a function\n\nI can define an function called `inside_rectangle()` to tell me whether a given (x, y) position is within a rectangle for a set of parameters. This will return `True` if the position is inside the rectangle and `False` otherwise.\n\nThe rectangle can be evaluated using the conditions:\n\n$$|x - x_0| = w/2$$\nand\n$$|y - y_0| = h/2$$\n\nwhere\n - $x$, $y$ are the x, y positions within the grid\n - $x_0$, $y_0$ are the centre of the rectangle\n - $w$, $h$ - are the full width and height of the rectangle\n - $| |$ means the magnitude of the difference\n\n::: {#199abeae .cell execution_count=5}\n``` {.python .cell-code}\ndef inside_rectangle(x,y,centre=(0,0),width=20,height=10):\n    \n    x0 = centre[0]\n    y0 = centre[1]\n    \n    distance_x = np.abs(x - x0) # Magnitude of distance\n    distance_y = np.abs(y - y0) # Magnitude of distance\n    \n    # Check if (x, y) position is within the rectangle\n    if distance_x < width/2 and distance_y < height/2:\n        return True\n    else:\n        return False\n```\n:::\n\n\nFor this mask, I want to define the parameters as follows:\n\n::: {#ab03fecc .cell execution_count=6}\n``` {.python .cell-code}\n# Input parameters\ncentre = (382,320)\nwidth = 280\nheight = 218\n```\n:::\n\n\nThe `inside_rectangle` function allows you to pass the parameters for your position and your rectangle and can tell you whether the position is within your rectangle (returns a `True` value) or not (returns a `False` value). For example if we had a position of (50, 50) we could use the function as follows:\n\n::: {#379c25d7 .cell execution_count=7}\n``` {.python .cell-code}\nx = 50\ny = 50\n\nposition_is_in_rectangle = inside_rectangle(x, y, centre=centre, width=width, height=height)\n\nif position_is_in_rectangle:\n    print(f\"Position ({x}, {y}) is within the rectangle\")\nelse:\n    print(f\"Not within rectangle\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNot within rectangle\n```\n:::\n:::\n\n\nHere we used the output of `inside_rectangle` as our condition directly (Python sees this `if True` or `if False` and follows the logic accordingly).\n\nWe can use the `inside_rectangle()` function to define our mask - looping over every element and checking the x, y position with the `inside_rectangle()` function with the appropriate parameters:\n\n::: {#c50c8023 .cell execution_count=8}\n``` {.python .cell-code}\nncol = shape[0]\nnrow = shape[1]\n\n# Create array of zeros based on shape of input image - height x width\nrect_mask = np.zeros(shape[0:2],dtype=int)\n\nfor y in range(ncol): # iterate over first dimension\n    for x in range(nrow): # iterate over second dimension\n        # Check whether x, y position is within defined rectangle\n        position_is_in_rectangle = inside_rectangle(x, y, centre=centre, width=width, height=height)\n        if position_is_in_rectangle:\n            rect_mask[y, x] = 1\n\nprint(f\"Shape of mask: {rect_mask.shape}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nShape of mask: (780, 1000)\n```\n:::\n:::\n\n\nAs before, we don't need an `else` block here because the array we have defined already contains zeros.\n\n**Extended:** See [alternative numpy method](hint1_mask.qmd#Extended:-Leveraging-numpy-functionality) mask in Hint 1 notebook for a more efficient way to create a square mask. Could you extend this method to reproduce a rectangular mask (without the need for the `inside_rectangle` function)?\n\n## Apply mask to the image\n\nNow we have created `rect_mask`, we need to apply this to my image. We can do this by multiplying `im` by `rect_mask` and this will combine element-wise. This means that each pixel in the image will be multiplied by the corresponding value within the mask. Multipying by 0 will result in the output pixel also being 0 but multiplying by 1 will retain the original value in that pixel.\n\nFor creating the `im_masked` output there a few ways you could do this - the upshot is that you want to create an array of the right *shape*:\n - Create an empty array of the right shape\n - Create a new variable called `im_masked` which is a copy of the `im` using the [`copy()` function (method)](https://numpy.org/doc/stable/reference/generated/numpy.copy.html)\n\nBecause `im` is a three dimensional array (height x weight x colour channel), one way to apply the mask is to do this for each of the three colours (R, G, B channels) separately.\n\n::: {#7c26779e .cell execution_count=9}\n``` {.python .cell-code}\n## Create an empty array of the right shape\nim_masked = np.empty(shape)\n## OR make a copy and then apply mask\n#im_masked = im.copy()\n\n# Update the values within this array for each colour channel\nim_masked[:,:,0] = im[:,:,0]*rect_mask # shapes match (780, 1000) x (780, 1000)\nim_masked[:,:,1] = im[:,:,1]*rect_mask # shapes match (780, 1000) x (780, 1000)\nim_masked[:,:,2] = im[:,:,2]*rect_mask # shapes match (780, 1000) x (780, 1000)\n\n# # Another way to write this would be to add an extra dimension to our mask\n# # - This can be done using the np.newaxis constant to add an extra dimension\n# # - Numpy can then *broadcast* along this new dimension to combine correctly\n# im_masked = im*rect_mask[:,:,np.newaxis] # shapes (780, 1000, 3) x (780, 1000, 1)\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im_masked.astype(int)) \n```\n\n::: {.cell-output .cell-output-display}\n![](hint2_apply_mask_files/figure-html/cell-9-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "hint2_apply_mask_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}