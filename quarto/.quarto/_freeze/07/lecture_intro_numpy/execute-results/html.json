{
  "hash": "99cd777828d0b77b2017f298b10151e6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: The `numpy` module\njupyter: python3\n---\n\n\n\n## What is the `numpy` module?\n\nA collection of many functions is called a *module*. One of the most useful modules in Python is called *numpy* (**num**erical **Py**thon) â€“ it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we've been focussing on so far but now comes as standard in most Python installations.\n\nThe `numpy` module builds on the core functionality but also adds additional features including:\n\n - It is *performant* which means it is well optimised\n - It offers additional *numerical computing tools*\n - It adds an additional object called an *n-dimensional array*\n\n### Numpy arrays vs lists\nOne thing we can use the `numpy` module for is to create a new object called a *numpy array*. This is another data structure, in addition to the in-built Python types we've been learning about, and is similiar to a list. \n\n<table style=\"font-size:0.95em;font-family:Arial, Helvetica, sans-serif;border-spacing:5px;border-collapse:initial\">\n    <tr>\n        <th style=\"background-color:lavender\">\n            Numpy arrays\n        <td style=\"width:50%;text-align:left;vertical-align:top\">\n            Numpy module (and arrays) are a Python extension (but often come as standard)<br>\n            <br>\n            Ordered<br>\n            <br>\n            Mutable<br>\n            <br>\n            Less flexible<br>\n             - One data type per array<br>\n            <br>\n            Allows implicit element-wise operations<br>\n            <br>\n            Generally quicker (optimised)<br>\n            More memory efficient\n        <th style=\"background-color:linen\">\n            Lists\n        <td style=\"width:50%;text-align:left;vertical-align:top\">\n            Lists are part of Python in-built functionality<br>\n            <br>\n            Ordered<br>\n            <br>\n            Mutable<br>\n            <br>\n            Very flexible<br>\n             - All types in any list<br>\n            <br>\n            Needs explicit element-wise operations<br>\n            <br>\n            Generally slower performance<br>\n            Less memory efficient\n    </tr>\n</table>\n\nWhen using these objects, `list` objects are highly flexible, in both content and shape whereas `numpy.array` objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n### Numpy arrays\n\n`numpy.array` objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\n\nTo use the `numpy` module we first need to *import* it.\n\n\n\nThe `as` part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case `np`. This is the convention most often used for the numpy module. `import` statements themselves are the way we access additional Python modules such as `numpy` or `matplotlib`. \n\nOne way to create a `numpy.array` is from a `list`:\n\n\n\nwhere we need the `np.` at the start of the function to tell python to access the `numpy` module.\n\nWe can also index and slice `numpy.arrays` in a similar way to other iterable objects (i.e. objects with length like `lists`):\n\n::: {#12266dae .cell execution_count=3}\n\n::: {.cell-output .cell-output-stdout}\n```\n1.0\n[2. 3. 5.]\n```\n:::\n:::\n\n\nAnd a `numpy.array` has an additional properties (*attributes*) called *dtype* which tells us what is contained within the array and *shape* which tells us the dimensions of the array.\n\n::: {#fc966e3c .cell execution_count=4}\n\n::: {.cell-output .cell-output-stdout}\n```\nfloat64\n(6,)\n```\n:::\n:::\n\n\n### Element-wise operations\n\nThe `numpy` module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we've shown before one way to act on every item in a `list` using a `for` loop:\n\n::: {#1107a7a2 .cell execution_count=5}\n\n::: {.cell-output .cell-output-stdout}\n```\n[4.0, 4.0, 8.0, 12.0, 20.0, 32.0]\n```\n:::\n:::\n\n\nThere is actually a short hand for creating a new list using a `for` loop for very simple operations called a *list comprehension*.\n\n::: {#24dced94 .cell execution_count=6}\n\n::: {.cell-output .cell-output-stdout}\n```\n[4.0, 4.0, 8.0, 12.0, 20.0, 32.0]\n```\n:::\n:::\n\n\nBut this is still more complex than using a `numpy.array`, where the same operation can be performed using an operator directly on the whole array:\n\n::: {#4b31e4ad .cell execution_count=7}\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 4.  4.  8. 12. 20. 32.]\n```\n:::\n:::\n\n\n### Operation speed\n\nFor large numbers of elements the time difference between operations using `lists` and `numpy.arrays` can start to be measurable. We can quickly check this my importing the `time` module:\n\n\n\n\n\n\n\nComparing the two operations we can see that performing this operation with the `list` takes longer than within a `numpy.array` (this is highly variable though):\n\n::: {#3e8305cd .cell execution_count=11}\n\n::: {.cell-output .cell-output-stdout}\n```\nArray operation is 1 times faster for 100,000 numbers\n```\n:::\n:::\n\n\nYou may recall, when we first introduced `list` and `dict` objects, we also mentioned other Python objects which were similar but with some differences in functionality (`tuple` and `set` objects).  In Python, as in many languages, there are often many tools which can be used to complete a task and it's up to you to choose the correct tool for the job. Overall, `list` objects may be more appropriate when you need to store a set of strings or if you don't know the number of elements in advance (appending to a `list` is faster than appending to an `numpy.array` due to the way the data is stored in memory). Whereas `numpy.array` objects would be more appropriate when performance is a factor or for simpler numerical operations.\n\n## Working with `numpy`\n\nTo use the `numpy` module we always need to start by using an import statement. In this case we import the `numpy` module and use the shorthand `np`:\n\n\n\n\n\nWe've seen that we can apply operators directly to a `numpy.array`:\n\n::: {#580c273b .cell execution_count=14}\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\narray([ 6.5,  6.5,  8. ,  9.5, 12.5, 17. ])\n```\n:::\n:::\n\n\nSimilarly you can use additional functions provided by the `numpy` module to do something to each element in the array. For example you can apply a square root:\n\n::: {#85d0a3d5 .cell execution_count=15}\n\n::: {.cell-output .cell-output-stdout}\n```\n[1.         1.         1.41421356 1.73205081 2.23606798 2.82842712]\n```\n:::\n:::\n\n\nOr perform a reductive operation such as calculating the mean of all the elements:\n\n::: {#4affeb53 .cell execution_count=16}\n\n::: {.cell-output .cell-output-stdout}\n```\n3.3333333333333335\n```\n:::\n:::\n\n\nWe can also apply mathematical operations over the whole array. For instance we can look at the `np.cos` function which produces applies the cosine function element-wise:\n\n\n\nThe help states that this wants an *array-like* object and wants the input in radians. We can write this as:\n\n::: {#87a59168 .cell execution_count=18}\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 0.54030231  0.54030231 -0.41614684 -0.9899925   0.28366219 -0.14550003]\n```\n:::\n:::\n\n\nIf we look at `arr1` we can see that this has not been updated by the application of these operations - when using this functionality a copy of the array is returned which you can choose to re-assign to the original variable name or create a new variable:\n\n::: {#618ca2db .cell execution_count=19}\n\n::: {.cell-output .cell-output-stdout}\n```\n[1. 1. 2. 3. 5. 8.]\n[ 6.5  6.5  8.   9.5 12.5 17. ]\n```\n:::\n:::\n\n\n## Element-wise operations on 1D arrays\n\nElement-wise operations in numpy allow you to perform arithmetic or mathematical functions on each corresponding element of arrays. For example, if you have two arrays of the same length, `arr1` and `arr2`, you can add them directly: `arr1 + arr2`. This will produce a new array where each element is the sum of the elements at the same position in the original arrays. Similarly, you can use other operators (`-`, `*`, `/`) or numpy functions (`np.sqrt(arr1)`, `np.cos(arr1)`) to apply operations to each element individually. The arrays must have compatible shapes for these operations.\n\n::: {#6a3198ca .cell execution_count=20}\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 7.5  7.5 10.  12.5 17.5 25. ]\n[-5.5 -5.5 -6.  -6.5 -7.5 -9. ]\n```\n:::\n:::\n\n\n::: {#736419d4 .cell execution_count=21}\n\n::: {.cell-output .cell-output-stdout}\n```\nElement-wise multiplication: [  6.5   6.5  16.   28.5  62.5 136. ]\nElement-wise division: [0.15384615 0.15384615 0.25       0.31578947 0.4        0.47058824]\n```\n:::\n:::\n\n\nWhen 1D arrays have different lengths, you need to be careful about the operations you perform. **Element-wise operations**: Operations such as `arr1 + arr3` or `arr1 * arr3` require arrays to have the same length or compatible shapes. If the lengths differ, numpy will raise a `ValueError` due to shape mismatch.\n\n::: {#8a94abe4 .cell execution_count=22}\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">NameError</span>                                 Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[22]</span><span class=\"ansi-green-fg\">, line 2</span>\n<span class=\"ansi-green-fg\">      1</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># This will raise a ValueError because arr1 and arr3 have different lengths</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">2</span> result = arr1 + <span class=\"ansi-yellow-bg\">arr3</span>\n\n<span class=\"ansi-red-fg\">NameError</span>: name 'arr3' is not defined</pre>\n```\n:::\n\n:::\n:::\n\n\n## Basic operations on 1D arrays\n\nSumming all elements in a 1D numpy array can be done with `np.sum(arr1)`.\n\nFor cumulative summing, use `np.cumsum(arr1)`, which returns an array where each element is the sum of all previous elements.\n\n\nSorting is performed with `np.sort(arr1)`, which returns a sorted copy of the array.\n \nTo concatenate two arrays, use `np.concatenate([arr1, arr2])`. This joins the arrays end-to-end, creating a new array containing all elements from both arrays in order. Concatenation is useful for combining datasets or extending arrays.\n  \nTo find unique elements, use `np.unique(arr1)`, which returns an array of the distinct values in `arr1`. These operations are efficient and commonly used for data analysis.\n\n::: {#9bfc3f53 .cell execution_count=23}\n\n::: {.cell-output .cell-output-stdout}\n```\nSum of arr1: 20.0\nCumulative sum of arr1: [ 1.  2.  4.  7. 12. 20.]\nSorted arr1: [1. 1. 2. 3. 5. 8.]\nCombined array: [ 1.   1.   2.   3.   5.   8.   6.5  6.5  8.   9.5 12.5 17. ]\nUnique elements in combined: [ 1.   2.   3.   5.   6.5  8.   9.5 12.5 17. ]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "lecture_intro_numpy_files"
    ],
    "filters": [],
    "includes": {}
  }
}