{
  "hash": "ed873141d4aa33e0a87ca78b5ebe5f73",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Exercises - Working with NumPy\njupyter: python3\n---\n\n\n\n### Exercise 1: Basic Indexing\nCreate a 1D NumPy array `arr` of integers from 10 to 19. Access the element at index 3.\n\n::: {#264f1f5e .cell tags='[\"sol\"]' execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\narr = np.arange(10, 20)\narr[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n13\n```\n:::\n:::\n\n\n### Exercise 2: Slicing\nSlice the array `arr` to get elements from index 2 to 6 included.\n\n::: {#d6d2eb66 .cell tags='[\"sol\"]' execution_count=3}\n``` {.python .cell-code}\narr = np.arange(10, 20)\narr[2:7]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\narray([12, 13, 14, 15, 16])\n```\n:::\n:::\n\n\n### Exercise 3: Step Slicing\nUse slicing with a step to get every second element from index 1 to 9.\n\n::: {#ea7a4ad8 .cell tags='[\"sol\"]' execution_count=4}\n``` {.python .cell-code}\narr = np.arange(10, 20)\narr[1:10:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([11, 13, 15, 17, 19])\n```\n:::\n:::\n\n\n### Exercise 4: Copy vs View\nDemonstrate that slicing creates a view, not a copy, by modifying a slice and showing the original array changes.\n\n::: {#5f03bee0 .cell tags='[\"sol\"]' execution_count=5}\n``` {.python .cell-code}\narr = np.arange(10, 20)\nslice_view = arr[2:5]\nslice_view[:] = 99\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([10, 11, 99, 99, 99, 15, 16, 17, 18, 19])\n```\n:::\n:::\n\n\n### Exercise 5: Copying Arrays\nUse `.copy()` to create a slice that doesn't affect the original array. In particular, select only the elements from index 2 to 5 and assign 99 to all of them. Show that the original array remains unchanged.\n\n::: {#5cd2ebde .cell tags='[\"sol\"]' execution_count=6}\n``` {.python .cell-code}\narr = np.arange(10, 20)\nslice_copy = arr[2:5].copy()\nslice_copy[:] = 99\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\narray([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n```\n:::\n:::\n\n\n### Exercise 6: Generating sequences and Boolean indexing\n\nGenerate a NumPy sequence of 100 integers from 0 to 99. Use Boolean indexing to select only the even numbers from this array.\n\n::: {#6ae41ee1 .cell tags='[\"sol\"]' execution_count=7}\n``` {.python .cell-code}\narr = np.arange(0, 100)\neven_numbers = arr[arr % 2 == 0]\neven_numbers\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,\n       34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,\n       68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98])\n```\n:::\n:::\n\n\n### Exercise 8: Random Array Generation\n\nRandom numbers from arbitrary distributions are in fact generated through the transformation of uniformly distributed random numbers.\n\nThe trick is the following:\n\n- calculate the cumulative distribution function (CDF) of the desired distribution\n- calculate the inverse of the CDF (also known as the quantile function), which maps probabilities (values between 0 and 1) to values of the random variable\n- sample a uniformly distributed random number between 0 and 1 and use the the inverse CDF to read off the value of the random variable.\n\n\nLet's take the example of the exponential distribution. This is defined by the following probability density function (PDF):\n\n$$\nf(x) = \\lambda e^{-\\lambda x}\n$$\nwith mean $1/\\lambda$ and standard deviation $1/\\lambda$. \n\nThe CDF of the exponential distribution is given by:\n\n$$F(x) = 1 - e^{-\\lambda x}\n$$\n\nSo its inverse is:\n$$F^{-1}(p) = -\\frac{1}{\\lambda} \\ln(1 - p)$$\n\nSo in the following cell:\n\n- define a random number generator `rng` with a fixed seed 10\n- sample 1000 uniformly distributed random numbers between 0 and 1\n- use the inverse CDF to transform them into exponentially distributed random numbers with mean  30.0\n- calculate the mean and standard deviation of the resulting array.\n- compare this with the results obtained using `rng.exponential`.\n\n::: {#36a14aeb .cell tags='[\"sol\"]' execution_count=8}\n``` {.python .cell-code}\n# Define random number generator with fixed seed\nrng = np.random.default_rng(10)\n\n# Sample 1000 uniformly distributed random numbers between 0 and 1\nuniform_samples = rng.uniform(0, 1, 1000)\n\n# Exponential distribution parameters\nmean = 30.0\nlmbda = 1 / mean\n\n# Use inverse CDF to transform to exponential distribution\nexp_samples_inv = -np.log(1 - uniform_samples) / lmbda\n\n# Calculate mean and standard deviation\nmean_inv = exp_samples_inv.mean()\nstd_inv = exp_samples_inv.std()\n\n# Compare with rng.exponential\nexp_samples_builtin = rng.exponential(mean, 1000)\nmean_builtin = exp_samples_builtin.mean()\nstd_builtin = exp_samples_builtin.std()\n\nprint(f\"Direct method using the inverse CDF: mean={mean_inv:.2f}, std={std_inv:.2f}\")\nprint(f\"rng.exponential: mean={mean_builtin:.2f}, std={std_builtin:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDirect method using the inverse CDF: mean=30.68, std=31.96\nrng.exponential: mean=30.19, std=30.78\n```\n:::\n:::\n\n\n## Exercise 9: Problem solving with NumPy\n\nConsider the following problem:\n\n> A panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. **Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.**\n\nThe problem is a two-dimensional problem. The passenger has coordinates $x(t), y(t)$ and is performing uniform rotational motion, with angular velocity $\\omega$ and radius $R$. \n\nThe angle formed at which the passenger is located is $\\theta(t)$ and simply evolves as \n\n$$\\theta(t) = \\omega t +\\theta_0$$\n\nwhere $\\theta_0$ is the initial angle ($\\theta_0=0$ in our case).\n\n\nHence, the trajectory is expressed by \n\n$$\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n$$\n\n\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\n\nThe first approach is via using vanilla Python\n\n::: {#fef217c1 .cell execution_count=9}\n``` {.python .cell-code}\nimport math\nR = 10.0 #in metres\nomega = 2.0*2*math.pi/60. # in radians per second\nx0 = R # in metres\ny0 = 0 # in metres\ndt = 2.0 # in seconds\nduration = 20.0 #in seconds\nnum_iterations  = int(duration/dt)\nx, y = [], []\nt = 0\nfor _ in range(num_iterations):\n    x.append(R*math.cos(omega*t)+x0)\n    y.append(R*math.sin(omega*t)+y0)\n    t += dt \n\n# plotting, ignore the details for now sicne we will cover this in a later lecture\nimport matplotlib.pyplot as plt\nplt.scatter(x,y)\nplt.axis(\"equal\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](exercises_lecture_working_with_numpy_solutions_files/figure-html/cell-9-output-1.png){}\n:::\n:::\n\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on **avoiding for loops** and using NumPy's array operations instead.\n\n::: {#b0f21c80 .cell tags='[\"sol\"]' execution_count=10}\n``` {.python .cell-code}\n# solution\nimport numpy as np\nR = 10.0\n# numpy also contains all the useful mathematical constants\nomega = 2.0*2*np.pi/60.\ntheta0 = 0\ndt = 2.0\nduration = 20.0\n\n# using numpy arrays, the for loop is replaced by the creation of an array\nt = np.arange(0,duration,dt) \n# from the array t, we can generate any other array, for example  by multiplying by a scalar\ntheta = omega*t+theta0\n# now theta is another array, and we can apply a numpy function, such as np.cos\nx = R*np.cos(theta)\ny = R*np.sin(theta)\n\n# plotting, ignore the details for now\nimport matplotlib.pyplot as plt\nplt.scatter(x,y)\nplt.axis(\"equal\")\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n(-10.77054980770496,\n 10.989073800366903,\n -6.669006096755103,\n 10.736372527513106)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](exercises_lecture_working_with_numpy_solutions_files/figure-html/cell-10-output-2.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "exercises_lecture_working_with_numpy_solutions_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}