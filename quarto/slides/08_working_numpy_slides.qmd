---
title: 'Working with NumPy: Indexing and Random Data'
format: 
  revealjs:
    theme: default
    highlight-style: github
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    code-copy: true
    code-overflow: wrap
execute:
  echo: true
  eval: true
  warning: false
---

## Array Indexing & Slicing

```{python}
import numpy as np
arr = np.array([10, 20, 30, 40, 50])

# Integer indexing
print("Element at index 1:", arr[1])

# Basic slicing
print("Slice [1:4]:", arr[1:4])
```

**Advanced slicing:**
```{python}
print("Every other element:", arr[::2])
print("Last three elements:", arr[-3:])
print("Reversed array:", arr[::-1])
```

---

## Views vs Copies

**Slicing creates views (shared data):**
```{python}
slice_view = arr[2:5]
slice_view[0] = 99
print("Original after view modification:", arr)
```

**Creating independent copies:**
```{python}
arr = np.array([10, 20, 30, 40, 50])  # Reset
arr_copy = arr[2:5].copy()
arr_copy[0] = 100
print("Copy:", arr_copy)
print("Original unchanged:", arr)
```

---

## Boolean Indexing

**Filter data with conditions:**
```{python}
arr = np.array([1, 2, 3, 4, 5, 6])
threshold = 3

bool_mask = arr > threshold
print("Boolean mask:", bool_mask)
print("Filtered values:", arr[bool_mask])
```

**Using `np.where`:**
```{python}
# Get indices where condition is True
indices = np.where(arr > threshold)[0]
print("Indices:", indices)

# Conditional selection
result = np.where(arr > 3, arr, 0)
print("Conditional result:", result)
```

---

## Generating Sequences

**`np.arange` - step-based:**
```{python}
print("Integers:", np.arange(0, 10, 2))
print("Floats:", np.arange(0.0, 1.0, 0.2))
```

**`np.linspace` - count-based:**
```{python}
print("5 points from 0 to 1:", np.linspace(0, 1, 5))
```

- **`arange`**: Use when you know the step size
- **`linspace`**: Use when you know the number of points

---

## Filled Arrays

```{python}
# Create arrays with specific values
zeros_arr = np.zeros(5)
ones_arr = np.ones(4)
full_arr = np.full(3, 7)

print("Zeros:", zeros_arr)
print("Ones:", ones_arr)
print("Full:", full_arr)
```

**Same shape as existing array:**
```{python}
template = np.array([1, 2, 3])
print("Zeros like:", np.zeros_like(template))
print("Ones like:", np.ones_like(template))
print("Full like:", np.full_like(template, 9))
```

---

## Random Number Generation

**Initialize generator (for reproducibility):**
```{python}
rng = np.random.default_rng(seed=123)
```

**Different distributions:**
```{python}
# Random integers
print("Random integers:", rng.integers(0, 100, size=5))

# Uniform floats [0, 1)
print("Uniform [0,1):", rng.random(5))

# Normal distribution
normal_samples = rng.normal(loc=0, scale=1, size=5)
print("Normal samples:", normal_samples)
```

---

## Pseudo-Random Numbers

**Computers are deterministic** - they use algorithms to generate "pseudo-random" sequences

**Linear Congruential Generator example:**
$$x_{n+1} = (a \times x_n + c) \bmod m$$

**Key concept: Seeds enable reproducibility**
```{python}
# Same seed = same sequence
rng1 = np.random.default_rng(seed=42)
rng2 = np.random.default_rng(seed=42)

print("RNG1:", rng1.integers(0, 10, size=3))
print("RNG2:", rng2.integers(0, 10, size=3))  # Same output!
```

---

## Performance Tips

**Preallocate for efficiency:**
```{python}
# Less efficient: generate one at a time
# for _ in range(1000):
#     val = rng.integers(0, 100)

# More efficient: preallocate
prealloc = rng.integers(0, 100, size=1000)
# Then use values from prealloc array
```

**Memory vs Speed tradeoff:**
- Small tasks: 100-1,000 elements
- Medium tasks: 10,000-100,000 elements  
- Large tasks: 1,000,000+ elements

---

## Key Takeaways

- **Views** share data, **copies** are independent
- **Boolean indexing** enables powerful data filtering
- **`arange` vs `linspace`** serve different use cases
- **Random generators** need seeds for reproducibility
- **Preallocating** arrays improves performance
- Choose **array generation method** based on your needs
